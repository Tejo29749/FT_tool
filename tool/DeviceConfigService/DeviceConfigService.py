#
# Autogenerated by Thrift Compiler (0.14.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def getLastError(self):
        pass

    def getDevice(self):
        pass

    def initializeService(self):
        pass

    def initializeServiceByProtocol(self, diagProtocolHandle, qmiProtocolHandle):
        """
        Parameters:
         - diagProtocolHandle
         - qmiProtocolHandle

        """
        pass

    def initializeServiceWithOptions(self, connectionOptions):
        """
        Parameters:
         - connectionOptions

        """
        pass

    def destroyService(self):
        pass

    def doXqcnOperation(self, deviceConfigOptions):
        """
        Parameters:
         - deviceConfigOptions

        """
        pass

    def backupToXqcn(self, serviceProgrammingCode, resetUponCompletion, resetTimeout, filterFileContents):
        """
        Parameters:
         - serviceProgrammingCode
         - resetUponCompletion
         - resetTimeout
         - filterFileContents

        """
        pass

    def restoreFromXqcn(self, xqcnFileContents, serviceProgrammingCode, allowEsnMismatch, resetUponCompletion, resetTimeout, filterFileContents):
        """
        Parameters:
         - xqcnFileContents
         - serviceProgrammingCode
         - allowEsnMismatch
         - resetUponCompletion
         - resetTimeout
         - filterFileContents

        """
        pass

    def pdcGetMbnMaxStorage(self, mbnType):
        """
        Parameters:
         - mbnType

        """
        pass

    def pdcGetMbnStorageUsage(self, mbnType):
        """
        Parameters:
         - mbnType

        """
        pass

    def pdcGetMbnCount(self, mbnType):
        """
        Parameters:
         - mbnType

        """
        pass

    def pdcGetMbnList(self, mbnType):
        """
        Parameters:
         - mbnType

        """
        pass

    def pdcGetDefaultMbnInfo(self, mbnType):
        """
        Parameters:
         - mbnType

        """
        pass

    def pdcGetMbnId(self, mbnContent):
        """
        Parameters:
         - mbnContent

        """
        pass

    def pdcWriteMbn(self, mbnType, mbnContent):
        """
        Parameters:
         - mbnType
         - mbnContent

        """
        pass

    def pdcReadMbn(self, mbnType, mbnId, subId):
        """
        Parameters:
         - mbnType
         - mbnId
         - subId

        """
        pass

    def pdcRemoveMbn(self, mbnType, mbnId):
        """
        Parameters:
         - mbnType
         - mbnId

        """
        pass

    def pdcGetActiveMbn(self, mbnType, subId, slotId):
        """
        Parameters:
         - mbnType
         - subId
         - slotId

        """
        pass

    def pdcGetPendingMbn(self, mbnType, subId, slotId):
        """
        Parameters:
         - mbnType
         - subId
         - slotId

        """
        pass

    def pdcValidateMbn(self, mbnType, mbnId, subId, remotePath):
        """
        Parameters:
         - mbnType
         - mbnId
         - subId
         - remotePath

        """
        pass

    def pdcSelectMbn(self, mbnType, mbnId, subId, slotId):
        """
        Parameters:
         - mbnType
         - mbnId
         - subId
         - slotId

        """
        pass

    def pdcActivateMbn(self, mbnType, subId, slotId, mode, timeout):
        """
        Parameters:
         - mbnType
         - subId
         - slotId
         - mode
         - timeout

        """
        pass

    def pdcDeactivateMbn(self, mbnType, subId):
        """
        Parameters:
         - mbnType
         - subId

        """
        pass

    def pdcGetConfiguration(self, slotId, feature):
        """
        Parameters:
         - slotId
         - feature

        """
        pass

    def pdcSetConfiguration(self, slotId, feature, value):
        """
        Parameters:
         - slotId
         - feature
         - value

        """
        pass

    def nvIsItemSupported(self, nvItemNameOrId, subscriptionId):
        """
        Parameters:
         - nvItemNameOrId
         - subscriptionId

        """
        pass

    def nvReadItem(self, nvItemNameOrId, subscriptionId, index, returnConfig):
        """
        Parameters:
         - nvItemNameOrId
         - subscriptionId
         - index
         - returnConfig

        """
        pass

    def nvSetItem(self, nvItemNameOrId, valueList, subscriptionId):
        """
        Parameters:
         - nvItemNameOrId
         - valueList
         - subscriptionId

        """
        pass

    def nvSetOtpItem(self, nvItemNameOrId, valueList, subscriptionId):
        """
        Parameters:
         - nvItemNameOrId
         - valueList
         - subscriptionId

        """
        pass

    def nvGetAllItems(self):
        pass

    def nvGetItemDefinition(self, nvItemNameOrId):
        """
        Parameters:
         - nvItemNameOrId

        """
        pass

    def efsHasAlternateFileSystem(self):
        pass

    def efsCreateDirectory(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        pass

    def efsRemoveDirectory(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        pass

    def efsRemoveTree(self, pathName, efsSytem):
        """
        Parameters:
         - pathName
         - efsSytem

        """
        pass

    def efsGetDirectoryContents(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        pass

    def efsPutFile(self, pathName, buffer, efsSystem):
        """
        Parameters:
         - pathName
         - buffer
         - efsSystem

        """
        pass

    def efsGetFile(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        pass

    def efsDeleteFile(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        pass

    def efsRename(self, existingName, newName, efsSystem):
        """
        Parameters:
         - existingName
         - newName
         - efsSystem

        """
        pass

    def efsPathExists(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        pass

    def efsIsDirectory(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        pass

    def efsIsFile(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        pass

    def efsGetFileSize(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        pass

    def efsGetAvailableSpace(self, efsSystem):
        """
        Parameters:
         - efsSystem

        """
        pass

    def efsGetFileCheckSum(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        pass

    def efsGetFileAttributes(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        pass

    def efsIsReady(self):
        pass

    def createGoldenCopy(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        pass

    def createGoldenCopyV2(self, createGoldenCopyV2Options, efsSystem):
        """
        Parameters:
         - createGoldenCopyV2Options
         - efsSystem

        """
        pass

    def createCefsCopy(self, cefsSavePath, efsSystem):
        """
        Parameters:
         - cefsSavePath
         - efsSystem

        """
        pass

    def createFactoryEfsCopy(self, efsSystem, factoryEfsCopyOptions):
        """
        Parameters:
         - efsSystem
         - factoryEfsCopyOptions

        """
        pass

    def requestPrl(self, subscriptionId, index):
        """
        Parameters:
         - subscriptionId
         - index

        """
        pass

    def backupPrl(self):
        pass

    def restorePrl(self, xqcnFileContents):
        """
        Parameters:
         - xqcnFileContents

        """
        pass

    def sendPrl(self, subscriptionId, index, prlFileContents):
        """
        Parameters:
         - subscriptionId
         - index
         - prlFileContents

        """
        pass

    def forceEfsSync(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        pass

    def getEsn(self):
        pass

    def setEsn(self, esn):
        """
        Parameters:
         - esn

        """
        pass

    def getImei(self, subscriptionId):
        """
        Parameters:
         - subscriptionId

        """
        pass

    def setImei(self, imei, subscriptionId):
        """
        Parameters:
         - imei
         - subscriptionId

        """
        pass

    def getMeid(self, subscriptionId):
        """
        Parameters:
         - subscriptionId

        """
        pass

    def setMeid(self, meid, subscriptionId):
        """
        Parameters:
         - meid
         - subscriptionId

        """
        pass

    def checkSpc(self, spc):
        """
        Parameters:
         - spc

        """
        pass

    def provisionSpc(self, currentSpc, newSpc):
        """
        Parameters:
         - currentSpc
         - newSpc

        """
        pass

    def efsReadFromModemLog(self):
        pass

    def configureService(self, deviceConfigOptions):
        """
        Parameters:
         - deviceConfigOptions

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def getLastError(self):
        self.send_getLastError()
        return self.recv_getLastError()

    def send_getLastError(self):
        self._oprot.writeMessageBegin('getLastError', TMessageType.CALL, self._seqid)
        args = getLastError_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getLastError(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getLastError_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getLastError failed: unknown result")

    def getDevice(self):
        self.send_getDevice()
        return self.recv_getDevice()

    def send_getDevice(self):
        self._oprot.writeMessageBegin('getDevice', TMessageType.CALL, self._seqid)
        args = getDevice_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDevice(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDevice_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDevice failed: unknown result")

    def initializeService(self):
        self.send_initializeService()
        return self.recv_initializeService()

    def send_initializeService(self):
        self._oprot.writeMessageBegin('initializeService', TMessageType.CALL, self._seqid)
        args = initializeService_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_initializeService(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = initializeService_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "initializeService failed: unknown result")

    def initializeServiceByProtocol(self, diagProtocolHandle, qmiProtocolHandle):
        """
        Parameters:
         - diagProtocolHandle
         - qmiProtocolHandle

        """
        self.send_initializeServiceByProtocol(diagProtocolHandle, qmiProtocolHandle)
        return self.recv_initializeServiceByProtocol()

    def send_initializeServiceByProtocol(self, diagProtocolHandle, qmiProtocolHandle):
        self._oprot.writeMessageBegin('initializeServiceByProtocol', TMessageType.CALL, self._seqid)
        args = initializeServiceByProtocol_args()
        args.diagProtocolHandle = diagProtocolHandle
        args.qmiProtocolHandle = qmiProtocolHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_initializeServiceByProtocol(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = initializeServiceByProtocol_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "initializeServiceByProtocol failed: unknown result")

    def initializeServiceWithOptions(self, connectionOptions):
        """
        Parameters:
         - connectionOptions

        """
        self.send_initializeServiceWithOptions(connectionOptions)
        return self.recv_initializeServiceWithOptions()

    def send_initializeServiceWithOptions(self, connectionOptions):
        self._oprot.writeMessageBegin('initializeServiceWithOptions', TMessageType.CALL, self._seqid)
        args = initializeServiceWithOptions_args()
        args.connectionOptions = connectionOptions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_initializeServiceWithOptions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = initializeServiceWithOptions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "initializeServiceWithOptions failed: unknown result")

    def destroyService(self):
        self.send_destroyService()
        return self.recv_destroyService()

    def send_destroyService(self):
        self._oprot.writeMessageBegin('destroyService', TMessageType.CALL, self._seqid)
        args = destroyService_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_destroyService(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = destroyService_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "destroyService failed: unknown result")

    def doXqcnOperation(self, deviceConfigOptions):
        """
        Parameters:
         - deviceConfigOptions

        """
        self.send_doXqcnOperation(deviceConfigOptions)
        return self.recv_doXqcnOperation()

    def send_doXqcnOperation(self, deviceConfigOptions):
        self._oprot.writeMessageBegin('doXqcnOperation', TMessageType.CALL, self._seqid)
        args = doXqcnOperation_args()
        args.deviceConfigOptions = deviceConfigOptions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_doXqcnOperation(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = doXqcnOperation_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "doXqcnOperation failed: unknown result")

    def backupToXqcn(self, serviceProgrammingCode, resetUponCompletion, resetTimeout, filterFileContents):
        """
        Parameters:
         - serviceProgrammingCode
         - resetUponCompletion
         - resetTimeout
         - filterFileContents

        """
        self.send_backupToXqcn(serviceProgrammingCode, resetUponCompletion, resetTimeout, filterFileContents)
        return self.recv_backupToXqcn()

    def send_backupToXqcn(self, serviceProgrammingCode, resetUponCompletion, resetTimeout, filterFileContents):
        self._oprot.writeMessageBegin('backupToXqcn', TMessageType.CALL, self._seqid)
        args = backupToXqcn_args()
        args.serviceProgrammingCode = serviceProgrammingCode
        args.resetUponCompletion = resetUponCompletion
        args.resetTimeout = resetTimeout
        args.filterFileContents = filterFileContents
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_backupToXqcn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = backupToXqcn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "backupToXqcn failed: unknown result")

    def restoreFromXqcn(self, xqcnFileContents, serviceProgrammingCode, allowEsnMismatch, resetUponCompletion, resetTimeout, filterFileContents):
        """
        Parameters:
         - xqcnFileContents
         - serviceProgrammingCode
         - allowEsnMismatch
         - resetUponCompletion
         - resetTimeout
         - filterFileContents

        """
        self.send_restoreFromXqcn(xqcnFileContents, serviceProgrammingCode, allowEsnMismatch, resetUponCompletion, resetTimeout, filterFileContents)
        return self.recv_restoreFromXqcn()

    def send_restoreFromXqcn(self, xqcnFileContents, serviceProgrammingCode, allowEsnMismatch, resetUponCompletion, resetTimeout, filterFileContents):
        self._oprot.writeMessageBegin('restoreFromXqcn', TMessageType.CALL, self._seqid)
        args = restoreFromXqcn_args()
        args.xqcnFileContents = xqcnFileContents
        args.serviceProgrammingCode = serviceProgrammingCode
        args.allowEsnMismatch = allowEsnMismatch
        args.resetUponCompletion = resetUponCompletion
        args.resetTimeout = resetTimeout
        args.filterFileContents = filterFileContents
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_restoreFromXqcn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = restoreFromXqcn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "restoreFromXqcn failed: unknown result")

    def pdcGetMbnMaxStorage(self, mbnType):
        """
        Parameters:
         - mbnType

        """
        self.send_pdcGetMbnMaxStorage(mbnType)
        return self.recv_pdcGetMbnMaxStorage()

    def send_pdcGetMbnMaxStorage(self, mbnType):
        self._oprot.writeMessageBegin('pdcGetMbnMaxStorage', TMessageType.CALL, self._seqid)
        args = pdcGetMbnMaxStorage_args()
        args.mbnType = mbnType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pdcGetMbnMaxStorage(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pdcGetMbnMaxStorage_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pdcGetMbnMaxStorage failed: unknown result")

    def pdcGetMbnStorageUsage(self, mbnType):
        """
        Parameters:
         - mbnType

        """
        self.send_pdcGetMbnStorageUsage(mbnType)
        return self.recv_pdcGetMbnStorageUsage()

    def send_pdcGetMbnStorageUsage(self, mbnType):
        self._oprot.writeMessageBegin('pdcGetMbnStorageUsage', TMessageType.CALL, self._seqid)
        args = pdcGetMbnStorageUsage_args()
        args.mbnType = mbnType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pdcGetMbnStorageUsage(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pdcGetMbnStorageUsage_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pdcGetMbnStorageUsage failed: unknown result")

    def pdcGetMbnCount(self, mbnType):
        """
        Parameters:
         - mbnType

        """
        self.send_pdcGetMbnCount(mbnType)
        return self.recv_pdcGetMbnCount()

    def send_pdcGetMbnCount(self, mbnType):
        self._oprot.writeMessageBegin('pdcGetMbnCount', TMessageType.CALL, self._seqid)
        args = pdcGetMbnCount_args()
        args.mbnType = mbnType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pdcGetMbnCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pdcGetMbnCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pdcGetMbnCount failed: unknown result")

    def pdcGetMbnList(self, mbnType):
        """
        Parameters:
         - mbnType

        """
        self.send_pdcGetMbnList(mbnType)
        return self.recv_pdcGetMbnList()

    def send_pdcGetMbnList(self, mbnType):
        self._oprot.writeMessageBegin('pdcGetMbnList', TMessageType.CALL, self._seqid)
        args = pdcGetMbnList_args()
        args.mbnType = mbnType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pdcGetMbnList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pdcGetMbnList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pdcGetMbnList failed: unknown result")

    def pdcGetDefaultMbnInfo(self, mbnType):
        """
        Parameters:
         - mbnType

        """
        self.send_pdcGetDefaultMbnInfo(mbnType)
        return self.recv_pdcGetDefaultMbnInfo()

    def send_pdcGetDefaultMbnInfo(self, mbnType):
        self._oprot.writeMessageBegin('pdcGetDefaultMbnInfo', TMessageType.CALL, self._seqid)
        args = pdcGetDefaultMbnInfo_args()
        args.mbnType = mbnType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pdcGetDefaultMbnInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pdcGetDefaultMbnInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pdcGetDefaultMbnInfo failed: unknown result")

    def pdcGetMbnId(self, mbnContent):
        """
        Parameters:
         - mbnContent

        """
        self.send_pdcGetMbnId(mbnContent)
        return self.recv_pdcGetMbnId()

    def send_pdcGetMbnId(self, mbnContent):
        self._oprot.writeMessageBegin('pdcGetMbnId', TMessageType.CALL, self._seqid)
        args = pdcGetMbnId_args()
        args.mbnContent = mbnContent
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pdcGetMbnId(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pdcGetMbnId_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pdcGetMbnId failed: unknown result")

    def pdcWriteMbn(self, mbnType, mbnContent):
        """
        Parameters:
         - mbnType
         - mbnContent

        """
        self.send_pdcWriteMbn(mbnType, mbnContent)
        return self.recv_pdcWriteMbn()

    def send_pdcWriteMbn(self, mbnType, mbnContent):
        self._oprot.writeMessageBegin('pdcWriteMbn', TMessageType.CALL, self._seqid)
        args = pdcWriteMbn_args()
        args.mbnType = mbnType
        args.mbnContent = mbnContent
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pdcWriteMbn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pdcWriteMbn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pdcWriteMbn failed: unknown result")

    def pdcReadMbn(self, mbnType, mbnId, subId):
        """
        Parameters:
         - mbnType
         - mbnId
         - subId

        """
        self.send_pdcReadMbn(mbnType, mbnId, subId)
        return self.recv_pdcReadMbn()

    def send_pdcReadMbn(self, mbnType, mbnId, subId):
        self._oprot.writeMessageBegin('pdcReadMbn', TMessageType.CALL, self._seqid)
        args = pdcReadMbn_args()
        args.mbnType = mbnType
        args.mbnId = mbnId
        args.subId = subId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pdcReadMbn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pdcReadMbn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pdcReadMbn failed: unknown result")

    def pdcRemoveMbn(self, mbnType, mbnId):
        """
        Parameters:
         - mbnType
         - mbnId

        """
        self.send_pdcRemoveMbn(mbnType, mbnId)
        return self.recv_pdcRemoveMbn()

    def send_pdcRemoveMbn(self, mbnType, mbnId):
        self._oprot.writeMessageBegin('pdcRemoveMbn', TMessageType.CALL, self._seqid)
        args = pdcRemoveMbn_args()
        args.mbnType = mbnType
        args.mbnId = mbnId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pdcRemoveMbn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pdcRemoveMbn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pdcRemoveMbn failed: unknown result")

    def pdcGetActiveMbn(self, mbnType, subId, slotId):
        """
        Parameters:
         - mbnType
         - subId
         - slotId

        """
        self.send_pdcGetActiveMbn(mbnType, subId, slotId)
        return self.recv_pdcGetActiveMbn()

    def send_pdcGetActiveMbn(self, mbnType, subId, slotId):
        self._oprot.writeMessageBegin('pdcGetActiveMbn', TMessageType.CALL, self._seqid)
        args = pdcGetActiveMbn_args()
        args.mbnType = mbnType
        args.subId = subId
        args.slotId = slotId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pdcGetActiveMbn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pdcGetActiveMbn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pdcGetActiveMbn failed: unknown result")

    def pdcGetPendingMbn(self, mbnType, subId, slotId):
        """
        Parameters:
         - mbnType
         - subId
         - slotId

        """
        self.send_pdcGetPendingMbn(mbnType, subId, slotId)
        return self.recv_pdcGetPendingMbn()

    def send_pdcGetPendingMbn(self, mbnType, subId, slotId):
        self._oprot.writeMessageBegin('pdcGetPendingMbn', TMessageType.CALL, self._seqid)
        args = pdcGetPendingMbn_args()
        args.mbnType = mbnType
        args.subId = subId
        args.slotId = slotId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pdcGetPendingMbn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pdcGetPendingMbn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pdcGetPendingMbn failed: unknown result")

    def pdcValidateMbn(self, mbnType, mbnId, subId, remotePath):
        """
        Parameters:
         - mbnType
         - mbnId
         - subId
         - remotePath

        """
        self.send_pdcValidateMbn(mbnType, mbnId, subId, remotePath)
        return self.recv_pdcValidateMbn()

    def send_pdcValidateMbn(self, mbnType, mbnId, subId, remotePath):
        self._oprot.writeMessageBegin('pdcValidateMbn', TMessageType.CALL, self._seqid)
        args = pdcValidateMbn_args()
        args.mbnType = mbnType
        args.mbnId = mbnId
        args.subId = subId
        args.remotePath = remotePath
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pdcValidateMbn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pdcValidateMbn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pdcValidateMbn failed: unknown result")

    def pdcSelectMbn(self, mbnType, mbnId, subId, slotId):
        """
        Parameters:
         - mbnType
         - mbnId
         - subId
         - slotId

        """
        self.send_pdcSelectMbn(mbnType, mbnId, subId, slotId)
        return self.recv_pdcSelectMbn()

    def send_pdcSelectMbn(self, mbnType, mbnId, subId, slotId):
        self._oprot.writeMessageBegin('pdcSelectMbn', TMessageType.CALL, self._seqid)
        args = pdcSelectMbn_args()
        args.mbnType = mbnType
        args.mbnId = mbnId
        args.subId = subId
        args.slotId = slotId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pdcSelectMbn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pdcSelectMbn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pdcSelectMbn failed: unknown result")

    def pdcActivateMbn(self, mbnType, subId, slotId, mode, timeout):
        """
        Parameters:
         - mbnType
         - subId
         - slotId
         - mode
         - timeout

        """
        self.send_pdcActivateMbn(mbnType, subId, slotId, mode, timeout)
        return self.recv_pdcActivateMbn()

    def send_pdcActivateMbn(self, mbnType, subId, slotId, mode, timeout):
        self._oprot.writeMessageBegin('pdcActivateMbn', TMessageType.CALL, self._seqid)
        args = pdcActivateMbn_args()
        args.mbnType = mbnType
        args.subId = subId
        args.slotId = slotId
        args.mode = mode
        args.timeout = timeout
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pdcActivateMbn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pdcActivateMbn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pdcActivateMbn failed: unknown result")

    def pdcDeactivateMbn(self, mbnType, subId):
        """
        Parameters:
         - mbnType
         - subId

        """
        self.send_pdcDeactivateMbn(mbnType, subId)
        return self.recv_pdcDeactivateMbn()

    def send_pdcDeactivateMbn(self, mbnType, subId):
        self._oprot.writeMessageBegin('pdcDeactivateMbn', TMessageType.CALL, self._seqid)
        args = pdcDeactivateMbn_args()
        args.mbnType = mbnType
        args.subId = subId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pdcDeactivateMbn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pdcDeactivateMbn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pdcDeactivateMbn failed: unknown result")

    def pdcGetConfiguration(self, slotId, feature):
        """
        Parameters:
         - slotId
         - feature

        """
        self.send_pdcGetConfiguration(slotId, feature)
        return self.recv_pdcGetConfiguration()

    def send_pdcGetConfiguration(self, slotId, feature):
        self._oprot.writeMessageBegin('pdcGetConfiguration', TMessageType.CALL, self._seqid)
        args = pdcGetConfiguration_args()
        args.slotId = slotId
        args.feature = feature
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pdcGetConfiguration(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pdcGetConfiguration_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pdcGetConfiguration failed: unknown result")

    def pdcSetConfiguration(self, slotId, feature, value):
        """
        Parameters:
         - slotId
         - feature
         - value

        """
        self.send_pdcSetConfiguration(slotId, feature, value)
        return self.recv_pdcSetConfiguration()

    def send_pdcSetConfiguration(self, slotId, feature, value):
        self._oprot.writeMessageBegin('pdcSetConfiguration', TMessageType.CALL, self._seqid)
        args = pdcSetConfiguration_args()
        args.slotId = slotId
        args.feature = feature
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pdcSetConfiguration(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pdcSetConfiguration_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pdcSetConfiguration failed: unknown result")

    def nvIsItemSupported(self, nvItemNameOrId, subscriptionId):
        """
        Parameters:
         - nvItemNameOrId
         - subscriptionId

        """
        self.send_nvIsItemSupported(nvItemNameOrId, subscriptionId)
        return self.recv_nvIsItemSupported()

    def send_nvIsItemSupported(self, nvItemNameOrId, subscriptionId):
        self._oprot.writeMessageBegin('nvIsItemSupported', TMessageType.CALL, self._seqid)
        args = nvIsItemSupported_args()
        args.nvItemNameOrId = nvItemNameOrId
        args.subscriptionId = subscriptionId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_nvIsItemSupported(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = nvIsItemSupported_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "nvIsItemSupported failed: unknown result")

    def nvReadItem(self, nvItemNameOrId, subscriptionId, index, returnConfig):
        """
        Parameters:
         - nvItemNameOrId
         - subscriptionId
         - index
         - returnConfig

        """
        self.send_nvReadItem(nvItemNameOrId, subscriptionId, index, returnConfig)
        return self.recv_nvReadItem()

    def send_nvReadItem(self, nvItemNameOrId, subscriptionId, index, returnConfig):
        self._oprot.writeMessageBegin('nvReadItem', TMessageType.CALL, self._seqid)
        args = nvReadItem_args()
        args.nvItemNameOrId = nvItemNameOrId
        args.subscriptionId = subscriptionId
        args.index = index
        args.returnConfig = returnConfig
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_nvReadItem(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = nvReadItem_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "nvReadItem failed: unknown result")

    def nvSetItem(self, nvItemNameOrId, valueList, subscriptionId):
        """
        Parameters:
         - nvItemNameOrId
         - valueList
         - subscriptionId

        """
        self.send_nvSetItem(nvItemNameOrId, valueList, subscriptionId)
        return self.recv_nvSetItem()

    def send_nvSetItem(self, nvItemNameOrId, valueList, subscriptionId):
        self._oprot.writeMessageBegin('nvSetItem', TMessageType.CALL, self._seqid)
        args = nvSetItem_args()
        args.nvItemNameOrId = nvItemNameOrId
        args.valueList = valueList
        args.subscriptionId = subscriptionId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_nvSetItem(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = nvSetItem_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "nvSetItem failed: unknown result")

    def nvSetOtpItem(self, nvItemNameOrId, valueList, subscriptionId):
        """
        Parameters:
         - nvItemNameOrId
         - valueList
         - subscriptionId

        """
        self.send_nvSetOtpItem(nvItemNameOrId, valueList, subscriptionId)
        return self.recv_nvSetOtpItem()

    def send_nvSetOtpItem(self, nvItemNameOrId, valueList, subscriptionId):
        self._oprot.writeMessageBegin('nvSetOtpItem', TMessageType.CALL, self._seqid)
        args = nvSetOtpItem_args()
        args.nvItemNameOrId = nvItemNameOrId
        args.valueList = valueList
        args.subscriptionId = subscriptionId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_nvSetOtpItem(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = nvSetOtpItem_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "nvSetOtpItem failed: unknown result")

    def nvGetAllItems(self):
        self.send_nvGetAllItems()
        return self.recv_nvGetAllItems()

    def send_nvGetAllItems(self):
        self._oprot.writeMessageBegin('nvGetAllItems', TMessageType.CALL, self._seqid)
        args = nvGetAllItems_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_nvGetAllItems(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = nvGetAllItems_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "nvGetAllItems failed: unknown result")

    def nvGetItemDefinition(self, nvItemNameOrId):
        """
        Parameters:
         - nvItemNameOrId

        """
        self.send_nvGetItemDefinition(nvItemNameOrId)
        return self.recv_nvGetItemDefinition()

    def send_nvGetItemDefinition(self, nvItemNameOrId):
        self._oprot.writeMessageBegin('nvGetItemDefinition', TMessageType.CALL, self._seqid)
        args = nvGetItemDefinition_args()
        args.nvItemNameOrId = nvItemNameOrId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_nvGetItemDefinition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = nvGetItemDefinition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "nvGetItemDefinition failed: unknown result")

    def efsHasAlternateFileSystem(self):
        self.send_efsHasAlternateFileSystem()
        return self.recv_efsHasAlternateFileSystem()

    def send_efsHasAlternateFileSystem(self):
        self._oprot.writeMessageBegin('efsHasAlternateFileSystem', TMessageType.CALL, self._seqid)
        args = efsHasAlternateFileSystem_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_efsHasAlternateFileSystem(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = efsHasAlternateFileSystem_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "efsHasAlternateFileSystem failed: unknown result")

    def efsCreateDirectory(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        self.send_efsCreateDirectory(pathName, efsSystem)
        return self.recv_efsCreateDirectory()

    def send_efsCreateDirectory(self, pathName, efsSystem):
        self._oprot.writeMessageBegin('efsCreateDirectory', TMessageType.CALL, self._seqid)
        args = efsCreateDirectory_args()
        args.pathName = pathName
        args.efsSystem = efsSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_efsCreateDirectory(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = efsCreateDirectory_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "efsCreateDirectory failed: unknown result")

    def efsRemoveDirectory(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        self.send_efsRemoveDirectory(pathName, efsSystem)
        return self.recv_efsRemoveDirectory()

    def send_efsRemoveDirectory(self, pathName, efsSystem):
        self._oprot.writeMessageBegin('efsRemoveDirectory', TMessageType.CALL, self._seqid)
        args = efsRemoveDirectory_args()
        args.pathName = pathName
        args.efsSystem = efsSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_efsRemoveDirectory(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = efsRemoveDirectory_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "efsRemoveDirectory failed: unknown result")

    def efsRemoveTree(self, pathName, efsSytem):
        """
        Parameters:
         - pathName
         - efsSytem

        """
        self.send_efsRemoveTree(pathName, efsSytem)
        return self.recv_efsRemoveTree()

    def send_efsRemoveTree(self, pathName, efsSytem):
        self._oprot.writeMessageBegin('efsRemoveTree', TMessageType.CALL, self._seqid)
        args = efsRemoveTree_args()
        args.pathName = pathName
        args.efsSytem = efsSytem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_efsRemoveTree(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = efsRemoveTree_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "efsRemoveTree failed: unknown result")

    def efsGetDirectoryContents(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        self.send_efsGetDirectoryContents(pathName, efsSystem)
        return self.recv_efsGetDirectoryContents()

    def send_efsGetDirectoryContents(self, pathName, efsSystem):
        self._oprot.writeMessageBegin('efsGetDirectoryContents', TMessageType.CALL, self._seqid)
        args = efsGetDirectoryContents_args()
        args.pathName = pathName
        args.efsSystem = efsSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_efsGetDirectoryContents(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = efsGetDirectoryContents_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "efsGetDirectoryContents failed: unknown result")

    def efsPutFile(self, pathName, buffer, efsSystem):
        """
        Parameters:
         - pathName
         - buffer
         - efsSystem

        """
        self.send_efsPutFile(pathName, buffer, efsSystem)
        return self.recv_efsPutFile()

    def send_efsPutFile(self, pathName, buffer, efsSystem):
        self._oprot.writeMessageBegin('efsPutFile', TMessageType.CALL, self._seqid)
        args = efsPutFile_args()
        args.pathName = pathName
        args.buffer = buffer
        args.efsSystem = efsSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_efsPutFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = efsPutFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "efsPutFile failed: unknown result")

    def efsGetFile(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        self.send_efsGetFile(pathName, efsSystem)
        return self.recv_efsGetFile()

    def send_efsGetFile(self, pathName, efsSystem):
        self._oprot.writeMessageBegin('efsGetFile', TMessageType.CALL, self._seqid)
        args = efsGetFile_args()
        args.pathName = pathName
        args.efsSystem = efsSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_efsGetFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = efsGetFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "efsGetFile failed: unknown result")

    def efsDeleteFile(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        self.send_efsDeleteFile(pathName, efsSystem)
        return self.recv_efsDeleteFile()

    def send_efsDeleteFile(self, pathName, efsSystem):
        self._oprot.writeMessageBegin('efsDeleteFile', TMessageType.CALL, self._seqid)
        args = efsDeleteFile_args()
        args.pathName = pathName
        args.efsSystem = efsSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_efsDeleteFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = efsDeleteFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "efsDeleteFile failed: unknown result")

    def efsRename(self, existingName, newName, efsSystem):
        """
        Parameters:
         - existingName
         - newName
         - efsSystem

        """
        self.send_efsRename(existingName, newName, efsSystem)
        return self.recv_efsRename()

    def send_efsRename(self, existingName, newName, efsSystem):
        self._oprot.writeMessageBegin('efsRename', TMessageType.CALL, self._seqid)
        args = efsRename_args()
        args.existingName = existingName
        args.newName = newName
        args.efsSystem = efsSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_efsRename(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = efsRename_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "efsRename failed: unknown result")

    def efsPathExists(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        self.send_efsPathExists(pathName, efsSystem)
        return self.recv_efsPathExists()

    def send_efsPathExists(self, pathName, efsSystem):
        self._oprot.writeMessageBegin('efsPathExists', TMessageType.CALL, self._seqid)
        args = efsPathExists_args()
        args.pathName = pathName
        args.efsSystem = efsSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_efsPathExists(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = efsPathExists_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "efsPathExists failed: unknown result")

    def efsIsDirectory(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        self.send_efsIsDirectory(pathName, efsSystem)
        return self.recv_efsIsDirectory()

    def send_efsIsDirectory(self, pathName, efsSystem):
        self._oprot.writeMessageBegin('efsIsDirectory', TMessageType.CALL, self._seqid)
        args = efsIsDirectory_args()
        args.pathName = pathName
        args.efsSystem = efsSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_efsIsDirectory(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = efsIsDirectory_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "efsIsDirectory failed: unknown result")

    def efsIsFile(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        self.send_efsIsFile(pathName, efsSystem)
        return self.recv_efsIsFile()

    def send_efsIsFile(self, pathName, efsSystem):
        self._oprot.writeMessageBegin('efsIsFile', TMessageType.CALL, self._seqid)
        args = efsIsFile_args()
        args.pathName = pathName
        args.efsSystem = efsSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_efsIsFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = efsIsFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "efsIsFile failed: unknown result")

    def efsGetFileSize(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        self.send_efsGetFileSize(pathName, efsSystem)
        return self.recv_efsGetFileSize()

    def send_efsGetFileSize(self, pathName, efsSystem):
        self._oprot.writeMessageBegin('efsGetFileSize', TMessageType.CALL, self._seqid)
        args = efsGetFileSize_args()
        args.pathName = pathName
        args.efsSystem = efsSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_efsGetFileSize(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = efsGetFileSize_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "efsGetFileSize failed: unknown result")

    def efsGetAvailableSpace(self, efsSystem):
        """
        Parameters:
         - efsSystem

        """
        self.send_efsGetAvailableSpace(efsSystem)
        return self.recv_efsGetAvailableSpace()

    def send_efsGetAvailableSpace(self, efsSystem):
        self._oprot.writeMessageBegin('efsGetAvailableSpace', TMessageType.CALL, self._seqid)
        args = efsGetAvailableSpace_args()
        args.efsSystem = efsSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_efsGetAvailableSpace(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = efsGetAvailableSpace_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "efsGetAvailableSpace failed: unknown result")

    def efsGetFileCheckSum(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        self.send_efsGetFileCheckSum(pathName, efsSystem)
        return self.recv_efsGetFileCheckSum()

    def send_efsGetFileCheckSum(self, pathName, efsSystem):
        self._oprot.writeMessageBegin('efsGetFileCheckSum', TMessageType.CALL, self._seqid)
        args = efsGetFileCheckSum_args()
        args.pathName = pathName
        args.efsSystem = efsSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_efsGetFileCheckSum(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = efsGetFileCheckSum_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "efsGetFileCheckSum failed: unknown result")

    def efsGetFileAttributes(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        self.send_efsGetFileAttributes(pathName, efsSystem)
        return self.recv_efsGetFileAttributes()

    def send_efsGetFileAttributes(self, pathName, efsSystem):
        self._oprot.writeMessageBegin('efsGetFileAttributes', TMessageType.CALL, self._seqid)
        args = efsGetFileAttributes_args()
        args.pathName = pathName
        args.efsSystem = efsSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_efsGetFileAttributes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = efsGetFileAttributes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "efsGetFileAttributes failed: unknown result")

    def efsIsReady(self):
        self.send_efsIsReady()
        return self.recv_efsIsReady()

    def send_efsIsReady(self):
        self._oprot.writeMessageBegin('efsIsReady', TMessageType.CALL, self._seqid)
        args = efsIsReady_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_efsIsReady(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = efsIsReady_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "efsIsReady failed: unknown result")

    def createGoldenCopy(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        self.send_createGoldenCopy(pathName, efsSystem)
        return self.recv_createGoldenCopy()

    def send_createGoldenCopy(self, pathName, efsSystem):
        self._oprot.writeMessageBegin('createGoldenCopy', TMessageType.CALL, self._seqid)
        args = createGoldenCopy_args()
        args.pathName = pathName
        args.efsSystem = efsSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createGoldenCopy(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createGoldenCopy_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createGoldenCopy failed: unknown result")

    def createGoldenCopyV2(self, createGoldenCopyV2Options, efsSystem):
        """
        Parameters:
         - createGoldenCopyV2Options
         - efsSystem

        """
        self.send_createGoldenCopyV2(createGoldenCopyV2Options, efsSystem)
        return self.recv_createGoldenCopyV2()

    def send_createGoldenCopyV2(self, createGoldenCopyV2Options, efsSystem):
        self._oprot.writeMessageBegin('createGoldenCopyV2', TMessageType.CALL, self._seqid)
        args = createGoldenCopyV2_args()
        args.createGoldenCopyV2Options = createGoldenCopyV2Options
        args.efsSystem = efsSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createGoldenCopyV2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createGoldenCopyV2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createGoldenCopyV2 failed: unknown result")

    def createCefsCopy(self, cefsSavePath, efsSystem):
        """
        Parameters:
         - cefsSavePath
         - efsSystem

        """
        self.send_createCefsCopy(cefsSavePath, efsSystem)
        return self.recv_createCefsCopy()

    def send_createCefsCopy(self, cefsSavePath, efsSystem):
        self._oprot.writeMessageBegin('createCefsCopy', TMessageType.CALL, self._seqid)
        args = createCefsCopy_args()
        args.cefsSavePath = cefsSavePath
        args.efsSystem = efsSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createCefsCopy(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createCefsCopy_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createCefsCopy failed: unknown result")

    def createFactoryEfsCopy(self, efsSystem, factoryEfsCopyOptions):
        """
        Parameters:
         - efsSystem
         - factoryEfsCopyOptions

        """
        self.send_createFactoryEfsCopy(efsSystem, factoryEfsCopyOptions)
        return self.recv_createFactoryEfsCopy()

    def send_createFactoryEfsCopy(self, efsSystem, factoryEfsCopyOptions):
        self._oprot.writeMessageBegin('createFactoryEfsCopy', TMessageType.CALL, self._seqid)
        args = createFactoryEfsCopy_args()
        args.efsSystem = efsSystem
        args.factoryEfsCopyOptions = factoryEfsCopyOptions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createFactoryEfsCopy(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createFactoryEfsCopy_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createFactoryEfsCopy failed: unknown result")

    def requestPrl(self, subscriptionId, index):
        """
        Parameters:
         - subscriptionId
         - index

        """
        self.send_requestPrl(subscriptionId, index)
        return self.recv_requestPrl()

    def send_requestPrl(self, subscriptionId, index):
        self._oprot.writeMessageBegin('requestPrl', TMessageType.CALL, self._seqid)
        args = requestPrl_args()
        args.subscriptionId = subscriptionId
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_requestPrl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = requestPrl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "requestPrl failed: unknown result")

    def backupPrl(self):
        self.send_backupPrl()
        return self.recv_backupPrl()

    def send_backupPrl(self):
        self._oprot.writeMessageBegin('backupPrl', TMessageType.CALL, self._seqid)
        args = backupPrl_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_backupPrl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = backupPrl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "backupPrl failed: unknown result")

    def restorePrl(self, xqcnFileContents):
        """
        Parameters:
         - xqcnFileContents

        """
        self.send_restorePrl(xqcnFileContents)
        return self.recv_restorePrl()

    def send_restorePrl(self, xqcnFileContents):
        self._oprot.writeMessageBegin('restorePrl', TMessageType.CALL, self._seqid)
        args = restorePrl_args()
        args.xqcnFileContents = xqcnFileContents
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_restorePrl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = restorePrl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "restorePrl failed: unknown result")

    def sendPrl(self, subscriptionId, index, prlFileContents):
        """
        Parameters:
         - subscriptionId
         - index
         - prlFileContents

        """
        self.send_sendPrl(subscriptionId, index, prlFileContents)
        return self.recv_sendPrl()

    def send_sendPrl(self, subscriptionId, index, prlFileContents):
        self._oprot.writeMessageBegin('sendPrl', TMessageType.CALL, self._seqid)
        args = sendPrl_args()
        args.subscriptionId = subscriptionId
        args.index = index
        args.prlFileContents = prlFileContents
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sendPrl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sendPrl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sendPrl failed: unknown result")

    def forceEfsSync(self, pathName, efsSystem):
        """
        Parameters:
         - pathName
         - efsSystem

        """
        self.send_forceEfsSync(pathName, efsSystem)
        return self.recv_forceEfsSync()

    def send_forceEfsSync(self, pathName, efsSystem):
        self._oprot.writeMessageBegin('forceEfsSync', TMessageType.CALL, self._seqid)
        args = forceEfsSync_args()
        args.pathName = pathName
        args.efsSystem = efsSystem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forceEfsSync(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forceEfsSync_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "forceEfsSync failed: unknown result")

    def getEsn(self):
        self.send_getEsn()
        return self.recv_getEsn()

    def send_getEsn(self):
        self._oprot.writeMessageBegin('getEsn', TMessageType.CALL, self._seqid)
        args = getEsn_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getEsn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getEsn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getEsn failed: unknown result")

    def setEsn(self, esn):
        """
        Parameters:
         - esn

        """
        self.send_setEsn(esn)
        return self.recv_setEsn()

    def send_setEsn(self, esn):
        self._oprot.writeMessageBegin('setEsn', TMessageType.CALL, self._seqid)
        args = setEsn_args()
        args.esn = esn
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setEsn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setEsn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "setEsn failed: unknown result")

    def getImei(self, subscriptionId):
        """
        Parameters:
         - subscriptionId

        """
        self.send_getImei(subscriptionId)
        return self.recv_getImei()

    def send_getImei(self, subscriptionId):
        self._oprot.writeMessageBegin('getImei', TMessageType.CALL, self._seqid)
        args = getImei_args()
        args.subscriptionId = subscriptionId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getImei(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getImei_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getImei failed: unknown result")

    def setImei(self, imei, subscriptionId):
        """
        Parameters:
         - imei
         - subscriptionId

        """
        self.send_setImei(imei, subscriptionId)
        return self.recv_setImei()

    def send_setImei(self, imei, subscriptionId):
        self._oprot.writeMessageBegin('setImei', TMessageType.CALL, self._seqid)
        args = setImei_args()
        args.imei = imei
        args.subscriptionId = subscriptionId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setImei(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setImei_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "setImei failed: unknown result")

    def getMeid(self, subscriptionId):
        """
        Parameters:
         - subscriptionId

        """
        self.send_getMeid(subscriptionId)
        return self.recv_getMeid()

    def send_getMeid(self, subscriptionId):
        self._oprot.writeMessageBegin('getMeid', TMessageType.CALL, self._seqid)
        args = getMeid_args()
        args.subscriptionId = subscriptionId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMeid(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMeid_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getMeid failed: unknown result")

    def setMeid(self, meid, subscriptionId):
        """
        Parameters:
         - meid
         - subscriptionId

        """
        self.send_setMeid(meid, subscriptionId)
        return self.recv_setMeid()

    def send_setMeid(self, meid, subscriptionId):
        self._oprot.writeMessageBegin('setMeid', TMessageType.CALL, self._seqid)
        args = setMeid_args()
        args.meid = meid
        args.subscriptionId = subscriptionId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setMeid(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setMeid_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "setMeid failed: unknown result")

    def checkSpc(self, spc):
        """
        Parameters:
         - spc

        """
        self.send_checkSpc(spc)
        return self.recv_checkSpc()

    def send_checkSpc(self, spc):
        self._oprot.writeMessageBegin('checkSpc', TMessageType.CALL, self._seqid)
        args = checkSpc_args()
        args.spc = spc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_checkSpc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = checkSpc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "checkSpc failed: unknown result")

    def provisionSpc(self, currentSpc, newSpc):
        """
        Parameters:
         - currentSpc
         - newSpc

        """
        self.send_provisionSpc(currentSpc, newSpc)
        return self.recv_provisionSpc()

    def send_provisionSpc(self, currentSpc, newSpc):
        self._oprot.writeMessageBegin('provisionSpc', TMessageType.CALL, self._seqid)
        args = provisionSpc_args()
        args.currentSpc = currentSpc
        args.newSpc = newSpc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_provisionSpc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = provisionSpc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "provisionSpc failed: unknown result")

    def efsReadFromModemLog(self):
        self.send_efsReadFromModemLog()
        return self.recv_efsReadFromModemLog()

    def send_efsReadFromModemLog(self):
        self._oprot.writeMessageBegin('efsReadFromModemLog', TMessageType.CALL, self._seqid)
        args = efsReadFromModemLog_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_efsReadFromModemLog(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = efsReadFromModemLog_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "efsReadFromModemLog failed: unknown result")

    def configureService(self, deviceConfigOptions):
        """
        Parameters:
         - deviceConfigOptions

        """
        self.send_configureService(deviceConfigOptions)
        return self.recv_configureService()

    def send_configureService(self, deviceConfigOptions):
        self._oprot.writeMessageBegin('configureService', TMessageType.CALL, self._seqid)
        args = configureService_args()
        args.deviceConfigOptions = deviceConfigOptions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_configureService(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = configureService_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "configureService failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["getLastError"] = Processor.process_getLastError
        self._processMap["getDevice"] = Processor.process_getDevice
        self._processMap["initializeService"] = Processor.process_initializeService
        self._processMap["initializeServiceByProtocol"] = Processor.process_initializeServiceByProtocol
        self._processMap["initializeServiceWithOptions"] = Processor.process_initializeServiceWithOptions
        self._processMap["destroyService"] = Processor.process_destroyService
        self._processMap["doXqcnOperation"] = Processor.process_doXqcnOperation
        self._processMap["backupToXqcn"] = Processor.process_backupToXqcn
        self._processMap["restoreFromXqcn"] = Processor.process_restoreFromXqcn
        self._processMap["pdcGetMbnMaxStorage"] = Processor.process_pdcGetMbnMaxStorage
        self._processMap["pdcGetMbnStorageUsage"] = Processor.process_pdcGetMbnStorageUsage
        self._processMap["pdcGetMbnCount"] = Processor.process_pdcGetMbnCount
        self._processMap["pdcGetMbnList"] = Processor.process_pdcGetMbnList
        self._processMap["pdcGetDefaultMbnInfo"] = Processor.process_pdcGetDefaultMbnInfo
        self._processMap["pdcGetMbnId"] = Processor.process_pdcGetMbnId
        self._processMap["pdcWriteMbn"] = Processor.process_pdcWriteMbn
        self._processMap["pdcReadMbn"] = Processor.process_pdcReadMbn
        self._processMap["pdcRemoveMbn"] = Processor.process_pdcRemoveMbn
        self._processMap["pdcGetActiveMbn"] = Processor.process_pdcGetActiveMbn
        self._processMap["pdcGetPendingMbn"] = Processor.process_pdcGetPendingMbn
        self._processMap["pdcValidateMbn"] = Processor.process_pdcValidateMbn
        self._processMap["pdcSelectMbn"] = Processor.process_pdcSelectMbn
        self._processMap["pdcActivateMbn"] = Processor.process_pdcActivateMbn
        self._processMap["pdcDeactivateMbn"] = Processor.process_pdcDeactivateMbn
        self._processMap["pdcGetConfiguration"] = Processor.process_pdcGetConfiguration
        self._processMap["pdcSetConfiguration"] = Processor.process_pdcSetConfiguration
        self._processMap["nvIsItemSupported"] = Processor.process_nvIsItemSupported
        self._processMap["nvReadItem"] = Processor.process_nvReadItem
        self._processMap["nvSetItem"] = Processor.process_nvSetItem
        self._processMap["nvSetOtpItem"] = Processor.process_nvSetOtpItem
        self._processMap["nvGetAllItems"] = Processor.process_nvGetAllItems
        self._processMap["nvGetItemDefinition"] = Processor.process_nvGetItemDefinition
        self._processMap["efsHasAlternateFileSystem"] = Processor.process_efsHasAlternateFileSystem
        self._processMap["efsCreateDirectory"] = Processor.process_efsCreateDirectory
        self._processMap["efsRemoveDirectory"] = Processor.process_efsRemoveDirectory
        self._processMap["efsRemoveTree"] = Processor.process_efsRemoveTree
        self._processMap["efsGetDirectoryContents"] = Processor.process_efsGetDirectoryContents
        self._processMap["efsPutFile"] = Processor.process_efsPutFile
        self._processMap["efsGetFile"] = Processor.process_efsGetFile
        self._processMap["efsDeleteFile"] = Processor.process_efsDeleteFile
        self._processMap["efsRename"] = Processor.process_efsRename
        self._processMap["efsPathExists"] = Processor.process_efsPathExists
        self._processMap["efsIsDirectory"] = Processor.process_efsIsDirectory
        self._processMap["efsIsFile"] = Processor.process_efsIsFile
        self._processMap["efsGetFileSize"] = Processor.process_efsGetFileSize
        self._processMap["efsGetAvailableSpace"] = Processor.process_efsGetAvailableSpace
        self._processMap["efsGetFileCheckSum"] = Processor.process_efsGetFileCheckSum
        self._processMap["efsGetFileAttributes"] = Processor.process_efsGetFileAttributes
        self._processMap["efsIsReady"] = Processor.process_efsIsReady
        self._processMap["createGoldenCopy"] = Processor.process_createGoldenCopy
        self._processMap["createGoldenCopyV2"] = Processor.process_createGoldenCopyV2
        self._processMap["createCefsCopy"] = Processor.process_createCefsCopy
        self._processMap["createFactoryEfsCopy"] = Processor.process_createFactoryEfsCopy
        self._processMap["requestPrl"] = Processor.process_requestPrl
        self._processMap["backupPrl"] = Processor.process_backupPrl
        self._processMap["restorePrl"] = Processor.process_restorePrl
        self._processMap["sendPrl"] = Processor.process_sendPrl
        self._processMap["forceEfsSync"] = Processor.process_forceEfsSync
        self._processMap["getEsn"] = Processor.process_getEsn
        self._processMap["setEsn"] = Processor.process_setEsn
        self._processMap["getImei"] = Processor.process_getImei
        self._processMap["setImei"] = Processor.process_setImei
        self._processMap["getMeid"] = Processor.process_getMeid
        self._processMap["setMeid"] = Processor.process_setMeid
        self._processMap["checkSpc"] = Processor.process_checkSpc
        self._processMap["provisionSpc"] = Processor.process_provisionSpc
        self._processMap["efsReadFromModemLog"] = Processor.process_efsReadFromModemLog
        self._processMap["configureService"] = Processor.process_configureService
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_getLastError(self, seqid, iprot, oprot):
        args = getLastError_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getLastError_result()
        try:
            result.success = self._handler.getLastError()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getLastError", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDevice(self, seqid, iprot, oprot):
        args = getDevice_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDevice_result()
        try:
            result.success = self._handler.getDevice()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDevice", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_initializeService(self, seqid, iprot, oprot):
        args = initializeService_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = initializeService_result()
        try:
            result.success = self._handler.initializeService()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("initializeService", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_initializeServiceByProtocol(self, seqid, iprot, oprot):
        args = initializeServiceByProtocol_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = initializeServiceByProtocol_result()
        try:
            result.success = self._handler.initializeServiceByProtocol(args.diagProtocolHandle, args.qmiProtocolHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("initializeServiceByProtocol", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_initializeServiceWithOptions(self, seqid, iprot, oprot):
        args = initializeServiceWithOptions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = initializeServiceWithOptions_result()
        try:
            result.success = self._handler.initializeServiceWithOptions(args.connectionOptions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("initializeServiceWithOptions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_destroyService(self, seqid, iprot, oprot):
        args = destroyService_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = destroyService_result()
        try:
            result.success = self._handler.destroyService()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("destroyService", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_doXqcnOperation(self, seqid, iprot, oprot):
        args = doXqcnOperation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = doXqcnOperation_result()
        try:
            result.success = self._handler.doXqcnOperation(args.deviceConfigOptions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("doXqcnOperation", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_backupToXqcn(self, seqid, iprot, oprot):
        args = backupToXqcn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = backupToXqcn_result()
        try:
            result.success = self._handler.backupToXqcn(args.serviceProgrammingCode, args.resetUponCompletion, args.resetTimeout, args.filterFileContents)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("backupToXqcn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_restoreFromXqcn(self, seqid, iprot, oprot):
        args = restoreFromXqcn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = restoreFromXqcn_result()
        try:
            result.success = self._handler.restoreFromXqcn(args.xqcnFileContents, args.serviceProgrammingCode, args.allowEsnMismatch, args.resetUponCompletion, args.resetTimeout, args.filterFileContents)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("restoreFromXqcn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pdcGetMbnMaxStorage(self, seqid, iprot, oprot):
        args = pdcGetMbnMaxStorage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pdcGetMbnMaxStorage_result()
        try:
            result.success = self._handler.pdcGetMbnMaxStorage(args.mbnType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pdcGetMbnMaxStorage", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pdcGetMbnStorageUsage(self, seqid, iprot, oprot):
        args = pdcGetMbnStorageUsage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pdcGetMbnStorageUsage_result()
        try:
            result.success = self._handler.pdcGetMbnStorageUsage(args.mbnType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pdcGetMbnStorageUsage", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pdcGetMbnCount(self, seqid, iprot, oprot):
        args = pdcGetMbnCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pdcGetMbnCount_result()
        try:
            result.success = self._handler.pdcGetMbnCount(args.mbnType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pdcGetMbnCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pdcGetMbnList(self, seqid, iprot, oprot):
        args = pdcGetMbnList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pdcGetMbnList_result()
        try:
            result.success = self._handler.pdcGetMbnList(args.mbnType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pdcGetMbnList", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pdcGetDefaultMbnInfo(self, seqid, iprot, oprot):
        args = pdcGetDefaultMbnInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pdcGetDefaultMbnInfo_result()
        try:
            result.success = self._handler.pdcGetDefaultMbnInfo(args.mbnType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pdcGetDefaultMbnInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pdcGetMbnId(self, seqid, iprot, oprot):
        args = pdcGetMbnId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pdcGetMbnId_result()
        try:
            result.success = self._handler.pdcGetMbnId(args.mbnContent)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pdcGetMbnId", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pdcWriteMbn(self, seqid, iprot, oprot):
        args = pdcWriteMbn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pdcWriteMbn_result()
        try:
            result.success = self._handler.pdcWriteMbn(args.mbnType, args.mbnContent)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pdcWriteMbn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pdcReadMbn(self, seqid, iprot, oprot):
        args = pdcReadMbn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pdcReadMbn_result()
        try:
            result.success = self._handler.pdcReadMbn(args.mbnType, args.mbnId, args.subId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pdcReadMbn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pdcRemoveMbn(self, seqid, iprot, oprot):
        args = pdcRemoveMbn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pdcRemoveMbn_result()
        try:
            result.success = self._handler.pdcRemoveMbn(args.mbnType, args.mbnId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pdcRemoveMbn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pdcGetActiveMbn(self, seqid, iprot, oprot):
        args = pdcGetActiveMbn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pdcGetActiveMbn_result()
        try:
            result.success = self._handler.pdcGetActiveMbn(args.mbnType, args.subId, args.slotId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pdcGetActiveMbn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pdcGetPendingMbn(self, seqid, iprot, oprot):
        args = pdcGetPendingMbn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pdcGetPendingMbn_result()
        try:
            result.success = self._handler.pdcGetPendingMbn(args.mbnType, args.subId, args.slotId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pdcGetPendingMbn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pdcValidateMbn(self, seqid, iprot, oprot):
        args = pdcValidateMbn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pdcValidateMbn_result()
        try:
            result.success = self._handler.pdcValidateMbn(args.mbnType, args.mbnId, args.subId, args.remotePath)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pdcValidateMbn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pdcSelectMbn(self, seqid, iprot, oprot):
        args = pdcSelectMbn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pdcSelectMbn_result()
        try:
            result.success = self._handler.pdcSelectMbn(args.mbnType, args.mbnId, args.subId, args.slotId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pdcSelectMbn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pdcActivateMbn(self, seqid, iprot, oprot):
        args = pdcActivateMbn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pdcActivateMbn_result()
        try:
            result.success = self._handler.pdcActivateMbn(args.mbnType, args.subId, args.slotId, args.mode, args.timeout)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pdcActivateMbn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pdcDeactivateMbn(self, seqid, iprot, oprot):
        args = pdcDeactivateMbn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pdcDeactivateMbn_result()
        try:
            result.success = self._handler.pdcDeactivateMbn(args.mbnType, args.subId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pdcDeactivateMbn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pdcGetConfiguration(self, seqid, iprot, oprot):
        args = pdcGetConfiguration_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pdcGetConfiguration_result()
        try:
            result.success = self._handler.pdcGetConfiguration(args.slotId, args.feature)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pdcGetConfiguration", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pdcSetConfiguration(self, seqid, iprot, oprot):
        args = pdcSetConfiguration_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pdcSetConfiguration_result()
        try:
            result.success = self._handler.pdcSetConfiguration(args.slotId, args.feature, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pdcSetConfiguration", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_nvIsItemSupported(self, seqid, iprot, oprot):
        args = nvIsItemSupported_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = nvIsItemSupported_result()
        try:
            result.success = self._handler.nvIsItemSupported(args.nvItemNameOrId, args.subscriptionId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("nvIsItemSupported", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_nvReadItem(self, seqid, iprot, oprot):
        args = nvReadItem_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = nvReadItem_result()
        try:
            result.success = self._handler.nvReadItem(args.nvItemNameOrId, args.subscriptionId, args.index, args.returnConfig)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("nvReadItem", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_nvSetItem(self, seqid, iprot, oprot):
        args = nvSetItem_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = nvSetItem_result()
        try:
            result.success = self._handler.nvSetItem(args.nvItemNameOrId, args.valueList, args.subscriptionId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("nvSetItem", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_nvSetOtpItem(self, seqid, iprot, oprot):
        args = nvSetOtpItem_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = nvSetOtpItem_result()
        try:
            result.success = self._handler.nvSetOtpItem(args.nvItemNameOrId, args.valueList, args.subscriptionId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("nvSetOtpItem", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_nvGetAllItems(self, seqid, iprot, oprot):
        args = nvGetAllItems_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = nvGetAllItems_result()
        try:
            result.success = self._handler.nvGetAllItems()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("nvGetAllItems", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_nvGetItemDefinition(self, seqid, iprot, oprot):
        args = nvGetItemDefinition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = nvGetItemDefinition_result()
        try:
            result.success = self._handler.nvGetItemDefinition(args.nvItemNameOrId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("nvGetItemDefinition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_efsHasAlternateFileSystem(self, seqid, iprot, oprot):
        args = efsHasAlternateFileSystem_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = efsHasAlternateFileSystem_result()
        try:
            result.success = self._handler.efsHasAlternateFileSystem()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("efsHasAlternateFileSystem", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_efsCreateDirectory(self, seqid, iprot, oprot):
        args = efsCreateDirectory_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = efsCreateDirectory_result()
        try:
            result.success = self._handler.efsCreateDirectory(args.pathName, args.efsSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("efsCreateDirectory", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_efsRemoveDirectory(self, seqid, iprot, oprot):
        args = efsRemoveDirectory_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = efsRemoveDirectory_result()
        try:
            result.success = self._handler.efsRemoveDirectory(args.pathName, args.efsSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("efsRemoveDirectory", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_efsRemoveTree(self, seqid, iprot, oprot):
        args = efsRemoveTree_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = efsRemoveTree_result()
        try:
            result.success = self._handler.efsRemoveTree(args.pathName, args.efsSytem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("efsRemoveTree", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_efsGetDirectoryContents(self, seqid, iprot, oprot):
        args = efsGetDirectoryContents_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = efsGetDirectoryContents_result()
        try:
            result.success = self._handler.efsGetDirectoryContents(args.pathName, args.efsSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("efsGetDirectoryContents", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_efsPutFile(self, seqid, iprot, oprot):
        args = efsPutFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = efsPutFile_result()
        try:
            result.success = self._handler.efsPutFile(args.pathName, args.buffer, args.efsSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("efsPutFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_efsGetFile(self, seqid, iprot, oprot):
        args = efsGetFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = efsGetFile_result()
        try:
            result.success = self._handler.efsGetFile(args.pathName, args.efsSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("efsGetFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_efsDeleteFile(self, seqid, iprot, oprot):
        args = efsDeleteFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = efsDeleteFile_result()
        try:
            result.success = self._handler.efsDeleteFile(args.pathName, args.efsSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("efsDeleteFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_efsRename(self, seqid, iprot, oprot):
        args = efsRename_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = efsRename_result()
        try:
            result.success = self._handler.efsRename(args.existingName, args.newName, args.efsSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("efsRename", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_efsPathExists(self, seqid, iprot, oprot):
        args = efsPathExists_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = efsPathExists_result()
        try:
            result.success = self._handler.efsPathExists(args.pathName, args.efsSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("efsPathExists", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_efsIsDirectory(self, seqid, iprot, oprot):
        args = efsIsDirectory_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = efsIsDirectory_result()
        try:
            result.success = self._handler.efsIsDirectory(args.pathName, args.efsSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("efsIsDirectory", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_efsIsFile(self, seqid, iprot, oprot):
        args = efsIsFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = efsIsFile_result()
        try:
            result.success = self._handler.efsIsFile(args.pathName, args.efsSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("efsIsFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_efsGetFileSize(self, seqid, iprot, oprot):
        args = efsGetFileSize_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = efsGetFileSize_result()
        try:
            result.success = self._handler.efsGetFileSize(args.pathName, args.efsSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("efsGetFileSize", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_efsGetAvailableSpace(self, seqid, iprot, oprot):
        args = efsGetAvailableSpace_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = efsGetAvailableSpace_result()
        try:
            result.success = self._handler.efsGetAvailableSpace(args.efsSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("efsGetAvailableSpace", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_efsGetFileCheckSum(self, seqid, iprot, oprot):
        args = efsGetFileCheckSum_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = efsGetFileCheckSum_result()
        try:
            result.success = self._handler.efsGetFileCheckSum(args.pathName, args.efsSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("efsGetFileCheckSum", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_efsGetFileAttributes(self, seqid, iprot, oprot):
        args = efsGetFileAttributes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = efsGetFileAttributes_result()
        try:
            result.success = self._handler.efsGetFileAttributes(args.pathName, args.efsSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("efsGetFileAttributes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_efsIsReady(self, seqid, iprot, oprot):
        args = efsIsReady_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = efsIsReady_result()
        try:
            result.success = self._handler.efsIsReady()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("efsIsReady", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createGoldenCopy(self, seqid, iprot, oprot):
        args = createGoldenCopy_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createGoldenCopy_result()
        try:
            result.success = self._handler.createGoldenCopy(args.pathName, args.efsSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createGoldenCopy", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createGoldenCopyV2(self, seqid, iprot, oprot):
        args = createGoldenCopyV2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createGoldenCopyV2_result()
        try:
            result.success = self._handler.createGoldenCopyV2(args.createGoldenCopyV2Options, args.efsSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createGoldenCopyV2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createCefsCopy(self, seqid, iprot, oprot):
        args = createCefsCopy_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createCefsCopy_result()
        try:
            result.success = self._handler.createCefsCopy(args.cefsSavePath, args.efsSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createCefsCopy", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createFactoryEfsCopy(self, seqid, iprot, oprot):
        args = createFactoryEfsCopy_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createFactoryEfsCopy_result()
        try:
            result.success = self._handler.createFactoryEfsCopy(args.efsSystem, args.factoryEfsCopyOptions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createFactoryEfsCopy", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_requestPrl(self, seqid, iprot, oprot):
        args = requestPrl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = requestPrl_result()
        try:
            result.success = self._handler.requestPrl(args.subscriptionId, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("requestPrl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_backupPrl(self, seqid, iprot, oprot):
        args = backupPrl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = backupPrl_result()
        try:
            result.success = self._handler.backupPrl()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("backupPrl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_restorePrl(self, seqid, iprot, oprot):
        args = restorePrl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = restorePrl_result()
        try:
            result.success = self._handler.restorePrl(args.xqcnFileContents)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("restorePrl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sendPrl(self, seqid, iprot, oprot):
        args = sendPrl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sendPrl_result()
        try:
            result.success = self._handler.sendPrl(args.subscriptionId, args.index, args.prlFileContents)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sendPrl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forceEfsSync(self, seqid, iprot, oprot):
        args = forceEfsSync_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forceEfsSync_result()
        try:
            result.success = self._handler.forceEfsSync(args.pathName, args.efsSystem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forceEfsSync", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getEsn(self, seqid, iprot, oprot):
        args = getEsn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getEsn_result()
        try:
            result.success = self._handler.getEsn()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getEsn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setEsn(self, seqid, iprot, oprot):
        args = setEsn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setEsn_result()
        try:
            result.success = self._handler.setEsn(args.esn)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setEsn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getImei(self, seqid, iprot, oprot):
        args = getImei_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getImei_result()
        try:
            result.success = self._handler.getImei(args.subscriptionId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getImei", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setImei(self, seqid, iprot, oprot):
        args = setImei_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setImei_result()
        try:
            result.success = self._handler.setImei(args.imei, args.subscriptionId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setImei", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getMeid(self, seqid, iprot, oprot):
        args = getMeid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMeid_result()
        try:
            result.success = self._handler.getMeid(args.subscriptionId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getMeid", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setMeid(self, seqid, iprot, oprot):
        args = setMeid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setMeid_result()
        try:
            result.success = self._handler.setMeid(args.meid, args.subscriptionId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setMeid", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_checkSpc(self, seqid, iprot, oprot):
        args = checkSpc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = checkSpc_result()
        try:
            result.success = self._handler.checkSpc(args.spc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("checkSpc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_provisionSpc(self, seqid, iprot, oprot):
        args = provisionSpc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = provisionSpc_result()
        try:
            result.success = self._handler.provisionSpc(args.currentSpc, args.newSpc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("provisionSpc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_efsReadFromModemLog(self, seqid, iprot, oprot):
        args = efsReadFromModemLog_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = efsReadFromModemLog_result()
        try:
            result.success = self._handler.efsReadFromModemLog()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("efsReadFromModemLog", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_configureService(self, seqid, iprot, oprot):
        args = configureService_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = configureService_result()
        try:
            result.success = self._handler.configureService(args.deviceConfigOptions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("configureService", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class getLastError_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLastError_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLastError_args)
getLastError_args.thrift_spec = (
)


class getLastError_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Common.ttypes.ErrorType()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLastError_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLastError_result)
getLastError_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Common.ttypes.ErrorType, None], None, ),  # 0
)


class getDevice_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDevice_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDevice_args)
getDevice_args.thrift_spec = (
)


class getDevice_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDevice_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDevice_result)
getDevice_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class initializeService_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('initializeService_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(initializeService_args)
initializeService_args.thrift_spec = (
)


class initializeService_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('initializeService_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(initializeService_result)
initializeService_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class initializeServiceByProtocol_args(object):
    """
    Attributes:
     - diagProtocolHandle
     - qmiProtocolHandle

    """


    def __init__(self, diagProtocolHandle=None, qmiProtocolHandle=None,):
        self.diagProtocolHandle = diagProtocolHandle
        self.qmiProtocolHandle = qmiProtocolHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.diagProtocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.qmiProtocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('initializeServiceByProtocol_args')
        if self.diagProtocolHandle is not None:
            oprot.writeFieldBegin('diagProtocolHandle', TType.I64, 1)
            oprot.writeI64(self.diagProtocolHandle)
            oprot.writeFieldEnd()
        if self.qmiProtocolHandle is not None:
            oprot.writeFieldBegin('qmiProtocolHandle', TType.I64, 2)
            oprot.writeI64(self.qmiProtocolHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(initializeServiceByProtocol_args)
initializeServiceByProtocol_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'diagProtocolHandle', None, None, ),  # 1
    (2, TType.I64, 'qmiProtocolHandle', None, None, ),  # 2
)


class initializeServiceByProtocol_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('initializeServiceByProtocol_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(initializeServiceByProtocol_result)
initializeServiceByProtocol_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class initializeServiceWithOptions_args(object):
    """
    Attributes:
     - connectionOptions

    """


    def __init__(self, connectionOptions=None,):
        self.connectionOptions = connectionOptions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.connectionOptions = DeviceConfigConnectionOptions()
                    self.connectionOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('initializeServiceWithOptions_args')
        if self.connectionOptions is not None:
            oprot.writeFieldBegin('connectionOptions', TType.STRUCT, 1)
            self.connectionOptions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(initializeServiceWithOptions_args)
initializeServiceWithOptions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'connectionOptions', [DeviceConfigConnectionOptions, None], None, ),  # 1
)


class initializeServiceWithOptions_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('initializeServiceWithOptions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(initializeServiceWithOptions_result)
initializeServiceWithOptions_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class destroyService_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('destroyService_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(destroyService_args)
destroyService_args.thrift_spec = (
)


class destroyService_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('destroyService_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(destroyService_result)
destroyService_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class doXqcnOperation_args(object):
    """
    Attributes:
     - deviceConfigOptions

    """


    def __init__(self, deviceConfigOptions=None,):
        self.deviceConfigOptions = deviceConfigOptions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.deviceConfigOptions = DeviceConfigOptions()
                    self.deviceConfigOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('doXqcnOperation_args')
        if self.deviceConfigOptions is not None:
            oprot.writeFieldBegin('deviceConfigOptions', TType.STRUCT, 1)
            self.deviceConfigOptions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(doXqcnOperation_args)
doXqcnOperation_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'deviceConfigOptions', [DeviceConfigOptions, None], None, ),  # 1
)


class doXqcnOperation_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Common.ttypes.DeviceConfigResp()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('doXqcnOperation_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(doXqcnOperation_result)
doXqcnOperation_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Common.ttypes.DeviceConfigResp, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class backupToXqcn_args(object):
    """
    Attributes:
     - serviceProgrammingCode
     - resetUponCompletion
     - resetTimeout
     - filterFileContents

    """


    def __init__(self, serviceProgrammingCode=None, resetUponCompletion=None, resetTimeout=None, filterFileContents=None,):
        self.serviceProgrammingCode = serviceProgrammingCode
        self.resetUponCompletion = resetUponCompletion
        self.resetTimeout = resetTimeout
        self.filterFileContents = filterFileContents

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.serviceProgrammingCode = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.resetUponCompletion = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.resetTimeout = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.filterFileContents = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('backupToXqcn_args')
        if self.serviceProgrammingCode is not None:
            oprot.writeFieldBegin('serviceProgrammingCode', TType.STRING, 1)
            oprot.writeString(self.serviceProgrammingCode.encode('utf-8') if sys.version_info[0] == 2 else self.serviceProgrammingCode)
            oprot.writeFieldEnd()
        if self.resetUponCompletion is not None:
            oprot.writeFieldBegin('resetUponCompletion', TType.BOOL, 2)
            oprot.writeBool(self.resetUponCompletion)
            oprot.writeFieldEnd()
        if self.resetTimeout is not None:
            oprot.writeFieldBegin('resetTimeout', TType.I32, 3)
            oprot.writeI32(self.resetTimeout)
            oprot.writeFieldEnd()
        if self.filterFileContents is not None:
            oprot.writeFieldBegin('filterFileContents', TType.STRING, 4)
            oprot.writeString(self.filterFileContents.encode('utf-8') if sys.version_info[0] == 2 else self.filterFileContents)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(backupToXqcn_args)
backupToXqcn_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'serviceProgrammingCode', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'resetUponCompletion', None, None, ),  # 2
    (3, TType.I32, 'resetTimeout', None, None, ),  # 3
    (4, TType.STRING, 'filterFileContents', 'UTF8', None, ),  # 4
)


class backupToXqcn_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('backupToXqcn_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(backupToXqcn_result)
backupToXqcn_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class restoreFromXqcn_args(object):
    """
    Attributes:
     - xqcnFileContents
     - serviceProgrammingCode
     - allowEsnMismatch
     - resetUponCompletion
     - resetTimeout
     - filterFileContents

    """


    def __init__(self, xqcnFileContents=None, serviceProgrammingCode=None, allowEsnMismatch=None, resetUponCompletion=None, resetTimeout=None, filterFileContents=None,):
        self.xqcnFileContents = xqcnFileContents
        self.serviceProgrammingCode = serviceProgrammingCode
        self.allowEsnMismatch = allowEsnMismatch
        self.resetUponCompletion = resetUponCompletion
        self.resetTimeout = resetTimeout
        self.filterFileContents = filterFileContents

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.xqcnFileContents = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.serviceProgrammingCode = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.allowEsnMismatch = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.resetUponCompletion = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.resetTimeout = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.filterFileContents = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('restoreFromXqcn_args')
        if self.xqcnFileContents is not None:
            oprot.writeFieldBegin('xqcnFileContents', TType.STRING, 1)
            oprot.writeString(self.xqcnFileContents.encode('utf-8') if sys.version_info[0] == 2 else self.xqcnFileContents)
            oprot.writeFieldEnd()
        if self.serviceProgrammingCode is not None:
            oprot.writeFieldBegin('serviceProgrammingCode', TType.STRING, 2)
            oprot.writeString(self.serviceProgrammingCode.encode('utf-8') if sys.version_info[0] == 2 else self.serviceProgrammingCode)
            oprot.writeFieldEnd()
        if self.allowEsnMismatch is not None:
            oprot.writeFieldBegin('allowEsnMismatch', TType.BOOL, 3)
            oprot.writeBool(self.allowEsnMismatch)
            oprot.writeFieldEnd()
        if self.resetUponCompletion is not None:
            oprot.writeFieldBegin('resetUponCompletion', TType.BOOL, 4)
            oprot.writeBool(self.resetUponCompletion)
            oprot.writeFieldEnd()
        if self.resetTimeout is not None:
            oprot.writeFieldBegin('resetTimeout', TType.I32, 5)
            oprot.writeI32(self.resetTimeout)
            oprot.writeFieldEnd()
        if self.filterFileContents is not None:
            oprot.writeFieldBegin('filterFileContents', TType.STRING, 6)
            oprot.writeString(self.filterFileContents.encode('utf-8') if sys.version_info[0] == 2 else self.filterFileContents)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(restoreFromXqcn_args)
restoreFromXqcn_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'xqcnFileContents', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'serviceProgrammingCode', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'allowEsnMismatch', None, None, ),  # 3
    (4, TType.BOOL, 'resetUponCompletion', None, None, ),  # 4
    (5, TType.I32, 'resetTimeout', None, None, ),  # 5
    (6, TType.STRING, 'filterFileContents', 'UTF8', None, ),  # 6
)


class restoreFromXqcn_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('restoreFromXqcn_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(restoreFromXqcn_result)
restoreFromXqcn_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class pdcGetMbnMaxStorage_args(object):
    """
    Attributes:
     - mbnType

    """


    def __init__(self, mbnType=None,):
        self.mbnType = mbnType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.mbnType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcGetMbnMaxStorage_args')
        if self.mbnType is not None:
            oprot.writeFieldBegin('mbnType', TType.I32, 1)
            oprot.writeI32(self.mbnType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcGetMbnMaxStorage_args)
pdcGetMbnMaxStorage_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'mbnType', None, None, ),  # 1
)


class pdcGetMbnMaxStorage_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcGetMbnMaxStorage_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcGetMbnMaxStorage_result)
pdcGetMbnMaxStorage_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class pdcGetMbnStorageUsage_args(object):
    """
    Attributes:
     - mbnType

    """


    def __init__(self, mbnType=None,):
        self.mbnType = mbnType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.mbnType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcGetMbnStorageUsage_args')
        if self.mbnType is not None:
            oprot.writeFieldBegin('mbnType', TType.I32, 1)
            oprot.writeI32(self.mbnType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcGetMbnStorageUsage_args)
pdcGetMbnStorageUsage_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'mbnType', None, None, ),  # 1
)


class pdcGetMbnStorageUsage_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcGetMbnStorageUsage_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcGetMbnStorageUsage_result)
pdcGetMbnStorageUsage_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class pdcGetMbnCount_args(object):
    """
    Attributes:
     - mbnType

    """


    def __init__(self, mbnType=None,):
        self.mbnType = mbnType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.mbnType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcGetMbnCount_args')
        if self.mbnType is not None:
            oprot.writeFieldBegin('mbnType', TType.I32, 1)
            oprot.writeI32(self.mbnType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcGetMbnCount_args)
pdcGetMbnCount_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'mbnType', None, None, ),  # 1
)


class pdcGetMbnCount_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcGetMbnCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcGetMbnCount_result)
pdcGetMbnCount_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class pdcGetMbnList_args(object):
    """
    Attributes:
     - mbnType

    """


    def __init__(self, mbnType=None,):
        self.mbnType = mbnType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.mbnType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcGetMbnList_args')
        if self.mbnType is not None:
            oprot.writeFieldBegin('mbnType', TType.I32, 1)
            oprot.writeI32(self.mbnType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcGetMbnList_args)
pdcGetMbnList_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'mbnType', None, None, ),  # 1
)


class pdcGetMbnList_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = PdcMbnInfo()
                        _elem12.read(iprot)
                        self.success.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcGetMbnList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter13 in self.success:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcGetMbnList_result)
pdcGetMbnList_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [PdcMbnInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class pdcGetDefaultMbnInfo_args(object):
    """
    Attributes:
     - mbnType

    """


    def __init__(self, mbnType=None,):
        self.mbnType = mbnType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.mbnType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcGetDefaultMbnInfo_args')
        if self.mbnType is not None:
            oprot.writeFieldBegin('mbnType', TType.I32, 1)
            oprot.writeI32(self.mbnType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcGetDefaultMbnInfo_args)
pdcGetDefaultMbnInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'mbnType', None, None, ),  # 1
)


class pdcGetDefaultMbnInfo_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PdcMbnInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcGetDefaultMbnInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcGetDefaultMbnInfo_result)
pdcGetDefaultMbnInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [PdcMbnInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class pdcGetMbnId_args(object):
    """
    Attributes:
     - mbnContent

    """


    def __init__(self, mbnContent=None,):
        self.mbnContent = mbnContent

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.mbnContent = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcGetMbnId_args')
        if self.mbnContent is not None:
            oprot.writeFieldBegin('mbnContent', TType.STRING, 1)
            oprot.writeBinary(self.mbnContent)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcGetMbnId_args)
pdcGetMbnId_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'mbnContent', 'BINARY', None, ),  # 1
)


class pdcGetMbnId_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcGetMbnId_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcGetMbnId_result)
pdcGetMbnId_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class pdcWriteMbn_args(object):
    """
    Attributes:
     - mbnType
     - mbnContent

    """


    def __init__(self, mbnType=None, mbnContent=None,):
        self.mbnType = mbnType
        self.mbnContent = mbnContent

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.mbnType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mbnContent = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcWriteMbn_args')
        if self.mbnType is not None:
            oprot.writeFieldBegin('mbnType', TType.I32, 1)
            oprot.writeI32(self.mbnType)
            oprot.writeFieldEnd()
        if self.mbnContent is not None:
            oprot.writeFieldBegin('mbnContent', TType.STRING, 2)
            oprot.writeBinary(self.mbnContent)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcWriteMbn_args)
pdcWriteMbn_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'mbnType', None, None, ),  # 1
    (2, TType.STRING, 'mbnContent', 'BINARY', None, ),  # 2
)


class pdcWriteMbn_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcWriteMbn_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcWriteMbn_result)
pdcWriteMbn_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class pdcReadMbn_args(object):
    """
    Attributes:
     - mbnType
     - mbnId
     - subId

    """


    def __init__(self, mbnType=None, mbnId=None, subId=None,):
        self.mbnType = mbnType
        self.mbnId = mbnId
        self.subId = subId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.mbnType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mbnId = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.subId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcReadMbn_args')
        if self.mbnType is not None:
            oprot.writeFieldBegin('mbnType', TType.I32, 1)
            oprot.writeI32(self.mbnType)
            oprot.writeFieldEnd()
        if self.mbnId is not None:
            oprot.writeFieldBegin('mbnId', TType.STRING, 2)
            oprot.writeBinary(self.mbnId)
            oprot.writeFieldEnd()
        if self.subId is not None:
            oprot.writeFieldBegin('subId', TType.I32, 3)
            oprot.writeI32(self.subId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcReadMbn_args)
pdcReadMbn_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'mbnType', None, None, ),  # 1
    (2, TType.STRING, 'mbnId', 'BINARY', None, ),  # 2
    (3, TType.I32, 'subId', None, None, ),  # 3
)


class pdcReadMbn_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcReadMbn_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcReadMbn_result)
pdcReadMbn_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class pdcRemoveMbn_args(object):
    """
    Attributes:
     - mbnType
     - mbnId

    """


    def __init__(self, mbnType=None, mbnId=None,):
        self.mbnType = mbnType
        self.mbnId = mbnId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.mbnType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mbnId = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcRemoveMbn_args')
        if self.mbnType is not None:
            oprot.writeFieldBegin('mbnType', TType.I32, 1)
            oprot.writeI32(self.mbnType)
            oprot.writeFieldEnd()
        if self.mbnId is not None:
            oprot.writeFieldBegin('mbnId', TType.STRING, 2)
            oprot.writeBinary(self.mbnId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcRemoveMbn_args)
pdcRemoveMbn_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'mbnType', None, None, ),  # 1
    (2, TType.STRING, 'mbnId', 'BINARY', None, ),  # 2
)


class pdcRemoveMbn_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcRemoveMbn_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcRemoveMbn_result)
pdcRemoveMbn_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class pdcGetActiveMbn_args(object):
    """
    Attributes:
     - mbnType
     - subId
     - slotId

    """


    def __init__(self, mbnType=None, subId=None, slotId=None,):
        self.mbnType = mbnType
        self.subId = subId
        self.slotId = slotId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.mbnType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.subId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.slotId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcGetActiveMbn_args')
        if self.mbnType is not None:
            oprot.writeFieldBegin('mbnType', TType.I32, 1)
            oprot.writeI32(self.mbnType)
            oprot.writeFieldEnd()
        if self.subId is not None:
            oprot.writeFieldBegin('subId', TType.I32, 2)
            oprot.writeI32(self.subId)
            oprot.writeFieldEnd()
        if self.slotId is not None:
            oprot.writeFieldBegin('slotId', TType.I32, 3)
            oprot.writeI32(self.slotId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcGetActiveMbn_args)
pdcGetActiveMbn_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'mbnType', None, None, ),  # 1
    (2, TType.I32, 'subId', None, None, ),  # 2
    (3, TType.I32, 'slotId', None, None, ),  # 3
)


class pdcGetActiveMbn_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcGetActiveMbn_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcGetActiveMbn_result)
pdcGetActiveMbn_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class pdcGetPendingMbn_args(object):
    """
    Attributes:
     - mbnType
     - subId
     - slotId

    """


    def __init__(self, mbnType=None, subId=None, slotId=None,):
        self.mbnType = mbnType
        self.subId = subId
        self.slotId = slotId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.mbnType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.subId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.slotId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcGetPendingMbn_args')
        if self.mbnType is not None:
            oprot.writeFieldBegin('mbnType', TType.I32, 1)
            oprot.writeI32(self.mbnType)
            oprot.writeFieldEnd()
        if self.subId is not None:
            oprot.writeFieldBegin('subId', TType.I32, 2)
            oprot.writeI32(self.subId)
            oprot.writeFieldEnd()
        if self.slotId is not None:
            oprot.writeFieldBegin('slotId', TType.I32, 3)
            oprot.writeI32(self.slotId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcGetPendingMbn_args)
pdcGetPendingMbn_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'mbnType', None, None, ),  # 1
    (2, TType.I32, 'subId', None, None, ),  # 2
    (3, TType.I32, 'slotId', None, None, ),  # 3
)


class pdcGetPendingMbn_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcGetPendingMbn_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcGetPendingMbn_result)
pdcGetPendingMbn_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class pdcValidateMbn_args(object):
    """
    Attributes:
     - mbnType
     - mbnId
     - subId
     - remotePath

    """


    def __init__(self, mbnType=None, mbnId=None, subId=None, remotePath=None,):
        self.mbnType = mbnType
        self.mbnId = mbnId
        self.subId = subId
        self.remotePath = remotePath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.mbnType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mbnId = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.subId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.remotePath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcValidateMbn_args')
        if self.mbnType is not None:
            oprot.writeFieldBegin('mbnType', TType.I32, 1)
            oprot.writeI32(self.mbnType)
            oprot.writeFieldEnd()
        if self.mbnId is not None:
            oprot.writeFieldBegin('mbnId', TType.STRING, 2)
            oprot.writeBinary(self.mbnId)
            oprot.writeFieldEnd()
        if self.subId is not None:
            oprot.writeFieldBegin('subId', TType.I32, 3)
            oprot.writeI32(self.subId)
            oprot.writeFieldEnd()
        if self.remotePath is not None:
            oprot.writeFieldBegin('remotePath', TType.STRING, 4)
            oprot.writeString(self.remotePath.encode('utf-8') if sys.version_info[0] == 2 else self.remotePath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcValidateMbn_args)
pdcValidateMbn_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'mbnType', None, None, ),  # 1
    (2, TType.STRING, 'mbnId', 'BINARY', None, ),  # 2
    (3, TType.I32, 'subId', None, None, ),  # 3
    (4, TType.STRING, 'remotePath', 'UTF8', None, ),  # 4
)


class pdcValidateMbn_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PdcMbnResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcValidateMbn_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcValidateMbn_result)
pdcValidateMbn_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [PdcMbnResult, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class pdcSelectMbn_args(object):
    """
    Attributes:
     - mbnType
     - mbnId
     - subId
     - slotId

    """


    def __init__(self, mbnType=None, mbnId=None, subId=None, slotId=None,):
        self.mbnType = mbnType
        self.mbnId = mbnId
        self.subId = subId
        self.slotId = slotId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.mbnType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mbnId = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.subId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.slotId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcSelectMbn_args')
        if self.mbnType is not None:
            oprot.writeFieldBegin('mbnType', TType.I32, 1)
            oprot.writeI32(self.mbnType)
            oprot.writeFieldEnd()
        if self.mbnId is not None:
            oprot.writeFieldBegin('mbnId', TType.STRING, 2)
            oprot.writeBinary(self.mbnId)
            oprot.writeFieldEnd()
        if self.subId is not None:
            oprot.writeFieldBegin('subId', TType.I32, 3)
            oprot.writeI32(self.subId)
            oprot.writeFieldEnd()
        if self.slotId is not None:
            oprot.writeFieldBegin('slotId', TType.I32, 4)
            oprot.writeI32(self.slotId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcSelectMbn_args)
pdcSelectMbn_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'mbnType', None, None, ),  # 1
    (2, TType.STRING, 'mbnId', 'BINARY', None, ),  # 2
    (3, TType.I32, 'subId', None, None, ),  # 3
    (4, TType.I32, 'slotId', None, None, ),  # 4
)


class pdcSelectMbn_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcSelectMbn_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcSelectMbn_result)
pdcSelectMbn_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class pdcActivateMbn_args(object):
    """
    Attributes:
     - mbnType
     - subId
     - slotId
     - mode
     - timeout

    """


    def __init__(self, mbnType=None, subId=None, slotId=None, mode=None, timeout=None,):
        self.mbnType = mbnType
        self.subId = subId
        self.slotId = slotId
        self.mode = mode
        self.timeout = timeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.mbnType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.subId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.slotId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.timeout = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcActivateMbn_args')
        if self.mbnType is not None:
            oprot.writeFieldBegin('mbnType', TType.I32, 1)
            oprot.writeI32(self.mbnType)
            oprot.writeFieldEnd()
        if self.subId is not None:
            oprot.writeFieldBegin('subId', TType.I32, 2)
            oprot.writeI32(self.subId)
            oprot.writeFieldEnd()
        if self.slotId is not None:
            oprot.writeFieldBegin('slotId', TType.I32, 3)
            oprot.writeI32(self.slotId)
            oprot.writeFieldEnd()
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 4)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I32, 5)
            oprot.writeI32(self.timeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcActivateMbn_args)
pdcActivateMbn_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'mbnType', None, None, ),  # 1
    (2, TType.I32, 'subId', None, None, ),  # 2
    (3, TType.I32, 'slotId', None, None, ),  # 3
    (4, TType.I32, 'mode', None, None, ),  # 4
    (5, TType.I32, 'timeout', None, None, ),  # 5
)


class pdcActivateMbn_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcActivateMbn_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcActivateMbn_result)
pdcActivateMbn_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class pdcDeactivateMbn_args(object):
    """
    Attributes:
     - mbnType
     - subId

    """


    def __init__(self, mbnType=None, subId=None,):
        self.mbnType = mbnType
        self.subId = subId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.mbnType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.subId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcDeactivateMbn_args')
        if self.mbnType is not None:
            oprot.writeFieldBegin('mbnType', TType.I32, 1)
            oprot.writeI32(self.mbnType)
            oprot.writeFieldEnd()
        if self.subId is not None:
            oprot.writeFieldBegin('subId', TType.I32, 2)
            oprot.writeI32(self.subId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcDeactivateMbn_args)
pdcDeactivateMbn_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'mbnType', None, None, ),  # 1
    (2, TType.I32, 'subId', None, None, ),  # 2
)


class pdcDeactivateMbn_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcDeactivateMbn_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcDeactivateMbn_result)
pdcDeactivateMbn_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class pdcGetConfiguration_args(object):
    """
    Attributes:
     - slotId
     - feature

    """


    def __init__(self, slotId=None, feature=None,):
        self.slotId = slotId
        self.feature = feature

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.slotId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.feature = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcGetConfiguration_args')
        if self.slotId is not None:
            oprot.writeFieldBegin('slotId', TType.I32, 1)
            oprot.writeI32(self.slotId)
            oprot.writeFieldEnd()
        if self.feature is not None:
            oprot.writeFieldBegin('feature', TType.I32, 2)
            oprot.writeI32(self.feature)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcGetConfiguration_args)
pdcGetConfiguration_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'slotId', None, None, ),  # 1
    (2, TType.I32, 'feature', None, None, ),  # 2
)


class pdcGetConfiguration_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcGetConfiguration_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcGetConfiguration_result)
pdcGetConfiguration_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class pdcSetConfiguration_args(object):
    """
    Attributes:
     - slotId
     - feature
     - value

    """


    def __init__(self, slotId=None, feature=None, value=None,):
        self.slotId = slotId
        self.feature = feature
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.slotId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.feature = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcSetConfiguration_args')
        if self.slotId is not None:
            oprot.writeFieldBegin('slotId', TType.I32, 1)
            oprot.writeI32(self.slotId)
            oprot.writeFieldEnd()
        if self.feature is not None:
            oprot.writeFieldBegin('feature', TType.I32, 2)
            oprot.writeI32(self.feature)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 3)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcSetConfiguration_args)
pdcSetConfiguration_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'slotId', None, None, ),  # 1
    (2, TType.I32, 'feature', None, None, ),  # 2
    (3, TType.I32, 'value', None, None, ),  # 3
)


class pdcSetConfiguration_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pdcSetConfiguration_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pdcSetConfiguration_result)
pdcSetConfiguration_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class nvIsItemSupported_args(object):
    """
    Attributes:
     - nvItemNameOrId
     - subscriptionId

    """


    def __init__(self, nvItemNameOrId=None, subscriptionId=None,):
        self.nvItemNameOrId = nvItemNameOrId
        self.subscriptionId = subscriptionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.nvItemNameOrId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.subscriptionId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('nvIsItemSupported_args')
        if self.nvItemNameOrId is not None:
            oprot.writeFieldBegin('nvItemNameOrId', TType.STRING, 1)
            oprot.writeString(self.nvItemNameOrId.encode('utf-8') if sys.version_info[0] == 2 else self.nvItemNameOrId)
            oprot.writeFieldEnd()
        if self.subscriptionId is not None:
            oprot.writeFieldBegin('subscriptionId', TType.I32, 2)
            oprot.writeI32(self.subscriptionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(nvIsItemSupported_args)
nvIsItemSupported_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'nvItemNameOrId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'subscriptionId', None, None, ),  # 2
)


class nvIsItemSupported_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('nvIsItemSupported_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(nvIsItemSupported_result)
nvIsItemSupported_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class nvReadItem_args(object):
    """
    Attributes:
     - nvItemNameOrId
     - subscriptionId
     - index
     - returnConfig

    """


    def __init__(self, nvItemNameOrId=None, subscriptionId=None, index=None, returnConfig=None,):
        self.nvItemNameOrId = nvItemNameOrId
        self.subscriptionId = subscriptionId
        self.index = index
        self.returnConfig = returnConfig

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.nvItemNameOrId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.subscriptionId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BYTE:
                    self.index = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.returnConfig = NvReturns()
                    self.returnConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('nvReadItem_args')
        if self.nvItemNameOrId is not None:
            oprot.writeFieldBegin('nvItemNameOrId', TType.STRING, 1)
            oprot.writeString(self.nvItemNameOrId.encode('utf-8') if sys.version_info[0] == 2 else self.nvItemNameOrId)
            oprot.writeFieldEnd()
        if self.subscriptionId is not None:
            oprot.writeFieldBegin('subscriptionId', TType.I32, 2)
            oprot.writeI32(self.subscriptionId)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.BYTE, 3)
            oprot.writeByte(self.index)
            oprot.writeFieldEnd()
        if self.returnConfig is not None:
            oprot.writeFieldBegin('returnConfig', TType.STRUCT, 4)
            self.returnConfig.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(nvReadItem_args)
nvReadItem_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'nvItemNameOrId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'subscriptionId', None, None, ),  # 2
    (3, TType.BYTE, 'index', None, None, ),  # 3
    (4, TType.STRUCT, 'returnConfig', [NvReturns, None], None, ),  # 4
)


class nvReadItem_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NvData()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('nvReadItem_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(nvReadItem_result)
nvReadItem_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [NvData, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class nvSetItem_args(object):
    """
    Attributes:
     - nvItemNameOrId
     - valueList
     - subscriptionId

    """


    def __init__(self, nvItemNameOrId=None, valueList=None, subscriptionId=None,):
        self.nvItemNameOrId = nvItemNameOrId
        self.valueList = valueList
        self.subscriptionId = subscriptionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.nvItemNameOrId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.valueList = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.subscriptionId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('nvSetItem_args')
        if self.nvItemNameOrId is not None:
            oprot.writeFieldBegin('nvItemNameOrId', TType.STRING, 1)
            oprot.writeString(self.nvItemNameOrId.encode('utf-8') if sys.version_info[0] == 2 else self.nvItemNameOrId)
            oprot.writeFieldEnd()
        if self.valueList is not None:
            oprot.writeFieldBegin('valueList', TType.STRING, 2)
            oprot.writeString(self.valueList.encode('utf-8') if sys.version_info[0] == 2 else self.valueList)
            oprot.writeFieldEnd()
        if self.subscriptionId is not None:
            oprot.writeFieldBegin('subscriptionId', TType.I32, 3)
            oprot.writeI32(self.subscriptionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(nvSetItem_args)
nvSetItem_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'nvItemNameOrId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'valueList', 'UTF8', None, ),  # 2
    (3, TType.I32, 'subscriptionId', None, None, ),  # 3
)


class nvSetItem_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('nvSetItem_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(nvSetItem_result)
nvSetItem_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class nvSetOtpItem_args(object):
    """
    Attributes:
     - nvItemNameOrId
     - valueList
     - subscriptionId

    """


    def __init__(self, nvItemNameOrId=None, valueList=None, subscriptionId=None,):
        self.nvItemNameOrId = nvItemNameOrId
        self.valueList = valueList
        self.subscriptionId = subscriptionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.nvItemNameOrId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.valueList = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.subscriptionId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('nvSetOtpItem_args')
        if self.nvItemNameOrId is not None:
            oprot.writeFieldBegin('nvItemNameOrId', TType.STRING, 1)
            oprot.writeString(self.nvItemNameOrId.encode('utf-8') if sys.version_info[0] == 2 else self.nvItemNameOrId)
            oprot.writeFieldEnd()
        if self.valueList is not None:
            oprot.writeFieldBegin('valueList', TType.STRING, 2)
            oprot.writeString(self.valueList.encode('utf-8') if sys.version_info[0] == 2 else self.valueList)
            oprot.writeFieldEnd()
        if self.subscriptionId is not None:
            oprot.writeFieldBegin('subscriptionId', TType.I32, 3)
            oprot.writeI32(self.subscriptionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(nvSetOtpItem_args)
nvSetOtpItem_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'nvItemNameOrId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'valueList', 'UTF8', None, ),  # 2
    (3, TType.I32, 'subscriptionId', None, None, ),  # 3
)


class nvSetOtpItem_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('nvSetOtpItem_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(nvSetOtpItem_result)
nvSetOtpItem_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class nvGetAllItems_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('nvGetAllItems_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(nvGetAllItems_args)
nvGetAllItems_args.thrift_spec = (
)


class nvGetAllItems_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = Common.ttypes.NvItem()
                        _elem19.read(iprot)
                        self.success.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('nvGetAllItems_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter20 in self.success:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(nvGetAllItems_result)
nvGetAllItems_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Common.ttypes.NvItem, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class nvGetItemDefinition_args(object):
    """
    Attributes:
     - nvItemNameOrId

    """


    def __init__(self, nvItemNameOrId=None,):
        self.nvItemNameOrId = nvItemNameOrId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.nvItemNameOrId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('nvGetItemDefinition_args')
        if self.nvItemNameOrId is not None:
            oprot.writeFieldBegin('nvItemNameOrId', TType.STRING, 1)
            oprot.writeString(self.nvItemNameOrId.encode('utf-8') if sys.version_info[0] == 2 else self.nvItemNameOrId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(nvGetItemDefinition_args)
nvGetItemDefinition_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'nvItemNameOrId', 'UTF8', None, ),  # 1
)


class nvGetItemDefinition_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('nvGetItemDefinition_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(nvGetItemDefinition_result)
nvGetItemDefinition_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class efsHasAlternateFileSystem_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsHasAlternateFileSystem_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsHasAlternateFileSystem_args)
efsHasAlternateFileSystem_args.thrift_spec = (
)


class efsHasAlternateFileSystem_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsHasAlternateFileSystem_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsHasAlternateFileSystem_result)
efsHasAlternateFileSystem_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class efsCreateDirectory_args(object):
    """
    Attributes:
     - pathName
     - efsSystem

    """


    def __init__(self, pathName=None, efsSystem=None,):
        self.pathName = pathName
        self.efsSystem = efsSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.efsSystem = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsCreateDirectory_args')
        if self.pathName is not None:
            oprot.writeFieldBegin('pathName', TType.STRING, 1)
            oprot.writeString(self.pathName.encode('utf-8') if sys.version_info[0] == 2 else self.pathName)
            oprot.writeFieldEnd()
        if self.efsSystem is not None:
            oprot.writeFieldBegin('efsSystem', TType.I32, 2)
            oprot.writeI32(self.efsSystem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsCreateDirectory_args)
efsCreateDirectory_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'efsSystem', None, None, ),  # 2
)


class efsCreateDirectory_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsCreateDirectory_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsCreateDirectory_result)
efsCreateDirectory_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class efsRemoveDirectory_args(object):
    """
    Attributes:
     - pathName
     - efsSystem

    """


    def __init__(self, pathName=None, efsSystem=None,):
        self.pathName = pathName
        self.efsSystem = efsSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.efsSystem = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsRemoveDirectory_args')
        if self.pathName is not None:
            oprot.writeFieldBegin('pathName', TType.STRING, 1)
            oprot.writeString(self.pathName.encode('utf-8') if sys.version_info[0] == 2 else self.pathName)
            oprot.writeFieldEnd()
        if self.efsSystem is not None:
            oprot.writeFieldBegin('efsSystem', TType.I32, 2)
            oprot.writeI32(self.efsSystem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsRemoveDirectory_args)
efsRemoveDirectory_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'efsSystem', None, None, ),  # 2
)


class efsRemoveDirectory_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsRemoveDirectory_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsRemoveDirectory_result)
efsRemoveDirectory_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class efsRemoveTree_args(object):
    """
    Attributes:
     - pathName
     - efsSytem

    """


    def __init__(self, pathName=None, efsSytem=None,):
        self.pathName = pathName
        self.efsSytem = efsSytem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.efsSytem = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsRemoveTree_args')
        if self.pathName is not None:
            oprot.writeFieldBegin('pathName', TType.STRING, 1)
            oprot.writeString(self.pathName.encode('utf-8') if sys.version_info[0] == 2 else self.pathName)
            oprot.writeFieldEnd()
        if self.efsSytem is not None:
            oprot.writeFieldBegin('efsSytem', TType.I32, 2)
            oprot.writeI32(self.efsSytem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsRemoveTree_args)
efsRemoveTree_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'efsSytem', None, None, ),  # 2
)


class efsRemoveTree_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsRemoveTree_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsRemoveTree_result)
efsRemoveTree_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class efsGetDirectoryContents_args(object):
    """
    Attributes:
     - pathName
     - efsSystem

    """


    def __init__(self, pathName=None, efsSystem=None,):
        self.pathName = pathName
        self.efsSystem = efsSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.efsSystem = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsGetDirectoryContents_args')
        if self.pathName is not None:
            oprot.writeFieldBegin('pathName', TType.STRING, 1)
            oprot.writeString(self.pathName.encode('utf-8') if sys.version_info[0] == 2 else self.pathName)
            oprot.writeFieldEnd()
        if self.efsSystem is not None:
            oprot.writeFieldBegin('efsSystem', TType.I32, 2)
            oprot.writeI32(self.efsSystem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsGetDirectoryContents_args)
efsGetDirectoryContents_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'efsSystem', None, None, ),  # 2
)


class efsGetDirectoryContents_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = EfsItem()
                        _elem26.read(iprot)
                        self.success.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsGetDirectoryContents_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter27 in self.success:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsGetDirectoryContents_result)
efsGetDirectoryContents_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [EfsItem, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class efsPutFile_args(object):
    """
    Attributes:
     - pathName
     - buffer
     - efsSystem

    """


    def __init__(self, pathName=None, buffer=None, efsSystem=None,):
        self.pathName = pathName
        self.buffer = buffer
        self.efsSystem = efsSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.buffer = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.efsSystem = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsPutFile_args')
        if self.pathName is not None:
            oprot.writeFieldBegin('pathName', TType.STRING, 1)
            oprot.writeString(self.pathName.encode('utf-8') if sys.version_info[0] == 2 else self.pathName)
            oprot.writeFieldEnd()
        if self.buffer is not None:
            oprot.writeFieldBegin('buffer', TType.STRING, 2)
            oprot.writeBinary(self.buffer)
            oprot.writeFieldEnd()
        if self.efsSystem is not None:
            oprot.writeFieldBegin('efsSystem', TType.I32, 3)
            oprot.writeI32(self.efsSystem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsPutFile_args)
efsPutFile_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'buffer', 'BINARY', None, ),  # 2
    (3, TType.I32, 'efsSystem', None, None, ),  # 3
)


class efsPutFile_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsPutFile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsPutFile_result)
efsPutFile_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class efsGetFile_args(object):
    """
    Attributes:
     - pathName
     - efsSystem

    """


    def __init__(self, pathName=None, efsSystem=None,):
        self.pathName = pathName
        self.efsSystem = efsSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.efsSystem = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsGetFile_args')
        if self.pathName is not None:
            oprot.writeFieldBegin('pathName', TType.STRING, 1)
            oprot.writeString(self.pathName.encode('utf-8') if sys.version_info[0] == 2 else self.pathName)
            oprot.writeFieldEnd()
        if self.efsSystem is not None:
            oprot.writeFieldBegin('efsSystem', TType.I32, 2)
            oprot.writeI32(self.efsSystem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsGetFile_args)
efsGetFile_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'efsSystem', None, None, ),  # 2
)


class efsGetFile_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsGetFile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsGetFile_result)
efsGetFile_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class efsDeleteFile_args(object):
    """
    Attributes:
     - pathName
     - efsSystem

    """


    def __init__(self, pathName=None, efsSystem=None,):
        self.pathName = pathName
        self.efsSystem = efsSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.efsSystem = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsDeleteFile_args')
        if self.pathName is not None:
            oprot.writeFieldBegin('pathName', TType.STRING, 1)
            oprot.writeString(self.pathName.encode('utf-8') if sys.version_info[0] == 2 else self.pathName)
            oprot.writeFieldEnd()
        if self.efsSystem is not None:
            oprot.writeFieldBegin('efsSystem', TType.I32, 2)
            oprot.writeI32(self.efsSystem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsDeleteFile_args)
efsDeleteFile_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'efsSystem', None, None, ),  # 2
)


class efsDeleteFile_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsDeleteFile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsDeleteFile_result)
efsDeleteFile_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class efsRename_args(object):
    """
    Attributes:
     - existingName
     - newName
     - efsSystem

    """


    def __init__(self, existingName=None, newName=None, efsSystem=None,):
        self.existingName = existingName
        self.newName = newName
        self.efsSystem = efsSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.existingName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.newName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.efsSystem = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsRename_args')
        if self.existingName is not None:
            oprot.writeFieldBegin('existingName', TType.STRING, 1)
            oprot.writeString(self.existingName.encode('utf-8') if sys.version_info[0] == 2 else self.existingName)
            oprot.writeFieldEnd()
        if self.newName is not None:
            oprot.writeFieldBegin('newName', TType.STRING, 2)
            oprot.writeString(self.newName.encode('utf-8') if sys.version_info[0] == 2 else self.newName)
            oprot.writeFieldEnd()
        if self.efsSystem is not None:
            oprot.writeFieldBegin('efsSystem', TType.I32, 3)
            oprot.writeI32(self.efsSystem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsRename_args)
efsRename_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'existingName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'newName', 'UTF8', None, ),  # 2
    (3, TType.I32, 'efsSystem', None, None, ),  # 3
)


class efsRename_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsRename_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsRename_result)
efsRename_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class efsPathExists_args(object):
    """
    Attributes:
     - pathName
     - efsSystem

    """


    def __init__(self, pathName=None, efsSystem=None,):
        self.pathName = pathName
        self.efsSystem = efsSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.efsSystem = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsPathExists_args')
        if self.pathName is not None:
            oprot.writeFieldBegin('pathName', TType.STRING, 1)
            oprot.writeString(self.pathName.encode('utf-8') if sys.version_info[0] == 2 else self.pathName)
            oprot.writeFieldEnd()
        if self.efsSystem is not None:
            oprot.writeFieldBegin('efsSystem', TType.I32, 2)
            oprot.writeI32(self.efsSystem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsPathExists_args)
efsPathExists_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'efsSystem', None, None, ),  # 2
)


class efsPathExists_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsPathExists_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsPathExists_result)
efsPathExists_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class efsIsDirectory_args(object):
    """
    Attributes:
     - pathName
     - efsSystem

    """


    def __init__(self, pathName=None, efsSystem=None,):
        self.pathName = pathName
        self.efsSystem = efsSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.efsSystem = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsIsDirectory_args')
        if self.pathName is not None:
            oprot.writeFieldBegin('pathName', TType.STRING, 1)
            oprot.writeString(self.pathName.encode('utf-8') if sys.version_info[0] == 2 else self.pathName)
            oprot.writeFieldEnd()
        if self.efsSystem is not None:
            oprot.writeFieldBegin('efsSystem', TType.I32, 2)
            oprot.writeI32(self.efsSystem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsIsDirectory_args)
efsIsDirectory_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'efsSystem', None, None, ),  # 2
)


class efsIsDirectory_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsIsDirectory_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsIsDirectory_result)
efsIsDirectory_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class efsIsFile_args(object):
    """
    Attributes:
     - pathName
     - efsSystem

    """


    def __init__(self, pathName=None, efsSystem=None,):
        self.pathName = pathName
        self.efsSystem = efsSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.efsSystem = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsIsFile_args')
        if self.pathName is not None:
            oprot.writeFieldBegin('pathName', TType.STRING, 1)
            oprot.writeString(self.pathName.encode('utf-8') if sys.version_info[0] == 2 else self.pathName)
            oprot.writeFieldEnd()
        if self.efsSystem is not None:
            oprot.writeFieldBegin('efsSystem', TType.I32, 2)
            oprot.writeI32(self.efsSystem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsIsFile_args)
efsIsFile_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'efsSystem', None, None, ),  # 2
)


class efsIsFile_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsIsFile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsIsFile_result)
efsIsFile_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class efsGetFileSize_args(object):
    """
    Attributes:
     - pathName
     - efsSystem

    """


    def __init__(self, pathName=None, efsSystem=None,):
        self.pathName = pathName
        self.efsSystem = efsSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.efsSystem = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsGetFileSize_args')
        if self.pathName is not None:
            oprot.writeFieldBegin('pathName', TType.STRING, 1)
            oprot.writeString(self.pathName.encode('utf-8') if sys.version_info[0] == 2 else self.pathName)
            oprot.writeFieldEnd()
        if self.efsSystem is not None:
            oprot.writeFieldBegin('efsSystem', TType.I32, 2)
            oprot.writeI32(self.efsSystem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsGetFileSize_args)
efsGetFileSize_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'efsSystem', None, None, ),  # 2
)


class efsGetFileSize_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsGetFileSize_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsGetFileSize_result)
efsGetFileSize_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class efsGetAvailableSpace_args(object):
    """
    Attributes:
     - efsSystem

    """


    def __init__(self, efsSystem=None,):
        self.efsSystem = efsSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.efsSystem = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsGetAvailableSpace_args')
        if self.efsSystem is not None:
            oprot.writeFieldBegin('efsSystem', TType.I32, 1)
            oprot.writeI32(self.efsSystem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsGetAvailableSpace_args)
efsGetAvailableSpace_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'efsSystem', None, None, ),  # 1
)


class efsGetAvailableSpace_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsGetAvailableSpace_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsGetAvailableSpace_result)
efsGetAvailableSpace_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class efsGetFileCheckSum_args(object):
    """
    Attributes:
     - pathName
     - efsSystem

    """


    def __init__(self, pathName=None, efsSystem=None,):
        self.pathName = pathName
        self.efsSystem = efsSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.efsSystem = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsGetFileCheckSum_args')
        if self.pathName is not None:
            oprot.writeFieldBegin('pathName', TType.STRING, 1)
            oprot.writeString(self.pathName.encode('utf-8') if sys.version_info[0] == 2 else self.pathName)
            oprot.writeFieldEnd()
        if self.efsSystem is not None:
            oprot.writeFieldBegin('efsSystem', TType.I32, 2)
            oprot.writeI32(self.efsSystem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsGetFileCheckSum_args)
efsGetFileCheckSum_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'efsSystem', None, None, ),  # 2
)


class efsGetFileCheckSum_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsGetFileCheckSum_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsGetFileCheckSum_result)
efsGetFileCheckSum_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class efsGetFileAttributes_args(object):
    """
    Attributes:
     - pathName
     - efsSystem

    """


    def __init__(self, pathName=None, efsSystem=None,):
        self.pathName = pathName
        self.efsSystem = efsSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.efsSystem = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsGetFileAttributes_args')
        if self.pathName is not None:
            oprot.writeFieldBegin('pathName', TType.STRING, 1)
            oprot.writeString(self.pathName.encode('utf-8') if sys.version_info[0] == 2 else self.pathName)
            oprot.writeFieldEnd()
        if self.efsSystem is not None:
            oprot.writeFieldBegin('efsSystem', TType.I32, 2)
            oprot.writeI32(self.efsSystem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsGetFileAttributes_args)
efsGetFileAttributes_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'efsSystem', None, None, ),  # 2
)


class efsGetFileAttributes_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = EfsFileAttributes()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsGetFileAttributes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsGetFileAttributes_result)
efsGetFileAttributes_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [EfsFileAttributes, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class efsIsReady_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsIsReady_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsIsReady_args)
efsIsReady_args.thrift_spec = (
)


class efsIsReady_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsIsReady_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsIsReady_result)
efsIsReady_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class createGoldenCopy_args(object):
    """
    Attributes:
     - pathName
     - efsSystem

    """


    def __init__(self, pathName=None, efsSystem=None,):
        self.pathName = pathName
        self.efsSystem = efsSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.efsSystem = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createGoldenCopy_args')
        if self.pathName is not None:
            oprot.writeFieldBegin('pathName', TType.STRING, 1)
            oprot.writeString(self.pathName.encode('utf-8') if sys.version_info[0] == 2 else self.pathName)
            oprot.writeFieldEnd()
        if self.efsSystem is not None:
            oprot.writeFieldBegin('efsSystem', TType.I32, 2)
            oprot.writeI32(self.efsSystem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createGoldenCopy_args)
createGoldenCopy_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'efsSystem', None, None, ),  # 2
)


class createGoldenCopy_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createGoldenCopy_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createGoldenCopy_result)
createGoldenCopy_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class createGoldenCopyV2_args(object):
    """
    Attributes:
     - createGoldenCopyV2Options
     - efsSystem

    """


    def __init__(self, createGoldenCopyV2Options=None, efsSystem=None,):
        self.createGoldenCopyV2Options = createGoldenCopyV2Options
        self.efsSystem = efsSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.createGoldenCopyV2Options = CreateGoldenCopyV2Options()
                    self.createGoldenCopyV2Options.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.efsSystem = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createGoldenCopyV2_args')
        if self.createGoldenCopyV2Options is not None:
            oprot.writeFieldBegin('createGoldenCopyV2Options', TType.STRUCT, 1)
            self.createGoldenCopyV2Options.write(oprot)
            oprot.writeFieldEnd()
        if self.efsSystem is not None:
            oprot.writeFieldBegin('efsSystem', TType.I32, 2)
            oprot.writeI32(self.efsSystem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createGoldenCopyV2_args)
createGoldenCopyV2_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'createGoldenCopyV2Options', [CreateGoldenCopyV2Options, None], None, ),  # 1
    (2, TType.I32, 'efsSystem', None, None, ),  # 2
)


class createGoldenCopyV2_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createGoldenCopyV2_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createGoldenCopyV2_result)
createGoldenCopyV2_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class createCefsCopy_args(object):
    """
    Attributes:
     - cefsSavePath
     - efsSystem

    """


    def __init__(self, cefsSavePath=None, efsSystem=None,):
        self.cefsSavePath = cefsSavePath
        self.efsSystem = efsSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cefsSavePath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.efsSystem = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createCefsCopy_args')
        if self.cefsSavePath is not None:
            oprot.writeFieldBegin('cefsSavePath', TType.STRING, 1)
            oprot.writeString(self.cefsSavePath.encode('utf-8') if sys.version_info[0] == 2 else self.cefsSavePath)
            oprot.writeFieldEnd()
        if self.efsSystem is not None:
            oprot.writeFieldBegin('efsSystem', TType.I32, 2)
            oprot.writeI32(self.efsSystem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createCefsCopy_args)
createCefsCopy_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cefsSavePath', 'UTF8', None, ),  # 1
    (2, TType.I32, 'efsSystem', None, None, ),  # 2
)


class createCefsCopy_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createCefsCopy_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createCefsCopy_result)
createCefsCopy_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class createFactoryEfsCopy_args(object):
    """
    Attributes:
     - efsSystem
     - factoryEfsCopyOptions

    """


    def __init__(self, efsSystem=None, factoryEfsCopyOptions=None,):
        self.efsSystem = efsSystem
        self.factoryEfsCopyOptions = factoryEfsCopyOptions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.efsSystem = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.factoryEfsCopyOptions = FactoryEfsCopyOptions()
                    self.factoryEfsCopyOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createFactoryEfsCopy_args')
        if self.efsSystem is not None:
            oprot.writeFieldBegin('efsSystem', TType.I32, 1)
            oprot.writeI32(self.efsSystem)
            oprot.writeFieldEnd()
        if self.factoryEfsCopyOptions is not None:
            oprot.writeFieldBegin('factoryEfsCopyOptions', TType.STRUCT, 2)
            self.factoryEfsCopyOptions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createFactoryEfsCopy_args)
createFactoryEfsCopy_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'efsSystem', None, None, ),  # 1
    (2, TType.STRUCT, 'factoryEfsCopyOptions', [FactoryEfsCopyOptions, None], None, ),  # 2
)


class createFactoryEfsCopy_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createFactoryEfsCopy_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createFactoryEfsCopy_result)
createFactoryEfsCopy_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class requestPrl_args(object):
    """
    Attributes:
     - subscriptionId
     - index

    """


    def __init__(self, subscriptionId=None, index=None,):
        self.subscriptionId = subscriptionId
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.subscriptionId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.index = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('requestPrl_args')
        if self.subscriptionId is not None:
            oprot.writeFieldBegin('subscriptionId', TType.I32, 1)
            oprot.writeI32(self.subscriptionId)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.BYTE, 2)
            oprot.writeByte(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(requestPrl_args)
requestPrl_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'subscriptionId', None, None, ),  # 1
    (2, TType.BYTE, 'index', None, None, ),  # 2
)


class requestPrl_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('requestPrl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(requestPrl_result)
requestPrl_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class backupPrl_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('backupPrl_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(backupPrl_args)
backupPrl_args.thrift_spec = (
)


class backupPrl_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('backupPrl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(backupPrl_result)
backupPrl_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class restorePrl_args(object):
    """
    Attributes:
     - xqcnFileContents

    """


    def __init__(self, xqcnFileContents=None,):
        self.xqcnFileContents = xqcnFileContents

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.xqcnFileContents = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('restorePrl_args')
        if self.xqcnFileContents is not None:
            oprot.writeFieldBegin('xqcnFileContents', TType.STRING, 1)
            oprot.writeString(self.xqcnFileContents.encode('utf-8') if sys.version_info[0] == 2 else self.xqcnFileContents)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(restorePrl_args)
restorePrl_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'xqcnFileContents', 'UTF8', None, ),  # 1
)


class restorePrl_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('restorePrl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(restorePrl_result)
restorePrl_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class sendPrl_args(object):
    """
    Attributes:
     - subscriptionId
     - index
     - prlFileContents

    """


    def __init__(self, subscriptionId=None, index=None, prlFileContents=None,):
        self.subscriptionId = subscriptionId
        self.index = index
        self.prlFileContents = prlFileContents

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.subscriptionId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.index = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.prlFileContents = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sendPrl_args')
        if self.subscriptionId is not None:
            oprot.writeFieldBegin('subscriptionId', TType.I32, 1)
            oprot.writeI32(self.subscriptionId)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.BYTE, 2)
            oprot.writeByte(self.index)
            oprot.writeFieldEnd()
        if self.prlFileContents is not None:
            oprot.writeFieldBegin('prlFileContents', TType.STRING, 3)
            oprot.writeBinary(self.prlFileContents)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sendPrl_args)
sendPrl_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'subscriptionId', None, None, ),  # 1
    (2, TType.BYTE, 'index', None, None, ),  # 2
    (3, TType.STRING, 'prlFileContents', 'BINARY', None, ),  # 3
)


class sendPrl_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sendPrl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sendPrl_result)
sendPrl_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class forceEfsSync_args(object):
    """
    Attributes:
     - pathName
     - efsSystem

    """


    def __init__(self, pathName=None, efsSystem=None,):
        self.pathName = pathName
        self.efsSystem = efsSystem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.efsSystem = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forceEfsSync_args')
        if self.pathName is not None:
            oprot.writeFieldBegin('pathName', TType.STRING, 1)
            oprot.writeString(self.pathName.encode('utf-8') if sys.version_info[0] == 2 else self.pathName)
            oprot.writeFieldEnd()
        if self.efsSystem is not None:
            oprot.writeFieldBegin('efsSystem', TType.I32, 2)
            oprot.writeI32(self.efsSystem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forceEfsSync_args)
forceEfsSync_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'efsSystem', None, None, ),  # 2
)


class forceEfsSync_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forceEfsSync_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forceEfsSync_result)
forceEfsSync_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getEsn_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getEsn_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getEsn_args)
getEsn_args.thrift_spec = (
)


class getEsn_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getEsn_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getEsn_result)
getEsn_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class setEsn_args(object):
    """
    Attributes:
     - esn

    """


    def __init__(self, esn=None,):
        self.esn = esn

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.esn = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setEsn_args')
        if self.esn is not None:
            oprot.writeFieldBegin('esn', TType.I32, 1)
            oprot.writeI32(self.esn)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setEsn_args)
setEsn_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'esn', None, None, ),  # 1
)


class setEsn_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setEsn_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setEsn_result)
setEsn_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getImei_args(object):
    """
    Attributes:
     - subscriptionId

    """


    def __init__(self, subscriptionId=None,):
        self.subscriptionId = subscriptionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.subscriptionId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getImei_args')
        if self.subscriptionId is not None:
            oprot.writeFieldBegin('subscriptionId', TType.I32, 1)
            oprot.writeI32(self.subscriptionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getImei_args)
getImei_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'subscriptionId', None, None, ),  # 1
)


class getImei_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getImei_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getImei_result)
getImei_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class setImei_args(object):
    """
    Attributes:
     - imei
     - subscriptionId

    """


    def __init__(self, imei=None, subscriptionId=None,):
        self.imei = imei
        self.subscriptionId = subscriptionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.imei = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.subscriptionId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setImei_args')
        if self.imei is not None:
            oprot.writeFieldBegin('imei', TType.STRING, 1)
            oprot.writeBinary(self.imei)
            oprot.writeFieldEnd()
        if self.subscriptionId is not None:
            oprot.writeFieldBegin('subscriptionId', TType.I32, 2)
            oprot.writeI32(self.subscriptionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setImei_args)
setImei_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'imei', 'BINARY', None, ),  # 1
    (2, TType.I32, 'subscriptionId', None, None, ),  # 2
)


class setImei_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setImei_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setImei_result)
setImei_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getMeid_args(object):
    """
    Attributes:
     - subscriptionId

    """


    def __init__(self, subscriptionId=None,):
        self.subscriptionId = subscriptionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.subscriptionId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMeid_args')
        if self.subscriptionId is not None:
            oprot.writeFieldBegin('subscriptionId', TType.I32, 1)
            oprot.writeI32(self.subscriptionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMeid_args)
getMeid_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'subscriptionId', None, None, ),  # 1
)


class getMeid_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMeid_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMeid_result)
getMeid_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class setMeid_args(object):
    """
    Attributes:
     - meid
     - subscriptionId

    """


    def __init__(self, meid=None, subscriptionId=None,):
        self.meid = meid
        self.subscriptionId = subscriptionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.meid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.subscriptionId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setMeid_args')
        if self.meid is not None:
            oprot.writeFieldBegin('meid', TType.I64, 1)
            oprot.writeI64(self.meid)
            oprot.writeFieldEnd()
        if self.subscriptionId is not None:
            oprot.writeFieldBegin('subscriptionId', TType.I32, 2)
            oprot.writeI32(self.subscriptionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setMeid_args)
setMeid_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'meid', None, None, ),  # 1
    (2, TType.I32, 'subscriptionId', None, None, ),  # 2
)


class setMeid_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setMeid_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setMeid_result)
setMeid_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class checkSpc_args(object):
    """
    Attributes:
     - spc

    """


    def __init__(self, spc=None,):
        self.spc = spc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.spc = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('checkSpc_args')
        if self.spc is not None:
            oprot.writeFieldBegin('spc', TType.STRING, 1)
            oprot.writeString(self.spc.encode('utf-8') if sys.version_info[0] == 2 else self.spc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(checkSpc_args)
checkSpc_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'spc', 'UTF8', None, ),  # 1
)


class checkSpc_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('checkSpc_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(checkSpc_result)
checkSpc_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class provisionSpc_args(object):
    """
    Attributes:
     - currentSpc
     - newSpc

    """


    def __init__(self, currentSpc=None, newSpc=None,):
        self.currentSpc = currentSpc
        self.newSpc = newSpc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.currentSpc = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.newSpc = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('provisionSpc_args')
        if self.currentSpc is not None:
            oprot.writeFieldBegin('currentSpc', TType.STRING, 1)
            oprot.writeString(self.currentSpc.encode('utf-8') if sys.version_info[0] == 2 else self.currentSpc)
            oprot.writeFieldEnd()
        if self.newSpc is not None:
            oprot.writeFieldBegin('newSpc', TType.STRING, 2)
            oprot.writeString(self.newSpc.encode('utf-8') if sys.version_info[0] == 2 else self.newSpc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(provisionSpc_args)
provisionSpc_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'currentSpc', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'newSpc', 'UTF8', None, ),  # 2
)


class provisionSpc_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('provisionSpc_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(provisionSpc_result)
provisionSpc_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class efsReadFromModemLog_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsReadFromModemLog_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsReadFromModemLog_args)
efsReadFromModemLog_args.thrift_spec = (
)


class efsReadFromModemLog_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('efsReadFromModemLog_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(efsReadFromModemLog_result)
efsReadFromModemLog_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class configureService_args(object):
    """
    Attributes:
     - deviceConfigOptions

    """


    def __init__(self, deviceConfigOptions=None,):
        self.deviceConfigOptions = deviceConfigOptions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.deviceConfigOptions = DeviceConfigOptions()
                    self.deviceConfigOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('configureService_args')
        if self.deviceConfigOptions is not None:
            oprot.writeFieldBegin('deviceConfigOptions', TType.STRUCT, 1)
            self.deviceConfigOptions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(configureService_args)
configureService_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'deviceConfigOptions', [DeviceConfigOptions, None], None, ),  # 1
)


class configureService_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('configureService_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(configureService_result)
configureService_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs
