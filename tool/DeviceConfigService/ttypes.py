#
# Autogenerated by Thrift Compiler (0.14.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import Common.ttypes
import DiagService.ttypes

from thrift.transport import TTransport
all_structs = []


class PdcMbnType(object):
    PDC_CONFIG_TYPE_MODEM_PLATFORM = 0
    PDC_CONFIG_TYPE_MODEM_SW = 1

    _VALUES_TO_NAMES = {
        0: "PDC_CONFIG_TYPE_MODEM_PLATFORM",
        1: "PDC_CONFIG_TYPE_MODEM_SW",
    }

    _NAMES_TO_VALUES = {
        "PDC_CONFIG_TYPE_MODEM_PLATFORM": 0,
        "PDC_CONFIG_TYPE_MODEM_SW": 1,
    }


class PdcConfigurationType(object):
    SELECTION_MODE = 0
    CARRIER = 1
    FLEX_MAPPING = 2
    REFRESH_MODE = 3
    MULTISIM = 4
    OS = 5
    MARKET = 6
    DEPLOYMENT = 7
    IMS_FEATURE = 8
    VARIANT = 9
    COUNTRY = 10

    _VALUES_TO_NAMES = {
        0: "SELECTION_MODE",
        1: "CARRIER",
        2: "FLEX_MAPPING",
        3: "REFRESH_MODE",
        4: "MULTISIM",
        5: "OS",
        6: "MARKET",
        7: "DEPLOYMENT",
        8: "IMS_FEATURE",
        9: "VARIANT",
        10: "COUNTRY",
    }

    _NAMES_TO_VALUES = {
        "SELECTION_MODE": 0,
        "CARRIER": 1,
        "FLEX_MAPPING": 2,
        "REFRESH_MODE": 3,
        "MULTISIM": 4,
        "OS": 5,
        "MARKET": 6,
        "DEPLOYMENT": 7,
        "IMS_FEATURE": 8,
        "VARIANT": 9,
        "COUNTRY": 10,
    }


class NvReturnFlags(object):
    BINARY_PAYLOAD = 1
    PARSED_TEXT = 2
    JSON_TEXT = 3
    VALUE_LIST = 4

    _VALUES_TO_NAMES = {
        1: "BINARY_PAYLOAD",
        2: "PARSED_TEXT",
        3: "JSON_TEXT",
        4: "VALUE_LIST",
    }

    _NAMES_TO_VALUES = {
        "BINARY_PAYLOAD": 1,
        "PARSED_TEXT": 2,
        "JSON_TEXT": 3,
        "VALUE_LIST": 4,
    }


class FileSystem(object):
    FS_PRIMARY = 0
    FS_ALTERNATE = 1

    _VALUES_TO_NAMES = {
        0: "FS_PRIMARY",
        1: "FS_ALTERNATE",
    }

    _NAMES_TO_VALUES = {
        "FS_PRIMARY": 0,
        "FS_ALTERNATE": 1,
    }


class EfsType(object):
    DIRECTORY = 0
    FILE = 1
    SYMLINK = 2

    _VALUES_TO_NAMES = {
        0: "DIRECTORY",
        1: "FILE",
        2: "SYMLINK",
    }

    _NAMES_TO_VALUES = {
        "DIRECTORY": 0,
        "FILE": 1,
        "SYMLINK": 2,
    }


class EfsGoldenCopyType(object):
    UNDEFINE = 0
    WHOLE_SNAPSHOT_IMAGE = 1
    SELECTED_LIST_FILES = 2
    OEM_1_SELECTED_LIST_FILES = 3
    OEM_2_SELECTED_LIST_FILES = 4
    ZIPPED_TAR_OR_SELECTED_LIST_FILES = 5

    _VALUES_TO_NAMES = {
        0: "UNDEFINE",
        1: "WHOLE_SNAPSHOT_IMAGE",
        2: "SELECTED_LIST_FILES",
        3: "OEM_1_SELECTED_LIST_FILES",
        4: "OEM_2_SELECTED_LIST_FILES",
        5: "ZIPPED_TAR_OR_SELECTED_LIST_FILES",
    }

    _NAMES_TO_VALUES = {
        "UNDEFINE": 0,
        "WHOLE_SNAPSHOT_IMAGE": 1,
        "SELECTED_LIST_FILES": 2,
        "OEM_1_SELECTED_LIST_FILES": 3,
        "OEM_2_SELECTED_LIST_FILES": 4,
        "ZIPPED_TAR_OR_SELECTED_LIST_FILES": 5,
    }


class PdcMbnInfo(object):
    """
    Attributes:
     - errorCode
     - type
     - size
     - version
     - baseVersion
     - storageType
     - configId
     - description
     - path

    """


    def __init__(self, errorCode=None, type=None, size=None, version=None, baseVersion=None, storageType=None, configId=None, description=None, path=None,):
        self.errorCode = errorCode
        self.type = type
        self.size = size
        self.version = version
        self.baseVersion = baseVersion
        self.storageType = storageType
        self.configId = configId
        self.description = description
        self.path = path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.errorCode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.baseVersion = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.storageType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.configId = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.description = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PdcMbnInfo')
        if self.errorCode is not None:
            oprot.writeFieldBegin('errorCode', TType.I32, 1)
            oprot.writeI32(self.errorCode)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 2)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 3)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.I32, 4)
            oprot.writeI32(self.version)
            oprot.writeFieldEnd()
        if self.baseVersion is not None:
            oprot.writeFieldBegin('baseVersion', TType.I32, 5)
            oprot.writeI32(self.baseVersion)
            oprot.writeFieldEnd()
        if self.storageType is not None:
            oprot.writeFieldBegin('storageType', TType.I32, 6)
            oprot.writeI32(self.storageType)
            oprot.writeFieldEnd()
        if self.configId is not None:
            oprot.writeFieldBegin('configId', TType.STRING, 7)
            oprot.writeBinary(self.configId)
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin('description', TType.STRING, 8)
            oprot.writeString(self.description.encode('utf-8') if sys.version_info[0] == 2 else self.description)
            oprot.writeFieldEnd()
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 9)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PdcMbnResult(object):
    """
    Attributes:
     - errorCode
     - version
     - frame

    """


    def __init__(self, errorCode=None, version=None, frame=None,):
        self.errorCode = errorCode
        self.version = version
        self.frame = frame

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.errorCode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.frame = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PdcMbnResult')
        if self.errorCode is not None:
            oprot.writeFieldBegin('errorCode', TType.I32, 1)
            oprot.writeI32(self.errorCode)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.I32, 2)
            oprot.writeI32(self.version)
            oprot.writeFieldEnd()
        if self.frame is not None:
            oprot.writeFieldBegin('frame', TType.STRING, 3)
            oprot.writeString(self.frame.encode('utf-8') if sys.version_info[0] == 2 else self.frame)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NvReturns(object):
    """
    Attributes:
     - flags
     - fieldQueries

    """


    def __init__(self, flags=None, fieldQueries=None,):
        self.flags = flags
        self.fieldQueries = fieldQueries

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.flags = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.fieldQueries = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.fieldQueries.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NvReturns')
        if self.flags is not None:
            oprot.writeFieldBegin('flags', TType.I32, 1)
            oprot.writeI32(self.flags)
            oprot.writeFieldEnd()
        if self.fieldQueries is not None:
            oprot.writeFieldBegin('fieldQueries', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.fieldQueries))
            for iter6 in self.fieldQueries:
                oprot.writeString(iter6.encode('utf-8') if sys.version_info[0] == 2 else iter6)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NvData(object):
    """
    Attributes:
     - errorCode
     - payload
     - parsedText
     - parsedJson
     - valueList
     - queryResultJson

    """


    def __init__(self, errorCode=None, payload=None, parsedText=None, parsedJson=None, valueList=None, queryResultJson=None,):
        self.errorCode = errorCode
        self.payload = payload
        self.parsedText = parsedText
        self.parsedJson = parsedJson
        self.valueList = valueList
        self.queryResultJson = queryResultJson

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.errorCode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.payload = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.parsedText = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.parsedJson = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.valueList = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.queryResultJson = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NvData')
        if self.errorCode is not None:
            oprot.writeFieldBegin('errorCode', TType.I32, 1)
            oprot.writeI32(self.errorCode)
            oprot.writeFieldEnd()
        if self.payload is not None:
            oprot.writeFieldBegin('payload', TType.STRING, 2)
            oprot.writeBinary(self.payload)
            oprot.writeFieldEnd()
        if self.parsedText is not None:
            oprot.writeFieldBegin('parsedText', TType.STRING, 3)
            oprot.writeString(self.parsedText.encode('utf-8') if sys.version_info[0] == 2 else self.parsedText)
            oprot.writeFieldEnd()
        if self.parsedJson is not None:
            oprot.writeFieldBegin('parsedJson', TType.STRING, 4)
            oprot.writeString(self.parsedJson.encode('utf-8') if sys.version_info[0] == 2 else self.parsedJson)
            oprot.writeFieldEnd()
        if self.valueList is not None:
            oprot.writeFieldBegin('valueList', TType.STRING, 5)
            oprot.writeString(self.valueList.encode('utf-8') if sys.version_info[0] == 2 else self.valueList)
            oprot.writeFieldEnd()
        if self.queryResultJson is not None:
            oprot.writeFieldBegin('queryResultJson', TType.STRING, 6)
            oprot.writeString(self.queryResultJson.encode('utf-8') if sys.version_info[0] == 2 else self.queryResultJson)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EfsFileAttributes(object):
    """
    Attributes:
     - modifiedTime
     - createdTime
     - attributes
     - mode
     - nLinks
     - fileSize

    """


    def __init__(self, modifiedTime=None, createdTime=None, attributes=None, mode=None, nLinks=None, fileSize=None,):
        self.modifiedTime = modifiedTime
        self.createdTime = createdTime
        self.attributes = attributes
        self.mode = mode
        self.nLinks = nLinks
        self.fileSize = fileSize

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modifiedTime = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.createdTime = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.attributes = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.nLinks = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.fileSize = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EfsFileAttributes')
        if self.modifiedTime is not None:
            oprot.writeFieldBegin('modifiedTime', TType.STRING, 1)
            oprot.writeString(self.modifiedTime.encode('utf-8') if sys.version_info[0] == 2 else self.modifiedTime)
            oprot.writeFieldEnd()
        if self.createdTime is not None:
            oprot.writeFieldBegin('createdTime', TType.STRING, 2)
            oprot.writeString(self.createdTime.encode('utf-8') if sys.version_info[0] == 2 else self.createdTime)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.STRING, 3)
            oprot.writeString(self.attributes.encode('utf-8') if sys.version_info[0] == 2 else self.attributes)
            oprot.writeFieldEnd()
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 4)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        if self.nLinks is not None:
            oprot.writeFieldBegin('nLinks', TType.I32, 5)
            oprot.writeI32(self.nLinks)
            oprot.writeFieldEnd()
        if self.fileSize is not None:
            oprot.writeFieldBegin('fileSize', TType.I64, 6)
            oprot.writeI64(self.fileSize)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EfsItem(object):
    """
    Attributes:
     - type
     - name
     - accessible

    """


    def __init__(self, type=None, name=None, accessible=None,):
        self.type = type
        self.name = name
        self.accessible = accessible

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.accessible = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EfsItem')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.accessible is not None:
            oprot.writeFieldBegin('accessible', TType.BOOL, 3)
            oprot.writeBool(self.accessible)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DeviceConfigConnectionOptions(object):
    """
    Attributes:
     - diagConnectionOptions
     - qmiConnectionOptions

    """


    def __init__(self, diagConnectionOptions=None, qmiConnectionOptions=None,):
        self.diagConnectionOptions = diagConnectionOptions
        self.qmiConnectionOptions = qmiConnectionOptions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.diagConnectionOptions = DiagService.ttypes.DiagConnectionOptions()
                    self.diagConnectionOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.qmiConnectionOptions = Common.ttypes.QmiConnectionOptions()
                    self.qmiConnectionOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeviceConfigConnectionOptions')
        if self.diagConnectionOptions is not None:
            oprot.writeFieldBegin('diagConnectionOptions', TType.STRUCT, 1)
            self.diagConnectionOptions.write(oprot)
            oprot.writeFieldEnd()
        if self.qmiConnectionOptions is not None:
            oprot.writeFieldBegin('qmiConnectionOptions', TType.STRUCT, 2)
            self.qmiConnectionOptions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DeviceConfigOptions(object):
    """
    Attributes:
     - useDiagForPdc
     - xqcnOperationType
     - xqcnRestoreOptions
     - xqcnBackupOptions

    """


    def __init__(self, useDiagForPdc=None, xqcnOperationType=None, xqcnRestoreOptions=None, xqcnBackupOptions=None,):
        self.useDiagForPdc = useDiagForPdc
        self.xqcnOperationType = xqcnOperationType
        self.xqcnRestoreOptions = xqcnRestoreOptions
        self.xqcnBackupOptions = xqcnBackupOptions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.useDiagForPdc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.xqcnOperationType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.xqcnRestoreOptions = Common.ttypes.XqcnRestoreOptions()
                    self.xqcnRestoreOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.xqcnBackupOptions = Common.ttypes.XqcnBackupOptions()
                    self.xqcnBackupOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeviceConfigOptions')
        if self.useDiagForPdc is not None:
            oprot.writeFieldBegin('useDiagForPdc', TType.BOOL, 1)
            oprot.writeBool(self.useDiagForPdc)
            oprot.writeFieldEnd()
        if self.xqcnOperationType is not None:
            oprot.writeFieldBegin('xqcnOperationType', TType.I32, 2)
            oprot.writeI32(self.xqcnOperationType)
            oprot.writeFieldEnd()
        if self.xqcnRestoreOptions is not None:
            oprot.writeFieldBegin('xqcnRestoreOptions', TType.STRUCT, 3)
            self.xqcnRestoreOptions.write(oprot)
            oprot.writeFieldEnd()
        if self.xqcnBackupOptions is not None:
            oprot.writeFieldBegin('xqcnBackupOptions', TType.STRUCT, 4)
            self.xqcnBackupOptions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CreateGoldenCopyV2Options(object):
    """
    Attributes:
     - pathName
     - efsGoldenCopyType
     - statusPollingIntervalInMs
     - statusPollingMaxAttempts

    """


    def __init__(self, pathName=None, efsGoldenCopyType=None, statusPollingIntervalInMs=None, statusPollingMaxAttempts=None,):
        self.pathName = pathName
        self.efsGoldenCopyType = efsGoldenCopyType
        self.statusPollingIntervalInMs = statusPollingIntervalInMs
        self.statusPollingMaxAttempts = statusPollingMaxAttempts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.efsGoldenCopyType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.statusPollingIntervalInMs = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.statusPollingMaxAttempts = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateGoldenCopyV2Options')
        if self.pathName is not None:
            oprot.writeFieldBegin('pathName', TType.STRING, 1)
            oprot.writeString(self.pathName.encode('utf-8') if sys.version_info[0] == 2 else self.pathName)
            oprot.writeFieldEnd()
        if self.efsGoldenCopyType is not None:
            oprot.writeFieldBegin('efsGoldenCopyType', TType.I32, 2)
            oprot.writeI32(self.efsGoldenCopyType)
            oprot.writeFieldEnd()
        if self.statusPollingIntervalInMs is not None:
            oprot.writeFieldBegin('statusPollingIntervalInMs', TType.I32, 3)
            oprot.writeI32(self.statusPollingIntervalInMs)
            oprot.writeFieldEnd()
        if self.statusPollingMaxAttempts is not None:
            oprot.writeFieldBegin('statusPollingMaxAttempts', TType.I32, 4)
            oprot.writeI32(self.statusPollingMaxAttempts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FactoryEfsCopyOptions(object):
    """
    Attributes:
     - imageType
     - statusPollingIntervalInMs
     - statusPollingMaxAttempts

    """


    def __init__(self, imageType=None, statusPollingIntervalInMs=None, statusPollingMaxAttempts=None,):
        self.imageType = imageType
        self.statusPollingIntervalInMs = statusPollingIntervalInMs
        self.statusPollingMaxAttempts = statusPollingMaxAttempts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.imageType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.statusPollingIntervalInMs = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.statusPollingMaxAttempts = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FactoryEfsCopyOptions')
        if self.imageType is not None:
            oprot.writeFieldBegin('imageType', TType.I32, 1)
            oprot.writeI32(self.imageType)
            oprot.writeFieldEnd()
        if self.statusPollingIntervalInMs is not None:
            oprot.writeFieldBegin('statusPollingIntervalInMs', TType.I32, 2)
            oprot.writeI32(self.statusPollingIntervalInMs)
            oprot.writeFieldEnd()
        if self.statusPollingMaxAttempts is not None:
            oprot.writeFieldBegin('statusPollingMaxAttempts', TType.I32, 3)
            oprot.writeI32(self.statusPollingMaxAttempts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(PdcMbnInfo)
PdcMbnInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'errorCode', None, None, ),  # 1
    (2, TType.I32, 'type', None, None, ),  # 2
    (3, TType.I32, 'size', None, None, ),  # 3
    (4, TType.I32, 'version', None, None, ),  # 4
    (5, TType.I32, 'baseVersion', None, None, ),  # 5
    (6, TType.I32, 'storageType', None, None, ),  # 6
    (7, TType.STRING, 'configId', 'BINARY', None, ),  # 7
    (8, TType.STRING, 'description', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'path', 'UTF8', None, ),  # 9
)
all_structs.append(PdcMbnResult)
PdcMbnResult.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'errorCode', None, None, ),  # 1
    (2, TType.I32, 'version', None, None, ),  # 2
    (3, TType.STRING, 'frame', 'UTF8', None, ),  # 3
)
all_structs.append(NvReturns)
NvReturns.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'flags', None, None, ),  # 1
    (2, TType.LIST, 'fieldQueries', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(NvData)
NvData.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'errorCode', None, None, ),  # 1
    (2, TType.STRING, 'payload', 'BINARY', None, ),  # 2
    (3, TType.STRING, 'parsedText', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'parsedJson', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'valueList', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'queryResultJson', 'UTF8', None, ),  # 6
)
all_structs.append(EfsFileAttributes)
EfsFileAttributes.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modifiedTime', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'createdTime', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'attributes', 'UTF8', None, ),  # 3
    (4, TType.I32, 'mode', None, None, ),  # 4
    (5, TType.I32, 'nLinks', None, None, ),  # 5
    (6, TType.I64, 'fileSize', None, None, ),  # 6
)
all_structs.append(EfsItem)
EfsItem.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'accessible', None, None, ),  # 3
)
all_structs.append(DeviceConfigConnectionOptions)
DeviceConfigConnectionOptions.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'diagConnectionOptions', [DiagService.ttypes.DiagConnectionOptions, None], None, ),  # 1
    (2, TType.STRUCT, 'qmiConnectionOptions', [Common.ttypes.QmiConnectionOptions, None], None, ),  # 2
)
all_structs.append(DeviceConfigOptions)
DeviceConfigOptions.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'useDiagForPdc', None, None, ),  # 1
    (2, TType.I32, 'xqcnOperationType', None, None, ),  # 2
    (3, TType.STRUCT, 'xqcnRestoreOptions', [Common.ttypes.XqcnRestoreOptions, None], None, ),  # 3
    (4, TType.STRUCT, 'xqcnBackupOptions', [Common.ttypes.XqcnBackupOptions, None], None, ),  # 4
)
all_structs.append(CreateGoldenCopyV2Options)
CreateGoldenCopyV2Options.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'efsGoldenCopyType', None, None, ),  # 2
    (3, TType.I32, 'statusPollingIntervalInMs', None, None, ),  # 3
    (4, TType.I32, 'statusPollingMaxAttempts', None, None, ),  # 4
)
all_structs.append(FactoryEfsCopyOptions)
FactoryEfsCopyOptions.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'imageType', None, None, ),  # 1
    (2, TType.I32, 'statusPollingIntervalInMs', None, None, ),  # 2
    (3, TType.I32, 'statusPollingMaxAttempts', None, None, ),  # 3
)
fix_spec(all_structs)
del all_structs
