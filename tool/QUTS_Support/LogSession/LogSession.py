#
# Autogenerated by Thrift Compiler (0.14.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def getLastError(self):
        pass

    def destroyLogSession(self):
        pass

    def getDeviceList(self):
        pass

    def getProtocolList(self, deviceHandle):
        """
        Parameters:
         - deviceHandle

        """
        pass

    def getDataPacketCount(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        pass

    def createDataView(self, viewName, filter, returnConfig):
        """
        Parameters:
         - viewName
         - filter
         - returnConfig

        """
        pass

    def createDefaultDataView(self, viewName, protocolHandleList, returnConfig):
        """
        Parameters:
         - viewName
         - protocolHandleList
         - returnConfig

        """
        pass

    def createDataViewSet(self, dataViewDefinitions):
        """
        Parameters:
         - dataViewDefinitions

        """
        pass

    def removeDataView(self, viewName):
        """
        Parameters:
         - viewName

        """
        pass

    def getDataViewItemCount(self, viewName):
        """
        Parameters:
         - viewName

        """
        pass

    def getDataViewItems(self, viewName, packets):
        """
        Parameters:
         - viewName
         - packets

        """
        pass

    def saveDataViewItemsByIndex(self, viewName, destinationFolder, dataViewIndexes):
        """
        Parameters:
         - viewName
         - destinationFolder
         - dataViewIndexes

        """
        pass

    def saveDataViewItemsByIndexWithFilenames(self, viewName, dataViewIndexes, logNamesByHandle):
        """
        Parameters:
         - viewName
         - dataViewIndexes
         - logNamesByHandle

        """
        pass

    def saveLogFiles(self, saveFolder):
        """
        Parameters:
         - saveFolder

        """
        pass

    def getDurationByProtocol(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        pass

    def updatePacketFilters(self, viewName, filter, updateType):
        """
        Parameters:
         - viewName
         - filter
         - updateType

        """
        pass

    def updatePacketReturnConfig(self, viewName, returnConfig):
        """
        Parameters:
         - viewName
         - returnConfig

        """
        pass

    def getAvailablePacketIds(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        pass

    def getLogSessionInformation(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        pass

    def loadQShrinkFile(self, protocolHandle, pathName):
        """
        Parameters:
         - protocolHandle
         - pathName

        """
        pass

    def getDataViewItemIndex(self, viewName, sessionIndex):
        """
        Parameters:
         - viewName
         - sessionIndex

        """
        pass

    def getTimeStampTodAdjustedByDataviewIndexForAnnotations(self, viewName, dataviewIndex):
        """
        Parameters:
         - viewName
         - dataviewIndex

        """
        pass

    def getDataViewItemsForConfiguration(self, viewName, packets, returnConfig):
        """
        Parameters:
         - viewName
         - packets
         - returnConfig

        """
        pass

    def getClientSessionInfo(self):
        pass

    def createSubDataView(self, viewName, parentViewName, filter, packets, returnConfig):
        """
        Parameters:
         - viewName
         - parentViewName
         - filter
         - packets
         - returnConfig

        """
        pass

    def setWcdmaProtocolRevision(self, protocolHandle, revision):
        """
        Parameters:
         - protocolHandle
         - revision

        """
        pass

    def setCdmaProtocolRevision(self, protocolHandle, revision):
        """
        Parameters:
         - protocolHandle
         - revision

        """
        pass

    def setPilotInc(self, protocolHandle, pilotInc):
        """
        Parameters:
         - protocolHandle
         - pilotInc

        """
        pass

    def getBandClass(self, protocolHandle, protocolIndex):
        """
        Parameters:
         - protocolHandle
         - protocolIndex

        """
        pass

    def getCdmaProtocolRevision(self, protocolHandle, protocolIndex):
        """
        Parameters:
         - protocolHandle
         - protocolIndex

        """
        pass

    def getModel(self, protocolHandle, protocolIndex):
        """
        Parameters:
         - protocolHandle
         - protocolIndex

        """
        pass

    def getWcdmaProtocolRevision(self, protocolHandle, protocolIndex):
        """
        Parameters:
         - protocolHandle
         - protocolIndex

        """
        pass

    def getDecryptionKeyStatus(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        pass

    def saveMbnToFolder(self, protocolHandle, filePath):
        """
        Parameters:
         - protocolHandle
         - filePath

        """
        pass

    def getDecryptionFailureCount(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        pass

    def saveDataViewWithOptions(self, saveDataViewSettings):
        """
        Parameters:
         - saveDataViewSettings

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def getLastError(self):
        self.send_getLastError()
        return self.recv_getLastError()

    def send_getLastError(self):
        self._oprot.writeMessageBegin('getLastError', TMessageType.CALL, self._seqid)
        args = getLastError_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getLastError(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getLastError_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getLastError failed: unknown result")

    def destroyLogSession(self):
        self.send_destroyLogSession()
        return self.recv_destroyLogSession()

    def send_destroyLogSession(self):
        self._oprot.writeMessageBegin('destroyLogSession', TMessageType.CALL, self._seqid)
        args = destroyLogSession_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_destroyLogSession(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = destroyLogSession_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "destroyLogSession failed: unknown result")

    def getDeviceList(self):
        self.send_getDeviceList()
        return self.recv_getDeviceList()

    def send_getDeviceList(self):
        self._oprot.writeMessageBegin('getDeviceList', TMessageType.CALL, self._seqid)
        args = getDeviceList_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDeviceList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDeviceList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDeviceList failed: unknown result")

    def getProtocolList(self, deviceHandle):
        """
        Parameters:
         - deviceHandle

        """
        self.send_getProtocolList(deviceHandle)
        return self.recv_getProtocolList()

    def send_getProtocolList(self, deviceHandle):
        self._oprot.writeMessageBegin('getProtocolList', TMessageType.CALL, self._seqid)
        args = getProtocolList_args()
        args.deviceHandle = deviceHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getProtocolList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getProtocolList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getProtocolList failed: unknown result")

    def getDataPacketCount(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        self.send_getDataPacketCount(protocolHandle)
        return self.recv_getDataPacketCount()

    def send_getDataPacketCount(self, protocolHandle):
        self._oprot.writeMessageBegin('getDataPacketCount', TMessageType.CALL, self._seqid)
        args = getDataPacketCount_args()
        args.protocolHandle = protocolHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDataPacketCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDataPacketCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDataPacketCount failed: unknown result")

    def createDataView(self, viewName, filter, returnConfig):
        """
        Parameters:
         - viewName
         - filter
         - returnConfig

        """
        self.send_createDataView(viewName, filter, returnConfig)
        return self.recv_createDataView()

    def send_createDataView(self, viewName, filter, returnConfig):
        self._oprot.writeMessageBegin('createDataView', TMessageType.CALL, self._seqid)
        args = createDataView_args()
        args.viewName = viewName
        args.filter = filter
        args.returnConfig = returnConfig
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createDataView(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createDataView_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createDataView failed: unknown result")

    def createDefaultDataView(self, viewName, protocolHandleList, returnConfig):
        """
        Parameters:
         - viewName
         - protocolHandleList
         - returnConfig

        """
        self.send_createDefaultDataView(viewName, protocolHandleList, returnConfig)
        return self.recv_createDefaultDataView()

    def send_createDefaultDataView(self, viewName, protocolHandleList, returnConfig):
        self._oprot.writeMessageBegin('createDefaultDataView', TMessageType.CALL, self._seqid)
        args = createDefaultDataView_args()
        args.viewName = viewName
        args.protocolHandleList = protocolHandleList
        args.returnConfig = returnConfig
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createDefaultDataView(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createDefaultDataView_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createDefaultDataView failed: unknown result")

    def createDataViewSet(self, dataViewDefinitions):
        """
        Parameters:
         - dataViewDefinitions

        """
        self.send_createDataViewSet(dataViewDefinitions)
        return self.recv_createDataViewSet()

    def send_createDataViewSet(self, dataViewDefinitions):
        self._oprot.writeMessageBegin('createDataViewSet', TMessageType.CALL, self._seqid)
        args = createDataViewSet_args()
        args.dataViewDefinitions = dataViewDefinitions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createDataViewSet(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createDataViewSet_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createDataViewSet failed: unknown result")

    def removeDataView(self, viewName):
        """
        Parameters:
         - viewName

        """
        self.send_removeDataView(viewName)
        return self.recv_removeDataView()

    def send_removeDataView(self, viewName):
        self._oprot.writeMessageBegin('removeDataView', TMessageType.CALL, self._seqid)
        args = removeDataView_args()
        args.viewName = viewName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeDataView(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeDataView_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "removeDataView failed: unknown result")

    def getDataViewItemCount(self, viewName):
        """
        Parameters:
         - viewName

        """
        self.send_getDataViewItemCount(viewName)
        return self.recv_getDataViewItemCount()

    def send_getDataViewItemCount(self, viewName):
        self._oprot.writeMessageBegin('getDataViewItemCount', TMessageType.CALL, self._seqid)
        args = getDataViewItemCount_args()
        args.viewName = viewName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDataViewItemCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDataViewItemCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDataViewItemCount failed: unknown result")

    def getDataViewItems(self, viewName, packets):
        """
        Parameters:
         - viewName
         - packets

        """
        self.send_getDataViewItems(viewName, packets)
        return self.recv_getDataViewItems()

    def send_getDataViewItems(self, viewName, packets):
        self._oprot.writeMessageBegin('getDataViewItems', TMessageType.CALL, self._seqid)
        args = getDataViewItems_args()
        args.viewName = viewName
        args.packets = packets
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDataViewItems(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDataViewItems_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDataViewItems failed: unknown result")

    def saveDataViewItemsByIndex(self, viewName, destinationFolder, dataViewIndexes):
        """
        Parameters:
         - viewName
         - destinationFolder
         - dataViewIndexes

        """
        self.send_saveDataViewItemsByIndex(viewName, destinationFolder, dataViewIndexes)
        return self.recv_saveDataViewItemsByIndex()

    def send_saveDataViewItemsByIndex(self, viewName, destinationFolder, dataViewIndexes):
        self._oprot.writeMessageBegin('saveDataViewItemsByIndex', TMessageType.CALL, self._seqid)
        args = saveDataViewItemsByIndex_args()
        args.viewName = viewName
        args.destinationFolder = destinationFolder
        args.dataViewIndexes = dataViewIndexes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_saveDataViewItemsByIndex(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = saveDataViewItemsByIndex_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "saveDataViewItemsByIndex failed: unknown result")

    def saveDataViewItemsByIndexWithFilenames(self, viewName, dataViewIndexes, logNamesByHandle):
        """
        Parameters:
         - viewName
         - dataViewIndexes
         - logNamesByHandle

        """
        self.send_saveDataViewItemsByIndexWithFilenames(viewName, dataViewIndexes, logNamesByHandle)
        return self.recv_saveDataViewItemsByIndexWithFilenames()

    def send_saveDataViewItemsByIndexWithFilenames(self, viewName, dataViewIndexes, logNamesByHandle):
        self._oprot.writeMessageBegin('saveDataViewItemsByIndexWithFilenames', TMessageType.CALL, self._seqid)
        args = saveDataViewItemsByIndexWithFilenames_args()
        args.viewName = viewName
        args.dataViewIndexes = dataViewIndexes
        args.logNamesByHandle = logNamesByHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_saveDataViewItemsByIndexWithFilenames(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = saveDataViewItemsByIndexWithFilenames_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "saveDataViewItemsByIndexWithFilenames failed: unknown result")

    def saveLogFiles(self, saveFolder):
        """
        Parameters:
         - saveFolder

        """
        self.send_saveLogFiles(saveFolder)
        return self.recv_saveLogFiles()

    def send_saveLogFiles(self, saveFolder):
        self._oprot.writeMessageBegin('saveLogFiles', TMessageType.CALL, self._seqid)
        args = saveLogFiles_args()
        args.saveFolder = saveFolder
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_saveLogFiles(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = saveLogFiles_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "saveLogFiles failed: unknown result")

    def getDurationByProtocol(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        self.send_getDurationByProtocol(protocolHandle)
        return self.recv_getDurationByProtocol()

    def send_getDurationByProtocol(self, protocolHandle):
        self._oprot.writeMessageBegin('getDurationByProtocol', TMessageType.CALL, self._seqid)
        args = getDurationByProtocol_args()
        args.protocolHandle = protocolHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDurationByProtocol(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDurationByProtocol_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDurationByProtocol failed: unknown result")

    def updatePacketFilters(self, viewName, filter, updateType):
        """
        Parameters:
         - viewName
         - filter
         - updateType

        """
        self.send_updatePacketFilters(viewName, filter, updateType)
        return self.recv_updatePacketFilters()

    def send_updatePacketFilters(self, viewName, filter, updateType):
        self._oprot.writeMessageBegin('updatePacketFilters', TMessageType.CALL, self._seqid)
        args = updatePacketFilters_args()
        args.viewName = viewName
        args.filter = filter
        args.updateType = updateType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updatePacketFilters(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updatePacketFilters_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updatePacketFilters failed: unknown result")

    def updatePacketReturnConfig(self, viewName, returnConfig):
        """
        Parameters:
         - viewName
         - returnConfig

        """
        self.send_updatePacketReturnConfig(viewName, returnConfig)
        return self.recv_updatePacketReturnConfig()

    def send_updatePacketReturnConfig(self, viewName, returnConfig):
        self._oprot.writeMessageBegin('updatePacketReturnConfig', TMessageType.CALL, self._seqid)
        args = updatePacketReturnConfig_args()
        args.viewName = viewName
        args.returnConfig = returnConfig
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updatePacketReturnConfig(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updatePacketReturnConfig_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updatePacketReturnConfig failed: unknown result")

    def getAvailablePacketIds(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        self.send_getAvailablePacketIds(protocolHandle)
        return self.recv_getAvailablePacketIds()

    def send_getAvailablePacketIds(self, protocolHandle):
        self._oprot.writeMessageBegin('getAvailablePacketIds', TMessageType.CALL, self._seqid)
        args = getAvailablePacketIds_args()
        args.protocolHandle = protocolHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAvailablePacketIds(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAvailablePacketIds_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAvailablePacketIds failed: unknown result")

    def getLogSessionInformation(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        self.send_getLogSessionInformation(protocolHandle)
        return self.recv_getLogSessionInformation()

    def send_getLogSessionInformation(self, protocolHandle):
        self._oprot.writeMessageBegin('getLogSessionInformation', TMessageType.CALL, self._seqid)
        args = getLogSessionInformation_args()
        args.protocolHandle = protocolHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getLogSessionInformation(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getLogSessionInformation_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getLogSessionInformation failed: unknown result")

    def loadQShrinkFile(self, protocolHandle, pathName):
        """
        Parameters:
         - protocolHandle
         - pathName

        """
        self.send_loadQShrinkFile(protocolHandle, pathName)
        self.recv_loadQShrinkFile()

    def send_loadQShrinkFile(self, protocolHandle, pathName):
        self._oprot.writeMessageBegin('loadQShrinkFile', TMessageType.CALL, self._seqid)
        args = loadQShrinkFile_args()
        args.protocolHandle = protocolHandle
        args.pathName = pathName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_loadQShrinkFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = loadQShrinkFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def getDataViewItemIndex(self, viewName, sessionIndex):
        """
        Parameters:
         - viewName
         - sessionIndex

        """
        self.send_getDataViewItemIndex(viewName, sessionIndex)
        return self.recv_getDataViewItemIndex()

    def send_getDataViewItemIndex(self, viewName, sessionIndex):
        self._oprot.writeMessageBegin('getDataViewItemIndex', TMessageType.CALL, self._seqid)
        args = getDataViewItemIndex_args()
        args.viewName = viewName
        args.sessionIndex = sessionIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDataViewItemIndex(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDataViewItemIndex_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDataViewItemIndex failed: unknown result")

    def getTimeStampTodAdjustedByDataviewIndexForAnnotations(self, viewName, dataviewIndex):
        """
        Parameters:
         - viewName
         - dataviewIndex

        """
        self.send_getTimeStampTodAdjustedByDataviewIndexForAnnotations(viewName, dataviewIndex)
        return self.recv_getTimeStampTodAdjustedByDataviewIndexForAnnotations()

    def send_getTimeStampTodAdjustedByDataviewIndexForAnnotations(self, viewName, dataviewIndex):
        self._oprot.writeMessageBegin('getTimeStampTodAdjustedByDataviewIndexForAnnotations', TMessageType.CALL, self._seqid)
        args = getTimeStampTodAdjustedByDataviewIndexForAnnotations_args()
        args.viewName = viewName
        args.dataviewIndex = dataviewIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTimeStampTodAdjustedByDataviewIndexForAnnotations(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTimeStampTodAdjustedByDataviewIndexForAnnotations_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getTimeStampTodAdjustedByDataviewIndexForAnnotations failed: unknown result")

    def getDataViewItemsForConfiguration(self, viewName, packets, returnConfig):
        """
        Parameters:
         - viewName
         - packets
         - returnConfig

        """
        self.send_getDataViewItemsForConfiguration(viewName, packets, returnConfig)
        return self.recv_getDataViewItemsForConfiguration()

    def send_getDataViewItemsForConfiguration(self, viewName, packets, returnConfig):
        self._oprot.writeMessageBegin('getDataViewItemsForConfiguration', TMessageType.CALL, self._seqid)
        args = getDataViewItemsForConfiguration_args()
        args.viewName = viewName
        args.packets = packets
        args.returnConfig = returnConfig
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDataViewItemsForConfiguration(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDataViewItemsForConfiguration_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDataViewItemsForConfiguration failed: unknown result")

    def getClientSessionInfo(self):
        self.send_getClientSessionInfo()
        return self.recv_getClientSessionInfo()

    def send_getClientSessionInfo(self):
        self._oprot.writeMessageBegin('getClientSessionInfo', TMessageType.CALL, self._seqid)
        args = getClientSessionInfo_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getClientSessionInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getClientSessionInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getClientSessionInfo failed: unknown result")

    def createSubDataView(self, viewName, parentViewName, filter, packets, returnConfig):
        """
        Parameters:
         - viewName
         - parentViewName
         - filter
         - packets
         - returnConfig

        """
        self.send_createSubDataView(viewName, parentViewName, filter, packets, returnConfig)
        return self.recv_createSubDataView()

    def send_createSubDataView(self, viewName, parentViewName, filter, packets, returnConfig):
        self._oprot.writeMessageBegin('createSubDataView', TMessageType.CALL, self._seqid)
        args = createSubDataView_args()
        args.viewName = viewName
        args.parentViewName = parentViewName
        args.filter = filter
        args.packets = packets
        args.returnConfig = returnConfig
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createSubDataView(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createSubDataView_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createSubDataView failed: unknown result")

    def setWcdmaProtocolRevision(self, protocolHandle, revision):
        """
        Parameters:
         - protocolHandle
         - revision

        """
        self.send_setWcdmaProtocolRevision(protocolHandle, revision)
        return self.recv_setWcdmaProtocolRevision()

    def send_setWcdmaProtocolRevision(self, protocolHandle, revision):
        self._oprot.writeMessageBegin('setWcdmaProtocolRevision', TMessageType.CALL, self._seqid)
        args = setWcdmaProtocolRevision_args()
        args.protocolHandle = protocolHandle
        args.revision = revision
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setWcdmaProtocolRevision(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setWcdmaProtocolRevision_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "setWcdmaProtocolRevision failed: unknown result")

    def setCdmaProtocolRevision(self, protocolHandle, revision):
        """
        Parameters:
         - protocolHandle
         - revision

        """
        self.send_setCdmaProtocolRevision(protocolHandle, revision)
        return self.recv_setCdmaProtocolRevision()

    def send_setCdmaProtocolRevision(self, protocolHandle, revision):
        self._oprot.writeMessageBegin('setCdmaProtocolRevision', TMessageType.CALL, self._seqid)
        args = setCdmaProtocolRevision_args()
        args.protocolHandle = protocolHandle
        args.revision = revision
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setCdmaProtocolRevision(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setCdmaProtocolRevision_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "setCdmaProtocolRevision failed: unknown result")

    def setPilotInc(self, protocolHandle, pilotInc):
        """
        Parameters:
         - protocolHandle
         - pilotInc

        """
        self.send_setPilotInc(protocolHandle, pilotInc)
        return self.recv_setPilotInc()

    def send_setPilotInc(self, protocolHandle, pilotInc):
        self._oprot.writeMessageBegin('setPilotInc', TMessageType.CALL, self._seqid)
        args = setPilotInc_args()
        args.protocolHandle = protocolHandle
        args.pilotInc = pilotInc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setPilotInc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setPilotInc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "setPilotInc failed: unknown result")

    def getBandClass(self, protocolHandle, protocolIndex):
        """
        Parameters:
         - protocolHandle
         - protocolIndex

        """
        self.send_getBandClass(protocolHandle, protocolIndex)
        return self.recv_getBandClass()

    def send_getBandClass(self, protocolHandle, protocolIndex):
        self._oprot.writeMessageBegin('getBandClass', TMessageType.CALL, self._seqid)
        args = getBandClass_args()
        args.protocolHandle = protocolHandle
        args.protocolIndex = protocolIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getBandClass(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getBandClass_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getBandClass failed: unknown result")

    def getCdmaProtocolRevision(self, protocolHandle, protocolIndex):
        """
        Parameters:
         - protocolHandle
         - protocolIndex

        """
        self.send_getCdmaProtocolRevision(protocolHandle, protocolIndex)
        return self.recv_getCdmaProtocolRevision()

    def send_getCdmaProtocolRevision(self, protocolHandle, protocolIndex):
        self._oprot.writeMessageBegin('getCdmaProtocolRevision', TMessageType.CALL, self._seqid)
        args = getCdmaProtocolRevision_args()
        args.protocolHandle = protocolHandle
        args.protocolIndex = protocolIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCdmaProtocolRevision(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCdmaProtocolRevision_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCdmaProtocolRevision failed: unknown result")

    def getModel(self, protocolHandle, protocolIndex):
        """
        Parameters:
         - protocolHandle
         - protocolIndex

        """
        self.send_getModel(protocolHandle, protocolIndex)
        return self.recv_getModel()

    def send_getModel(self, protocolHandle, protocolIndex):
        self._oprot.writeMessageBegin('getModel', TMessageType.CALL, self._seqid)
        args = getModel_args()
        args.protocolHandle = protocolHandle
        args.protocolIndex = protocolIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getModel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getModel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getModel failed: unknown result")

    def getWcdmaProtocolRevision(self, protocolHandle, protocolIndex):
        """
        Parameters:
         - protocolHandle
         - protocolIndex

        """
        self.send_getWcdmaProtocolRevision(protocolHandle, protocolIndex)
        return self.recv_getWcdmaProtocolRevision()

    def send_getWcdmaProtocolRevision(self, protocolHandle, protocolIndex):
        self._oprot.writeMessageBegin('getWcdmaProtocolRevision', TMessageType.CALL, self._seqid)
        args = getWcdmaProtocolRevision_args()
        args.protocolHandle = protocolHandle
        args.protocolIndex = protocolIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getWcdmaProtocolRevision(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getWcdmaProtocolRevision_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getWcdmaProtocolRevision failed: unknown result")

    def getDecryptionKeyStatus(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        self.send_getDecryptionKeyStatus(protocolHandle)
        return self.recv_getDecryptionKeyStatus()

    def send_getDecryptionKeyStatus(self, protocolHandle):
        self._oprot.writeMessageBegin('getDecryptionKeyStatus', TMessageType.CALL, self._seqid)
        args = getDecryptionKeyStatus_args()
        args.protocolHandle = protocolHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDecryptionKeyStatus(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDecryptionKeyStatus_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDecryptionKeyStatus failed: unknown result")

    def saveMbnToFolder(self, protocolHandle, filePath):
        """
        Parameters:
         - protocolHandle
         - filePath

        """
        self.send_saveMbnToFolder(protocolHandle, filePath)
        self.recv_saveMbnToFolder()

    def send_saveMbnToFolder(self, protocolHandle, filePath):
        self._oprot.writeMessageBegin('saveMbnToFolder', TMessageType.CALL, self._seqid)
        args = saveMbnToFolder_args()
        args.protocolHandle = protocolHandle
        args.filePath = filePath
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_saveMbnToFolder(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = saveMbnToFolder_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def getDecryptionFailureCount(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        self.send_getDecryptionFailureCount(protocolHandle)
        return self.recv_getDecryptionFailureCount()

    def send_getDecryptionFailureCount(self, protocolHandle):
        self._oprot.writeMessageBegin('getDecryptionFailureCount', TMessageType.CALL, self._seqid)
        args = getDecryptionFailureCount_args()
        args.protocolHandle = protocolHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDecryptionFailureCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDecryptionFailureCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDecryptionFailureCount failed: unknown result")

    def saveDataViewWithOptions(self, saveDataViewSettings):
        """
        Parameters:
         - saveDataViewSettings

        """
        self.send_saveDataViewWithOptions(saveDataViewSettings)
        return self.recv_saveDataViewWithOptions()

    def send_saveDataViewWithOptions(self, saveDataViewSettings):
        self._oprot.writeMessageBegin('saveDataViewWithOptions', TMessageType.CALL, self._seqid)
        args = saveDataViewWithOptions_args()
        args.saveDataViewSettings = saveDataViewSettings
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_saveDataViewWithOptions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = saveDataViewWithOptions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "saveDataViewWithOptions failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["getLastError"] = Processor.process_getLastError
        self._processMap["destroyLogSession"] = Processor.process_destroyLogSession
        self._processMap["getDeviceList"] = Processor.process_getDeviceList
        self._processMap["getProtocolList"] = Processor.process_getProtocolList
        self._processMap["getDataPacketCount"] = Processor.process_getDataPacketCount
        self._processMap["createDataView"] = Processor.process_createDataView
        self._processMap["createDefaultDataView"] = Processor.process_createDefaultDataView
        self._processMap["createDataViewSet"] = Processor.process_createDataViewSet
        self._processMap["removeDataView"] = Processor.process_removeDataView
        self._processMap["getDataViewItemCount"] = Processor.process_getDataViewItemCount
        self._processMap["getDataViewItems"] = Processor.process_getDataViewItems
        self._processMap["saveDataViewItemsByIndex"] = Processor.process_saveDataViewItemsByIndex
        self._processMap["saveDataViewItemsByIndexWithFilenames"] = Processor.process_saveDataViewItemsByIndexWithFilenames
        self._processMap["saveLogFiles"] = Processor.process_saveLogFiles
        self._processMap["getDurationByProtocol"] = Processor.process_getDurationByProtocol
        self._processMap["updatePacketFilters"] = Processor.process_updatePacketFilters
        self._processMap["updatePacketReturnConfig"] = Processor.process_updatePacketReturnConfig
        self._processMap["getAvailablePacketIds"] = Processor.process_getAvailablePacketIds
        self._processMap["getLogSessionInformation"] = Processor.process_getLogSessionInformation
        self._processMap["loadQShrinkFile"] = Processor.process_loadQShrinkFile
        self._processMap["getDataViewItemIndex"] = Processor.process_getDataViewItemIndex
        self._processMap["getTimeStampTodAdjustedByDataviewIndexForAnnotations"] = Processor.process_getTimeStampTodAdjustedByDataviewIndexForAnnotations
        self._processMap["getDataViewItemsForConfiguration"] = Processor.process_getDataViewItemsForConfiguration
        self._processMap["getClientSessionInfo"] = Processor.process_getClientSessionInfo
        self._processMap["createSubDataView"] = Processor.process_createSubDataView
        self._processMap["setWcdmaProtocolRevision"] = Processor.process_setWcdmaProtocolRevision
        self._processMap["setCdmaProtocolRevision"] = Processor.process_setCdmaProtocolRevision
        self._processMap["setPilotInc"] = Processor.process_setPilotInc
        self._processMap["getBandClass"] = Processor.process_getBandClass
        self._processMap["getCdmaProtocolRevision"] = Processor.process_getCdmaProtocolRevision
        self._processMap["getModel"] = Processor.process_getModel
        self._processMap["getWcdmaProtocolRevision"] = Processor.process_getWcdmaProtocolRevision
        self._processMap["getDecryptionKeyStatus"] = Processor.process_getDecryptionKeyStatus
        self._processMap["saveMbnToFolder"] = Processor.process_saveMbnToFolder
        self._processMap["getDecryptionFailureCount"] = Processor.process_getDecryptionFailureCount
        self._processMap["saveDataViewWithOptions"] = Processor.process_saveDataViewWithOptions
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_getLastError(self, seqid, iprot, oprot):
        args = getLastError_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getLastError_result()
        try:
            result.success = self._handler.getLastError()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getLastError", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_destroyLogSession(self, seqid, iprot, oprot):
        args = destroyLogSession_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = destroyLogSession_result()
        try:
            result.success = self._handler.destroyLogSession()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("destroyLogSession", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDeviceList(self, seqid, iprot, oprot):
        args = getDeviceList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDeviceList_result()
        try:
            result.success = self._handler.getDeviceList()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDeviceList", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getProtocolList(self, seqid, iprot, oprot):
        args = getProtocolList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getProtocolList_result()
        try:
            result.success = self._handler.getProtocolList(args.deviceHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getProtocolList", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDataPacketCount(self, seqid, iprot, oprot):
        args = getDataPacketCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDataPacketCount_result()
        try:
            result.success = self._handler.getDataPacketCount(args.protocolHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDataPacketCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createDataView(self, seqid, iprot, oprot):
        args = createDataView_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createDataView_result()
        try:
            result.success = self._handler.createDataView(args.viewName, args.filter, args.returnConfig)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createDataView", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createDefaultDataView(self, seqid, iprot, oprot):
        args = createDefaultDataView_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createDefaultDataView_result()
        try:
            result.success = self._handler.createDefaultDataView(args.viewName, args.protocolHandleList, args.returnConfig)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createDefaultDataView", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createDataViewSet(self, seqid, iprot, oprot):
        args = createDataViewSet_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createDataViewSet_result()
        try:
            result.success = self._handler.createDataViewSet(args.dataViewDefinitions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createDataViewSet", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeDataView(self, seqid, iprot, oprot):
        args = removeDataView_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeDataView_result()
        try:
            result.success = self._handler.removeDataView(args.viewName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeDataView", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDataViewItemCount(self, seqid, iprot, oprot):
        args = getDataViewItemCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDataViewItemCount_result()
        try:
            result.success = self._handler.getDataViewItemCount(args.viewName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDataViewItemCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDataViewItems(self, seqid, iprot, oprot):
        args = getDataViewItems_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDataViewItems_result()
        try:
            result.success = self._handler.getDataViewItems(args.viewName, args.packets)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDataViewItems", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_saveDataViewItemsByIndex(self, seqid, iprot, oprot):
        args = saveDataViewItemsByIndex_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = saveDataViewItemsByIndex_result()
        try:
            result.success = self._handler.saveDataViewItemsByIndex(args.viewName, args.destinationFolder, args.dataViewIndexes)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("saveDataViewItemsByIndex", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_saveDataViewItemsByIndexWithFilenames(self, seqid, iprot, oprot):
        args = saveDataViewItemsByIndexWithFilenames_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = saveDataViewItemsByIndexWithFilenames_result()
        try:
            result.success = self._handler.saveDataViewItemsByIndexWithFilenames(args.viewName, args.dataViewIndexes, args.logNamesByHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("saveDataViewItemsByIndexWithFilenames", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_saveLogFiles(self, seqid, iprot, oprot):
        args = saveLogFiles_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = saveLogFiles_result()
        try:
            result.success = self._handler.saveLogFiles(args.saveFolder)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("saveLogFiles", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDurationByProtocol(self, seqid, iprot, oprot):
        args = getDurationByProtocol_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDurationByProtocol_result()
        try:
            result.success = self._handler.getDurationByProtocol(args.protocolHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDurationByProtocol", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updatePacketFilters(self, seqid, iprot, oprot):
        args = updatePacketFilters_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updatePacketFilters_result()
        try:
            result.success = self._handler.updatePacketFilters(args.viewName, args.filter, args.updateType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updatePacketFilters", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updatePacketReturnConfig(self, seqid, iprot, oprot):
        args = updatePacketReturnConfig_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updatePacketReturnConfig_result()
        try:
            result.success = self._handler.updatePacketReturnConfig(args.viewName, args.returnConfig)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updatePacketReturnConfig", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAvailablePacketIds(self, seqid, iprot, oprot):
        args = getAvailablePacketIds_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAvailablePacketIds_result()
        try:
            result.success = self._handler.getAvailablePacketIds(args.protocolHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAvailablePacketIds", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getLogSessionInformation(self, seqid, iprot, oprot):
        args = getLogSessionInformation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getLogSessionInformation_result()
        try:
            result.success = self._handler.getLogSessionInformation(args.protocolHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getLogSessionInformation", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_loadQShrinkFile(self, seqid, iprot, oprot):
        args = loadQShrinkFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = loadQShrinkFile_result()
        try:
            self._handler.loadQShrinkFile(args.protocolHandle, args.pathName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("loadQShrinkFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDataViewItemIndex(self, seqid, iprot, oprot):
        args = getDataViewItemIndex_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDataViewItemIndex_result()
        try:
            result.success = self._handler.getDataViewItemIndex(args.viewName, args.sessionIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDataViewItemIndex", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTimeStampTodAdjustedByDataviewIndexForAnnotations(self, seqid, iprot, oprot):
        args = getTimeStampTodAdjustedByDataviewIndexForAnnotations_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTimeStampTodAdjustedByDataviewIndexForAnnotations_result()
        try:
            result.success = self._handler.getTimeStampTodAdjustedByDataviewIndexForAnnotations(args.viewName, args.dataviewIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getTimeStampTodAdjustedByDataviewIndexForAnnotations", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDataViewItemsForConfiguration(self, seqid, iprot, oprot):
        args = getDataViewItemsForConfiguration_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDataViewItemsForConfiguration_result()
        try:
            result.success = self._handler.getDataViewItemsForConfiguration(args.viewName, args.packets, args.returnConfig)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDataViewItemsForConfiguration", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getClientSessionInfo(self, seqid, iprot, oprot):
        args = getClientSessionInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getClientSessionInfo_result()
        try:
            result.success = self._handler.getClientSessionInfo()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getClientSessionInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createSubDataView(self, seqid, iprot, oprot):
        args = createSubDataView_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createSubDataView_result()
        try:
            result.success = self._handler.createSubDataView(args.viewName, args.parentViewName, args.filter, args.packets, args.returnConfig)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createSubDataView", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setWcdmaProtocolRevision(self, seqid, iprot, oprot):
        args = setWcdmaProtocolRevision_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setWcdmaProtocolRevision_result()
        try:
            result.success = self._handler.setWcdmaProtocolRevision(args.protocolHandle, args.revision)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setWcdmaProtocolRevision", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setCdmaProtocolRevision(self, seqid, iprot, oprot):
        args = setCdmaProtocolRevision_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setCdmaProtocolRevision_result()
        try:
            result.success = self._handler.setCdmaProtocolRevision(args.protocolHandle, args.revision)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setCdmaProtocolRevision", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setPilotInc(self, seqid, iprot, oprot):
        args = setPilotInc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setPilotInc_result()
        try:
            result.success = self._handler.setPilotInc(args.protocolHandle, args.pilotInc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setPilotInc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getBandClass(self, seqid, iprot, oprot):
        args = getBandClass_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getBandClass_result()
        try:
            result.success = self._handler.getBandClass(args.protocolHandle, args.protocolIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getBandClass", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCdmaProtocolRevision(self, seqid, iprot, oprot):
        args = getCdmaProtocolRevision_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCdmaProtocolRevision_result()
        try:
            result.success = self._handler.getCdmaProtocolRevision(args.protocolHandle, args.protocolIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCdmaProtocolRevision", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getModel(self, seqid, iprot, oprot):
        args = getModel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getModel_result()
        try:
            result.success = self._handler.getModel(args.protocolHandle, args.protocolIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getModel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getWcdmaProtocolRevision(self, seqid, iprot, oprot):
        args = getWcdmaProtocolRevision_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getWcdmaProtocolRevision_result()
        try:
            result.success = self._handler.getWcdmaProtocolRevision(args.protocolHandle, args.protocolIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getWcdmaProtocolRevision", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDecryptionKeyStatus(self, seqid, iprot, oprot):
        args = getDecryptionKeyStatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDecryptionKeyStatus_result()
        try:
            result.success = self._handler.getDecryptionKeyStatus(args.protocolHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDecryptionKeyStatus", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_saveMbnToFolder(self, seqid, iprot, oprot):
        args = saveMbnToFolder_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = saveMbnToFolder_result()
        try:
            self._handler.saveMbnToFolder(args.protocolHandle, args.filePath)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("saveMbnToFolder", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDecryptionFailureCount(self, seqid, iprot, oprot):
        args = getDecryptionFailureCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDecryptionFailureCount_result()
        try:
            result.success = self._handler.getDecryptionFailureCount(args.protocolHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDecryptionFailureCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_saveDataViewWithOptions(self, seqid, iprot, oprot):
        args = saveDataViewWithOptions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = saveDataViewWithOptions_result()
        try:
            result.success = self._handler.saveDataViewWithOptions(args.saveDataViewSettings)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("saveDataViewWithOptions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class getLastError_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLastError_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLastError_args)
getLastError_args.thrift_spec = (
)


class getLastError_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Common.ttypes.ErrorType()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLastError_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLastError_result)
getLastError_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Common.ttypes.ErrorType, None], None, ),  # 0
)


class destroyLogSession_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('destroyLogSession_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(destroyLogSession_args)
destroyLogSession_args.thrift_spec = (
)


class destroyLogSession_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('destroyLogSession_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(destroyLogSession_result)
destroyLogSession_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getDeviceList_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDeviceList_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDeviceList_args)
getDeviceList_args.thrift_spec = (
)


class getDeviceList_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype79, _size76) = iprot.readListBegin()
                    for _i80 in range(_size76):
                        _elem81 = Common.ttypes.DeviceInfo()
                        _elem81.read(iprot)
                        self.success.append(_elem81)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDeviceList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter82 in self.success:
                iter82.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDeviceList_result)
getDeviceList_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Common.ttypes.DeviceInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getProtocolList_args(object):
    """
    Attributes:
     - deviceHandle

    """


    def __init__(self, deviceHandle=None,):
        self.deviceHandle = deviceHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getProtocolList_args')
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 1)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getProtocolList_args)
getProtocolList_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'deviceHandle', None, None, ),  # 1
)


class getProtocolList_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype86, _size83) = iprot.readListBegin()
                    for _i87 in range(_size83):
                        _elem88 = Common.ttypes.ProtocolInfo()
                        _elem88.read(iprot)
                        self.success.append(_elem88)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getProtocolList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter89 in self.success:
                iter89.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getProtocolList_result)
getProtocolList_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Common.ttypes.ProtocolInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getDataPacketCount_args(object):
    """
    Attributes:
     - protocolHandle

    """


    def __init__(self, protocolHandle=None,):
        self.protocolHandle = protocolHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDataPacketCount_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDataPacketCount_args)
getDataPacketCount_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
)


class getDataPacketCount_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDataPacketCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDataPacketCount_result)
getDataPacketCount_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class createDataView_args(object):
    """
    Attributes:
     - viewName
     - filter
     - returnConfig

    """


    def __init__(self, viewName=None, filter=None, returnConfig=None,):
        self.viewName = viewName
        self.filter = filter
        self.returnConfig = returnConfig

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.viewName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.filter = DataPacketFilter()
                    self.filter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.returnConfig = PacketReturnConfig()
                    self.returnConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createDataView_args')
        if self.viewName is not None:
            oprot.writeFieldBegin('viewName', TType.STRING, 1)
            oprot.writeString(self.viewName.encode('utf-8') if sys.version_info[0] == 2 else self.viewName)
            oprot.writeFieldEnd()
        if self.filter is not None:
            oprot.writeFieldBegin('filter', TType.STRUCT, 2)
            self.filter.write(oprot)
            oprot.writeFieldEnd()
        if self.returnConfig is not None:
            oprot.writeFieldBegin('returnConfig', TType.STRUCT, 3)
            self.returnConfig.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createDataView_args)
createDataView_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'viewName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'filter', [DataPacketFilter, None], None, ),  # 2
    (3, TType.STRUCT, 'returnConfig', [PacketReturnConfig, None], None, ),  # 3
)


class createDataView_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createDataView_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createDataView_result)
createDataView_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class createDefaultDataView_args(object):
    """
    Attributes:
     - viewName
     - protocolHandleList
     - returnConfig

    """


    def __init__(self, viewName=None, protocolHandleList=None, returnConfig=None,):
        self.viewName = viewName
        self.protocolHandleList = protocolHandleList
        self.returnConfig = returnConfig

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.viewName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.protocolHandleList = []
                    (_etype93, _size90) = iprot.readListBegin()
                    for _i94 in range(_size90):
                        _elem95 = iprot.readI64()
                        self.protocolHandleList.append(_elem95)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.returnConfig = PacketReturnConfig()
                    self.returnConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createDefaultDataView_args')
        if self.viewName is not None:
            oprot.writeFieldBegin('viewName', TType.STRING, 1)
            oprot.writeString(self.viewName.encode('utf-8') if sys.version_info[0] == 2 else self.viewName)
            oprot.writeFieldEnd()
        if self.protocolHandleList is not None:
            oprot.writeFieldBegin('protocolHandleList', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.protocolHandleList))
            for iter96 in self.protocolHandleList:
                oprot.writeI64(iter96)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.returnConfig is not None:
            oprot.writeFieldBegin('returnConfig', TType.STRUCT, 3)
            self.returnConfig.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createDefaultDataView_args)
createDefaultDataView_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'viewName', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'protocolHandleList', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRUCT, 'returnConfig', [PacketReturnConfig, None], None, ),  # 3
)


class createDefaultDataView_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createDefaultDataView_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createDefaultDataView_result)
createDefaultDataView_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class createDataViewSet_args(object):
    """
    Attributes:
     - dataViewDefinitions

    """


    def __init__(self, dataViewDefinitions=None,):
        self.dataViewDefinitions = dataViewDefinitions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.dataViewDefinitions = []
                    (_etype100, _size97) = iprot.readListBegin()
                    for _i101 in range(_size97):
                        _elem102 = DataViewInfo()
                        _elem102.read(iprot)
                        self.dataViewDefinitions.append(_elem102)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createDataViewSet_args')
        if self.dataViewDefinitions is not None:
            oprot.writeFieldBegin('dataViewDefinitions', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.dataViewDefinitions))
            for iter103 in self.dataViewDefinitions:
                iter103.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createDataViewSet_args)
createDataViewSet_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'dataViewDefinitions', (TType.STRUCT, [DataViewInfo, None], False), None, ),  # 1
)


class createDataViewSet_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createDataViewSet_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createDataViewSet_result)
createDataViewSet_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class removeDataView_args(object):
    """
    Attributes:
     - viewName

    """


    def __init__(self, viewName=None,):
        self.viewName = viewName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.viewName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeDataView_args')
        if self.viewName is not None:
            oprot.writeFieldBegin('viewName', TType.STRING, 1)
            oprot.writeString(self.viewName.encode('utf-8') if sys.version_info[0] == 2 else self.viewName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeDataView_args)
removeDataView_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'viewName', 'UTF8', None, ),  # 1
)


class removeDataView_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeDataView_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeDataView_result)
removeDataView_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getDataViewItemCount_args(object):
    """
    Attributes:
     - viewName

    """


    def __init__(self, viewName=None,):
        self.viewName = viewName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.viewName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDataViewItemCount_args')
        if self.viewName is not None:
            oprot.writeFieldBegin('viewName', TType.STRING, 1)
            oprot.writeString(self.viewName.encode('utf-8') if sys.version_info[0] == 2 else self.viewName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDataViewItemCount_args)
getDataViewItemCount_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'viewName', 'UTF8', None, ),  # 1
)


class getDataViewItemCount_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDataViewItemCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDataViewItemCount_result)
getDataViewItemCount_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getDataViewItems_args(object):
    """
    Attributes:
     - viewName
     - packets

    """


    def __init__(self, viewName=None, packets=None,):
        self.viewName = viewName
        self.packets = packets

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.viewName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.packets = PacketRange()
                    self.packets.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDataViewItems_args')
        if self.viewName is not None:
            oprot.writeFieldBegin('viewName', TType.STRING, 1)
            oprot.writeString(self.viewName.encode('utf-8') if sys.version_info[0] == 2 else self.viewName)
            oprot.writeFieldEnd()
        if self.packets is not None:
            oprot.writeFieldBegin('packets', TType.STRUCT, 2)
            self.packets.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDataViewItems_args)
getDataViewItems_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'viewName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'packets', [PacketRange, None], None, ),  # 2
)


class getDataViewItems_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype107, _size104) = iprot.readListBegin()
                    for _i108 in range(_size104):
                        _elem109 = DataPacket()
                        _elem109.read(iprot)
                        self.success.append(_elem109)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDataViewItems_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter110 in self.success:
                iter110.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDataViewItems_result)
getDataViewItems_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [DataPacket, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class saveDataViewItemsByIndex_args(object):
    """
    Attributes:
     - viewName
     - destinationFolder
     - dataViewIndexes

    """


    def __init__(self, viewName=None, destinationFolder=None, dataViewIndexes=None,):
        self.viewName = viewName
        self.destinationFolder = destinationFolder
        self.dataViewIndexes = dataViewIndexes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.viewName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.destinationFolder = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.dataViewIndexes = []
                    (_etype114, _size111) = iprot.readListBegin()
                    for _i115 in range(_size111):
                        _elem116 = iprot.readI64()
                        self.dataViewIndexes.append(_elem116)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('saveDataViewItemsByIndex_args')
        if self.viewName is not None:
            oprot.writeFieldBegin('viewName', TType.STRING, 1)
            oprot.writeString(self.viewName.encode('utf-8') if sys.version_info[0] == 2 else self.viewName)
            oprot.writeFieldEnd()
        if self.destinationFolder is not None:
            oprot.writeFieldBegin('destinationFolder', TType.STRING, 2)
            oprot.writeString(self.destinationFolder.encode('utf-8') if sys.version_info[0] == 2 else self.destinationFolder)
            oprot.writeFieldEnd()
        if self.dataViewIndexes is not None:
            oprot.writeFieldBegin('dataViewIndexes', TType.LIST, 3)
            oprot.writeListBegin(TType.I64, len(self.dataViewIndexes))
            for iter117 in self.dataViewIndexes:
                oprot.writeI64(iter117)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(saveDataViewItemsByIndex_args)
saveDataViewItemsByIndex_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'viewName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'destinationFolder', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'dataViewIndexes', (TType.I64, None, False), None, ),  # 3
)


class saveDataViewItemsByIndex_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('saveDataViewItemsByIndex_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(saveDataViewItemsByIndex_result)
saveDataViewItemsByIndex_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class saveDataViewItemsByIndexWithFilenames_args(object):
    """
    Attributes:
     - viewName
     - dataViewIndexes
     - logNamesByHandle

    """


    def __init__(self, viewName=None, dataViewIndexes=None, logNamesByHandle=None,):
        self.viewName = viewName
        self.dataViewIndexes = dataViewIndexes
        self.logNamesByHandle = logNamesByHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.viewName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.dataViewIndexes = []
                    (_etype121, _size118) = iprot.readListBegin()
                    for _i122 in range(_size118):
                        _elem123 = iprot.readI64()
                        self.dataViewIndexes.append(_elem123)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.logNamesByHandle = {}
                    (_ktype125, _vtype126, _size124) = iprot.readMapBegin()
                    for _i128 in range(_size124):
                        _key129 = iprot.readI64()
                        _val130 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.logNamesByHandle[_key129] = _val130
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('saveDataViewItemsByIndexWithFilenames_args')
        if self.viewName is not None:
            oprot.writeFieldBegin('viewName', TType.STRING, 1)
            oprot.writeString(self.viewName.encode('utf-8') if sys.version_info[0] == 2 else self.viewName)
            oprot.writeFieldEnd()
        if self.dataViewIndexes is not None:
            oprot.writeFieldBegin('dataViewIndexes', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.dataViewIndexes))
            for iter131 in self.dataViewIndexes:
                oprot.writeI64(iter131)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.logNamesByHandle is not None:
            oprot.writeFieldBegin('logNamesByHandle', TType.MAP, 3)
            oprot.writeMapBegin(TType.I64, TType.STRING, len(self.logNamesByHandle))
            for kiter132, viter133 in self.logNamesByHandle.items():
                oprot.writeI64(kiter132)
                oprot.writeString(viter133.encode('utf-8') if sys.version_info[0] == 2 else viter133)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(saveDataViewItemsByIndexWithFilenames_args)
saveDataViewItemsByIndexWithFilenames_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'viewName', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'dataViewIndexes', (TType.I64, None, False), None, ),  # 2
    (3, TType.MAP, 'logNamesByHandle', (TType.I64, None, TType.STRING, 'UTF8', False), None, ),  # 3
)


class saveDataViewItemsByIndexWithFilenames_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('saveDataViewItemsByIndexWithFilenames_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(saveDataViewItemsByIndexWithFilenames_result)
saveDataViewItemsByIndexWithFilenames_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class saveLogFiles_args(object):
    """
    Attributes:
     - saveFolder

    """


    def __init__(self, saveFolder=None,):
        self.saveFolder = saveFolder

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.saveFolder = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('saveLogFiles_args')
        if self.saveFolder is not None:
            oprot.writeFieldBegin('saveFolder', TType.STRING, 1)
            oprot.writeString(self.saveFolder.encode('utf-8') if sys.version_info[0] == 2 else self.saveFolder)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(saveLogFiles_args)
saveLogFiles_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'saveFolder', 'UTF8', None, ),  # 1
)


class saveLogFiles_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype137, _size134) = iprot.readListBegin()
                    for _i138 in range(_size134):
                        _elem139 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem139)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('saveLogFiles_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter140 in self.success:
                oprot.writeString(iter140.encode('utf-8') if sys.version_info[0] == 2 else iter140)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(saveLogFiles_result)
saveLogFiles_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getDurationByProtocol_args(object):
    """
    Attributes:
     - protocolHandle

    """


    def __init__(self, protocolHandle=None,):
        self.protocolHandle = protocolHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDurationByProtocol_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDurationByProtocol_args)
getDurationByProtocol_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
)


class getDurationByProtocol_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDurationByProtocol_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDurationByProtocol_result)
getDurationByProtocol_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class updatePacketFilters_args(object):
    """
    Attributes:
     - viewName
     - filter
     - updateType

    """


    def __init__(self, viewName=None, filter=None, updateType=None,):
        self.viewName = viewName
        self.filter = filter
        self.updateType = updateType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.viewName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.filter = DataPacketFilter()
                    self.filter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.updateType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updatePacketFilters_args')
        if self.viewName is not None:
            oprot.writeFieldBegin('viewName', TType.STRING, 1)
            oprot.writeString(self.viewName.encode('utf-8') if sys.version_info[0] == 2 else self.viewName)
            oprot.writeFieldEnd()
        if self.filter is not None:
            oprot.writeFieldBegin('filter', TType.STRUCT, 2)
            self.filter.write(oprot)
            oprot.writeFieldEnd()
        if self.updateType is not None:
            oprot.writeFieldBegin('updateType', TType.I32, 3)
            oprot.writeI32(self.updateType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updatePacketFilters_args)
updatePacketFilters_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'viewName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'filter', [DataPacketFilter, None], None, ),  # 2
    (3, TType.I32, 'updateType', None, None, ),  # 3
)


class updatePacketFilters_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updatePacketFilters_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updatePacketFilters_result)
updatePacketFilters_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class updatePacketReturnConfig_args(object):
    """
    Attributes:
     - viewName
     - returnConfig

    """


    def __init__(self, viewName=None, returnConfig=None,):
        self.viewName = viewName
        self.returnConfig = returnConfig

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.viewName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.returnConfig = PacketReturnConfig()
                    self.returnConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updatePacketReturnConfig_args')
        if self.viewName is not None:
            oprot.writeFieldBegin('viewName', TType.STRING, 1)
            oprot.writeString(self.viewName.encode('utf-8') if sys.version_info[0] == 2 else self.viewName)
            oprot.writeFieldEnd()
        if self.returnConfig is not None:
            oprot.writeFieldBegin('returnConfig', TType.STRUCT, 2)
            self.returnConfig.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updatePacketReturnConfig_args)
updatePacketReturnConfig_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'viewName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'returnConfig', [PacketReturnConfig, None], None, ),  # 2
)


class updatePacketReturnConfig_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updatePacketReturnConfig_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updatePacketReturnConfig_result)
updatePacketReturnConfig_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getAvailablePacketIds_args(object):
    """
    Attributes:
     - protocolHandle

    """


    def __init__(self, protocolHandle=None,):
        self.protocolHandle = protocolHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAvailablePacketIds_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAvailablePacketIds_args)
getAvailablePacketIds_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
)


class getAvailablePacketIds_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = DataPacketFilter()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAvailablePacketIds_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAvailablePacketIds_result)
getAvailablePacketIds_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [DataPacketFilter, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getLogSessionInformation_args(object):
    """
    Attributes:
     - protocolHandle

    """


    def __init__(self, protocolHandle=None,):
        self.protocolHandle = protocolHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.SET:
                    self.protocolHandle = set()
                    (_etype144, _size141) = iprot.readSetBegin()
                    for _i145 in range(_size141):
                        _elem146 = iprot.readI64()
                        self.protocolHandle.add(_elem146)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLogSessionInformation_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.SET, 1)
            oprot.writeSetBegin(TType.I64, len(self.protocolHandle))
            for iter147 in self.protocolHandle:
                oprot.writeI64(iter147)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLogSessionInformation_args)
getLogSessionInformation_args.thrift_spec = (
    None,  # 0
    (1, TType.SET, 'protocolHandle', (TType.I64, None, False), None, ),  # 1
)


class getLogSessionInformation_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LogSessionInformation()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLogSessionInformation_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLogSessionInformation_result)
getLogSessionInformation_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [LogSessionInformation, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class loadQShrinkFile_args(object):
    """
    Attributes:
     - protocolHandle
     - pathName

    """


    def __init__(self, protocolHandle=None, pathName=None,):
        self.protocolHandle = protocolHandle
        self.pathName = pathName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('loadQShrinkFile_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.pathName is not None:
            oprot.writeFieldBegin('pathName', TType.STRING, 2)
            oprot.writeString(self.pathName.encode('utf-8') if sys.version_info[0] == 2 else self.pathName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(loadQShrinkFile_args)
loadQShrinkFile_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
    (2, TType.STRING, 'pathName', 'UTF8', None, ),  # 2
)


class loadQShrinkFile_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('loadQShrinkFile_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(loadQShrinkFile_result)
loadQShrinkFile_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getDataViewItemIndex_args(object):
    """
    Attributes:
     - viewName
     - sessionIndex

    """


    def __init__(self, viewName=None, sessionIndex=None,):
        self.viewName = viewName
        self.sessionIndex = sessionIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.viewName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.sessionIndex = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDataViewItemIndex_args')
        if self.viewName is not None:
            oprot.writeFieldBegin('viewName', TType.STRING, 1)
            oprot.writeString(self.viewName.encode('utf-8') if sys.version_info[0] == 2 else self.viewName)
            oprot.writeFieldEnd()
        if self.sessionIndex is not None:
            oprot.writeFieldBegin('sessionIndex', TType.I64, 2)
            oprot.writeI64(self.sessionIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDataViewItemIndex_args)
getDataViewItemIndex_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'viewName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'sessionIndex', None, None, ),  # 2
)


class getDataViewItemIndex_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDataViewItemIndex_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDataViewItemIndex_result)
getDataViewItemIndex_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getTimeStampTodAdjustedByDataviewIndexForAnnotations_args(object):
    """
    Attributes:
     - viewName
     - dataviewIndex

    """


    def __init__(self, viewName=None, dataviewIndex=None,):
        self.viewName = viewName
        self.dataviewIndex = dataviewIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.viewName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.dataviewIndex = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTimeStampTodAdjustedByDataviewIndexForAnnotations_args')
        if self.viewName is not None:
            oprot.writeFieldBegin('viewName', TType.STRING, 1)
            oprot.writeString(self.viewName.encode('utf-8') if sys.version_info[0] == 2 else self.viewName)
            oprot.writeFieldEnd()
        if self.dataviewIndex is not None:
            oprot.writeFieldBegin('dataviewIndex', TType.I64, 2)
            oprot.writeI64(self.dataviewIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTimeStampTodAdjustedByDataviewIndexForAnnotations_args)
getTimeStampTodAdjustedByDataviewIndexForAnnotations_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'viewName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'dataviewIndex', None, None, ),  # 2
)


class getTimeStampTodAdjustedByDataviewIndexForAnnotations_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTimeStampTodAdjustedByDataviewIndexForAnnotations_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTimeStampTodAdjustedByDataviewIndexForAnnotations_result)
getTimeStampTodAdjustedByDataviewIndexForAnnotations_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getDataViewItemsForConfiguration_args(object):
    """
    Attributes:
     - viewName
     - packets
     - returnConfig

    """


    def __init__(self, viewName=None, packets=None, returnConfig=None,):
        self.viewName = viewName
        self.packets = packets
        self.returnConfig = returnConfig

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.viewName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.packets = PacketRange()
                    self.packets.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.returnConfig = PacketReturnConfig()
                    self.returnConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDataViewItemsForConfiguration_args')
        if self.viewName is not None:
            oprot.writeFieldBegin('viewName', TType.STRING, 1)
            oprot.writeString(self.viewName.encode('utf-8') if sys.version_info[0] == 2 else self.viewName)
            oprot.writeFieldEnd()
        if self.packets is not None:
            oprot.writeFieldBegin('packets', TType.STRUCT, 2)
            self.packets.write(oprot)
            oprot.writeFieldEnd()
        if self.returnConfig is not None:
            oprot.writeFieldBegin('returnConfig', TType.STRUCT, 3)
            self.returnConfig.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDataViewItemsForConfiguration_args)
getDataViewItemsForConfiguration_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'viewName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'packets', [PacketRange, None], None, ),  # 2
    (3, TType.STRUCT, 'returnConfig', [PacketReturnConfig, None], None, ),  # 3
)


class getDataViewItemsForConfiguration_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype151, _size148) = iprot.readListBegin()
                    for _i152 in range(_size148):
                        _elem153 = DataPacket()
                        _elem153.read(iprot)
                        self.success.append(_elem153)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDataViewItemsForConfiguration_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter154 in self.success:
                iter154.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDataViewItemsForConfiguration_result)
getDataViewItemsForConfiguration_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [DataPacket, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getClientSessionInfo_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getClientSessionInfo_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getClientSessionInfo_args)
getClientSessionInfo_args.thrift_spec = (
)


class getClientSessionInfo_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ClientSessionInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getClientSessionInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getClientSessionInfo_result)
getClientSessionInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ClientSessionInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class createSubDataView_args(object):
    """
    Attributes:
     - viewName
     - parentViewName
     - filter
     - packets
     - returnConfig

    """


    def __init__(self, viewName=None, parentViewName=None, filter=None, packets=None, returnConfig=None,):
        self.viewName = viewName
        self.parentViewName = parentViewName
        self.filter = filter
        self.packets = packets
        self.returnConfig = returnConfig

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.viewName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.parentViewName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.filter = DataPacketFilter()
                    self.filter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.packets = PacketRange()
                    self.packets.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.returnConfig = PacketReturnConfig()
                    self.returnConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createSubDataView_args')
        if self.viewName is not None:
            oprot.writeFieldBegin('viewName', TType.STRING, 1)
            oprot.writeString(self.viewName.encode('utf-8') if sys.version_info[0] == 2 else self.viewName)
            oprot.writeFieldEnd()
        if self.parentViewName is not None:
            oprot.writeFieldBegin('parentViewName', TType.STRING, 2)
            oprot.writeString(self.parentViewName.encode('utf-8') if sys.version_info[0] == 2 else self.parentViewName)
            oprot.writeFieldEnd()
        if self.filter is not None:
            oprot.writeFieldBegin('filter', TType.STRUCT, 3)
            self.filter.write(oprot)
            oprot.writeFieldEnd()
        if self.packets is not None:
            oprot.writeFieldBegin('packets', TType.STRUCT, 4)
            self.packets.write(oprot)
            oprot.writeFieldEnd()
        if self.returnConfig is not None:
            oprot.writeFieldBegin('returnConfig', TType.STRUCT, 5)
            self.returnConfig.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createSubDataView_args)
createSubDataView_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'viewName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'parentViewName', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'filter', [DataPacketFilter, None], None, ),  # 3
    (4, TType.STRUCT, 'packets', [PacketRange, None], None, ),  # 4
    (5, TType.STRUCT, 'returnConfig', [PacketReturnConfig, None], None, ),  # 5
)


class createSubDataView_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createSubDataView_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createSubDataView_result)
createSubDataView_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class setWcdmaProtocolRevision_args(object):
    """
    Attributes:
     - protocolHandle
     - revision

    """


    def __init__(self, protocolHandle=None, revision=None,):
        self.protocolHandle = protocolHandle
        self.revision = revision

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.revision = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setWcdmaProtocolRevision_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.revision is not None:
            oprot.writeFieldBegin('revision', TType.I32, 2)
            oprot.writeI32(self.revision)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setWcdmaProtocolRevision_args)
setWcdmaProtocolRevision_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
    (2, TType.I32, 'revision', None, None, ),  # 2
)


class setWcdmaProtocolRevision_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setWcdmaProtocolRevision_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setWcdmaProtocolRevision_result)
setWcdmaProtocolRevision_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class setCdmaProtocolRevision_args(object):
    """
    Attributes:
     - protocolHandle
     - revision

    """


    def __init__(self, protocolHandle=None, revision=None,):
        self.protocolHandle = protocolHandle
        self.revision = revision

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.revision = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setCdmaProtocolRevision_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.revision is not None:
            oprot.writeFieldBegin('revision', TType.I32, 2)
            oprot.writeI32(self.revision)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setCdmaProtocolRevision_args)
setCdmaProtocolRevision_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
    (2, TType.I32, 'revision', None, None, ),  # 2
)


class setCdmaProtocolRevision_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setCdmaProtocolRevision_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setCdmaProtocolRevision_result)
setCdmaProtocolRevision_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class setPilotInc_args(object):
    """
    Attributes:
     - protocolHandle
     - pilotInc

    """


    def __init__(self, protocolHandle=None, pilotInc=None,):
        self.protocolHandle = protocolHandle
        self.pilotInc = pilotInc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.pilotInc = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setPilotInc_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.pilotInc is not None:
            oprot.writeFieldBegin('pilotInc', TType.I16, 2)
            oprot.writeI16(self.pilotInc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setPilotInc_args)
setPilotInc_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
    (2, TType.I16, 'pilotInc', None, None, ),  # 2
)


class setPilotInc_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setPilotInc_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setPilotInc_result)
setPilotInc_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getBandClass_args(object):
    """
    Attributes:
     - protocolHandle
     - protocolIndex

    """


    def __init__(self, protocolHandle=None, protocolIndex=None,):
        self.protocolHandle = protocolHandle
        self.protocolIndex = protocolIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.protocolIndex = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getBandClass_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.protocolIndex is not None:
            oprot.writeFieldBegin('protocolIndex', TType.I64, 2)
            oprot.writeI64(self.protocolIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getBandClass_args)
getBandClass_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
    (2, TType.I64, 'protocolIndex', None, None, ),  # 2
)


class getBandClass_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I16:
                    self.success = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getBandClass_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I16, 0)
            oprot.writeI16(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getBandClass_result)
getBandClass_result.thrift_spec = (
    (0, TType.I16, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getCdmaProtocolRevision_args(object):
    """
    Attributes:
     - protocolHandle
     - protocolIndex

    """


    def __init__(self, protocolHandle=None, protocolIndex=None,):
        self.protocolHandle = protocolHandle
        self.protocolIndex = protocolIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.protocolIndex = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCdmaProtocolRevision_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.protocolIndex is not None:
            oprot.writeFieldBegin('protocolIndex', TType.I64, 2)
            oprot.writeI64(self.protocolIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCdmaProtocolRevision_args)
getCdmaProtocolRevision_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
    (2, TType.I64, 'protocolIndex', None, None, ),  # 2
)


class getCdmaProtocolRevision_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCdmaProtocolRevision_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCdmaProtocolRevision_result)
getCdmaProtocolRevision_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getModel_args(object):
    """
    Attributes:
     - protocolHandle
     - protocolIndex

    """


    def __init__(self, protocolHandle=None, protocolIndex=None,):
        self.protocolHandle = protocolHandle
        self.protocolIndex = protocolIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.protocolIndex = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getModel_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.protocolIndex is not None:
            oprot.writeFieldBegin('protocolIndex', TType.I64, 2)
            oprot.writeI64(self.protocolIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getModel_args)
getModel_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
    (2, TType.I64, 'protocolIndex', None, None, ),  # 2
)


class getModel_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I16:
                    self.success = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getModel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I16, 0)
            oprot.writeI16(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getModel_result)
getModel_result.thrift_spec = (
    (0, TType.I16, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getWcdmaProtocolRevision_args(object):
    """
    Attributes:
     - protocolHandle
     - protocolIndex

    """


    def __init__(self, protocolHandle=None, protocolIndex=None,):
        self.protocolHandle = protocolHandle
        self.protocolIndex = protocolIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.protocolIndex = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getWcdmaProtocolRevision_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.protocolIndex is not None:
            oprot.writeFieldBegin('protocolIndex', TType.I64, 2)
            oprot.writeI64(self.protocolIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getWcdmaProtocolRevision_args)
getWcdmaProtocolRevision_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
    (2, TType.I64, 'protocolIndex', None, None, ),  # 2
)


class getWcdmaProtocolRevision_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getWcdmaProtocolRevision_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getWcdmaProtocolRevision_result)
getWcdmaProtocolRevision_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getDecryptionKeyStatus_args(object):
    """
    Attributes:
     - protocolHandle

    """


    def __init__(self, protocolHandle=None,):
        self.protocolHandle = protocolHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDecryptionKeyStatus_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDecryptionKeyStatus_args)
getDecryptionKeyStatus_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
)


class getDecryptionKeyStatus_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype158, _size155) = iprot.readListBegin()
                    for _i159 in range(_size155):
                        _elem160 = Common.ttypes.KeyInfo()
                        _elem160.read(iprot)
                        self.success.append(_elem160)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDecryptionKeyStatus_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter161 in self.success:
                iter161.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDecryptionKeyStatus_result)
getDecryptionKeyStatus_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Common.ttypes.KeyInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class saveMbnToFolder_args(object):
    """
    Attributes:
     - protocolHandle
     - filePath

    """


    def __init__(self, protocolHandle=None, filePath=None,):
        self.protocolHandle = protocolHandle
        self.filePath = filePath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.filePath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('saveMbnToFolder_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.filePath is not None:
            oprot.writeFieldBegin('filePath', TType.STRING, 2)
            oprot.writeString(self.filePath.encode('utf-8') if sys.version_info[0] == 2 else self.filePath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(saveMbnToFolder_args)
saveMbnToFolder_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
    (2, TType.STRING, 'filePath', 'UTF8', None, ),  # 2
)


class saveMbnToFolder_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('saveMbnToFolder_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(saveMbnToFolder_result)
saveMbnToFolder_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getDecryptionFailureCount_args(object):
    """
    Attributes:
     - protocolHandle

    """


    def __init__(self, protocolHandle=None,):
        self.protocolHandle = protocolHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDecryptionFailureCount_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDecryptionFailureCount_args)
getDecryptionFailureCount_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
)


class getDecryptionFailureCount_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDecryptionFailureCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDecryptionFailureCount_result)
getDecryptionFailureCount_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class saveDataViewWithOptions_args(object):
    """
    Attributes:
     - saveDataViewSettings

    """


    def __init__(self, saveDataViewSettings=None,):
        self.saveDataViewSettings = saveDataViewSettings

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.saveDataViewSettings = SaveDataViewSettings()
                    self.saveDataViewSettings.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('saveDataViewWithOptions_args')
        if self.saveDataViewSettings is not None:
            oprot.writeFieldBegin('saveDataViewSettings', TType.STRUCT, 1)
            self.saveDataViewSettings.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(saveDataViewWithOptions_args)
saveDataViewWithOptions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'saveDataViewSettings', [SaveDataViewSettings, None], None, ),  # 1
)


class saveDataViewWithOptions_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('saveDataViewWithOptions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(saveDataViewWithOptions_result)
saveDataViewWithOptions_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs
