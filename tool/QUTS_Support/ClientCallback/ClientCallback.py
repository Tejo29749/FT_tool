#
# Autogenerated by Thrift Compiler (0.14.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def onMessage(self, level, location, title, description):
        """
        Parameters:
         - level
         - location
         - title
         - description

        """
        pass

    def onDeviceConnected(self, deviceInfo):
        """
        Parameters:
         - deviceInfo

        """
        pass

    def onDeviceDisconnected(self, deviceInfo):
        """
        Parameters:
         - deviceInfo

        """
        pass

    def onDeviceModeChange(self, deviceHandle, newMode):
        """
        Parameters:
         - deviceHandle
         - newMode

        """
        pass

    def onProtocolAdded(self, deviceInfo, protocolInfo):
        """
        Parameters:
         - deviceInfo
         - protocolInfo

        """
        pass

    def onProtocolRemoved(self, deviceInfo, protocolInfo):
        """
        Parameters:
         - deviceInfo
         - protocolInfo

        """
        pass

    def onProtocolStateChange(self, protocolHandle, newState):
        """
        Parameters:
         - protocolHandle
         - newState

        """
        pass

    def onProtocolFlowControlStatusChange(self, protocolHandle, dir, newStatus):
        """
        Parameters:
         - protocolHandle
         - dir
         - newStatus

        """
        pass

    def onProtocolLockStatusChange(self, protocolHandle, newStatus):
        """
        Parameters:
         - protocolHandle
         - newStatus

        """
        pass

    def onProtocolMbnDownloadStatusChange(self, protocolHandle, newStatus):
        """
        Parameters:
         - protocolHandle
         - newStatus

        """
        pass

    def onClientCloseRequest(self, closeReason):
        """
        Parameters:
         - closeReason

        """
        pass

    def onMissingQShrinkHashFile(self, protocolHandle, missingFileGuid):
        """
        Parameters:
         - protocolHandle
         - missingFileGuid

        """
        pass

    def onLogSessionMissingQShrinkHashFile(self, logSessionInstance, protocolHandle, missingFileGuid):
        """
        Parameters:
         - logSessionInstance
         - protocolHandle
         - missingFileGuid

        """
        pass

    def onAsyncResponse(self, protocolHandle, transactionId):
        """
        Parameters:
         - protocolHandle
         - transactionId

        """
        pass

    def onDataQueueUpdated(self, queueName, queueSize):
        """
        Parameters:
         - queueName
         - queueSize

        """
        pass

    def onDataViewUpdated(self, viewName, viewSize, finished):
        """
        Parameters:
         - viewName
         - viewSize
         - finished

        """
        pass

    def onServiceAvailable(self, serviceName, deviceHandle):
        """
        Parameters:
         - serviceName
         - deviceHandle

        """
        pass

    def onServiceEnded(self, serviceName, deviceHandle):
        """
        Parameters:
         - serviceName
         - deviceHandle

        """
        pass

    def onServiceEvent(self, serviceName, eventId, eventDescription):
        """
        Parameters:
         - serviceName
         - eventId
         - eventDescription

        """
        pass

    def onImageManagementServiceEvent(self, serviceName, deviceHandle, protocolHandle, eventId, eventDescription):
        """
        Parameters:
         - serviceName
         - deviceHandle
         - protocolHandle
         - eventId
         - eventDescription

        """
        pass

    def onDeviceConfigServiceEvent(self, serviceName, deviceHandle, protocolHandle, eventId, eventDescription):
        """
        Parameters:
         - serviceName
         - deviceHandle
         - protocolHandle
         - eventId
         - eventDescription

        """
        pass

    def onQShrinkStateUpdated(self, protocolHandle, newState):
        """
        Parameters:
         - protocolHandle
         - newState

        """
        pass

    def onDecryptionKeyStatusUpdate(self, protocolHandle, keyInfo):
        """
        Parameters:
         - protocolHandle
         - keyInfo

        """
        pass

    def onLogSessionDecryptionKeyStatusUpdate(self, logSesssionInstance, protocolHandle, keyInfo):
        """
        Parameters:
         - logSesssionInstance
         - protocolHandle
         - keyInfo

        """
        pass

    def onServiceLockUpdate(self, lockInfo, lockState):
        """
        Parameters:
         - lockInfo
         - lockState

        """
        pass

    def onRestrictedLogLicenseStatusUpdate(self, restrictedLogLicenseInfo):
        """
        Parameters:
         - restrictedLogLicenseInfo

        """
        pass

    def onQspsMessage(self, profilerMessage):
        """
        Parameters:
         - profilerMessage

        """
        pass

    def onHyperVisorDataChanged(self, protocolHandle, hyperVisorConfiguration):
        """
        Parameters:
         - protocolHandle
         - hyperVisorConfiguration

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def onMessage(self, level, location, title, description):
        """
        Parameters:
         - level
         - location
         - title
         - description

        """
        self.send_onMessage(level, location, title, description)

    def send_onMessage(self, level, location, title, description):
        self._oprot.writeMessageBegin('onMessage', TMessageType.ONEWAY, self._seqid)
        args = onMessage_args()
        args.level = level
        args.location = location
        args.title = title
        args.description = description
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onDeviceConnected(self, deviceInfo):
        """
        Parameters:
         - deviceInfo

        """
        self.send_onDeviceConnected(deviceInfo)

    def send_onDeviceConnected(self, deviceInfo):
        self._oprot.writeMessageBegin('onDeviceConnected', TMessageType.ONEWAY, self._seqid)
        args = onDeviceConnected_args()
        args.deviceInfo = deviceInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onDeviceDisconnected(self, deviceInfo):
        """
        Parameters:
         - deviceInfo

        """
        self.send_onDeviceDisconnected(deviceInfo)

    def send_onDeviceDisconnected(self, deviceInfo):
        self._oprot.writeMessageBegin('onDeviceDisconnected', TMessageType.ONEWAY, self._seqid)
        args = onDeviceDisconnected_args()
        args.deviceInfo = deviceInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onDeviceModeChange(self, deviceHandle, newMode):
        """
        Parameters:
         - deviceHandle
         - newMode

        """
        self.send_onDeviceModeChange(deviceHandle, newMode)

    def send_onDeviceModeChange(self, deviceHandle, newMode):
        self._oprot.writeMessageBegin('onDeviceModeChange', TMessageType.ONEWAY, self._seqid)
        args = onDeviceModeChange_args()
        args.deviceHandle = deviceHandle
        args.newMode = newMode
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onProtocolAdded(self, deviceInfo, protocolInfo):
        """
        Parameters:
         - deviceInfo
         - protocolInfo

        """
        self.send_onProtocolAdded(deviceInfo, protocolInfo)

    def send_onProtocolAdded(self, deviceInfo, protocolInfo):
        self._oprot.writeMessageBegin('onProtocolAdded', TMessageType.ONEWAY, self._seqid)
        args = onProtocolAdded_args()
        args.deviceInfo = deviceInfo
        args.protocolInfo = protocolInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onProtocolRemoved(self, deviceInfo, protocolInfo):
        """
        Parameters:
         - deviceInfo
         - protocolInfo

        """
        self.send_onProtocolRemoved(deviceInfo, protocolInfo)

    def send_onProtocolRemoved(self, deviceInfo, protocolInfo):
        self._oprot.writeMessageBegin('onProtocolRemoved', TMessageType.ONEWAY, self._seqid)
        args = onProtocolRemoved_args()
        args.deviceInfo = deviceInfo
        args.protocolInfo = protocolInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onProtocolStateChange(self, protocolHandle, newState):
        """
        Parameters:
         - protocolHandle
         - newState

        """
        self.send_onProtocolStateChange(protocolHandle, newState)

    def send_onProtocolStateChange(self, protocolHandle, newState):
        self._oprot.writeMessageBegin('onProtocolStateChange', TMessageType.ONEWAY, self._seqid)
        args = onProtocolStateChange_args()
        args.protocolHandle = protocolHandle
        args.newState = newState
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onProtocolFlowControlStatusChange(self, protocolHandle, dir, newStatus):
        """
        Parameters:
         - protocolHandle
         - dir
         - newStatus

        """
        self.send_onProtocolFlowControlStatusChange(protocolHandle, dir, newStatus)

    def send_onProtocolFlowControlStatusChange(self, protocolHandle, dir, newStatus):
        self._oprot.writeMessageBegin('onProtocolFlowControlStatusChange', TMessageType.ONEWAY, self._seqid)
        args = onProtocolFlowControlStatusChange_args()
        args.protocolHandle = protocolHandle
        args.dir = dir
        args.newStatus = newStatus
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onProtocolLockStatusChange(self, protocolHandle, newStatus):
        """
        Parameters:
         - protocolHandle
         - newStatus

        """
        self.send_onProtocolLockStatusChange(protocolHandle, newStatus)

    def send_onProtocolLockStatusChange(self, protocolHandle, newStatus):
        self._oprot.writeMessageBegin('onProtocolLockStatusChange', TMessageType.ONEWAY, self._seqid)
        args = onProtocolLockStatusChange_args()
        args.protocolHandle = protocolHandle
        args.newStatus = newStatus
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onProtocolMbnDownloadStatusChange(self, protocolHandle, newStatus):
        """
        Parameters:
         - protocolHandle
         - newStatus

        """
        self.send_onProtocolMbnDownloadStatusChange(protocolHandle, newStatus)

    def send_onProtocolMbnDownloadStatusChange(self, protocolHandle, newStatus):
        self._oprot.writeMessageBegin('onProtocolMbnDownloadStatusChange', TMessageType.ONEWAY, self._seqid)
        args = onProtocolMbnDownloadStatusChange_args()
        args.protocolHandle = protocolHandle
        args.newStatus = newStatus
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onClientCloseRequest(self, closeReason):
        """
        Parameters:
         - closeReason

        """
        self.send_onClientCloseRequest(closeReason)

    def send_onClientCloseRequest(self, closeReason):
        self._oprot.writeMessageBegin('onClientCloseRequest', TMessageType.ONEWAY, self._seqid)
        args = onClientCloseRequest_args()
        args.closeReason = closeReason
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onMissingQShrinkHashFile(self, protocolHandle, missingFileGuid):
        """
        Parameters:
         - protocolHandle
         - missingFileGuid

        """
        self.send_onMissingQShrinkHashFile(protocolHandle, missingFileGuid)

    def send_onMissingQShrinkHashFile(self, protocolHandle, missingFileGuid):
        self._oprot.writeMessageBegin('onMissingQShrinkHashFile', TMessageType.ONEWAY, self._seqid)
        args = onMissingQShrinkHashFile_args()
        args.protocolHandle = protocolHandle
        args.missingFileGuid = missingFileGuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onLogSessionMissingQShrinkHashFile(self, logSessionInstance, protocolHandle, missingFileGuid):
        """
        Parameters:
         - logSessionInstance
         - protocolHandle
         - missingFileGuid

        """
        self.send_onLogSessionMissingQShrinkHashFile(logSessionInstance, protocolHandle, missingFileGuid)

    def send_onLogSessionMissingQShrinkHashFile(self, logSessionInstance, protocolHandle, missingFileGuid):
        self._oprot.writeMessageBegin('onLogSessionMissingQShrinkHashFile', TMessageType.ONEWAY, self._seqid)
        args = onLogSessionMissingQShrinkHashFile_args()
        args.logSessionInstance = logSessionInstance
        args.protocolHandle = protocolHandle
        args.missingFileGuid = missingFileGuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onAsyncResponse(self, protocolHandle, transactionId):
        """
        Parameters:
         - protocolHandle
         - transactionId

        """
        self.send_onAsyncResponse(protocolHandle, transactionId)

    def send_onAsyncResponse(self, protocolHandle, transactionId):
        self._oprot.writeMessageBegin('onAsyncResponse', TMessageType.ONEWAY, self._seqid)
        args = onAsyncResponse_args()
        args.protocolHandle = protocolHandle
        args.transactionId = transactionId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onDataQueueUpdated(self, queueName, queueSize):
        """
        Parameters:
         - queueName
         - queueSize

        """
        self.send_onDataQueueUpdated(queueName, queueSize)

    def send_onDataQueueUpdated(self, queueName, queueSize):
        self._oprot.writeMessageBegin('onDataQueueUpdated', TMessageType.ONEWAY, self._seqid)
        args = onDataQueueUpdated_args()
        args.queueName = queueName
        args.queueSize = queueSize
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onDataViewUpdated(self, viewName, viewSize, finished):
        """
        Parameters:
         - viewName
         - viewSize
         - finished

        """
        self.send_onDataViewUpdated(viewName, viewSize, finished)

    def send_onDataViewUpdated(self, viewName, viewSize, finished):
        self._oprot.writeMessageBegin('onDataViewUpdated', TMessageType.ONEWAY, self._seqid)
        args = onDataViewUpdated_args()
        args.viewName = viewName
        args.viewSize = viewSize
        args.finished = finished
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onServiceAvailable(self, serviceName, deviceHandle):
        """
        Parameters:
         - serviceName
         - deviceHandle

        """
        self.send_onServiceAvailable(serviceName, deviceHandle)

    def send_onServiceAvailable(self, serviceName, deviceHandle):
        self._oprot.writeMessageBegin('onServiceAvailable', TMessageType.ONEWAY, self._seqid)
        args = onServiceAvailable_args()
        args.serviceName = serviceName
        args.deviceHandle = deviceHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onServiceEnded(self, serviceName, deviceHandle):
        """
        Parameters:
         - serviceName
         - deviceHandle

        """
        self.send_onServiceEnded(serviceName, deviceHandle)

    def send_onServiceEnded(self, serviceName, deviceHandle):
        self._oprot.writeMessageBegin('onServiceEnded', TMessageType.ONEWAY, self._seqid)
        args = onServiceEnded_args()
        args.serviceName = serviceName
        args.deviceHandle = deviceHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onServiceEvent(self, serviceName, eventId, eventDescription):
        """
        Parameters:
         - serviceName
         - eventId
         - eventDescription

        """
        self.send_onServiceEvent(serviceName, eventId, eventDescription)

    def send_onServiceEvent(self, serviceName, eventId, eventDescription):
        self._oprot.writeMessageBegin('onServiceEvent', TMessageType.ONEWAY, self._seqid)
        args = onServiceEvent_args()
        args.serviceName = serviceName
        args.eventId = eventId
        args.eventDescription = eventDescription
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onImageManagementServiceEvent(self, serviceName, deviceHandle, protocolHandle, eventId, eventDescription):
        """
        Parameters:
         - serviceName
         - deviceHandle
         - protocolHandle
         - eventId
         - eventDescription

        """
        self.send_onImageManagementServiceEvent(serviceName, deviceHandle, protocolHandle, eventId, eventDescription)

    def send_onImageManagementServiceEvent(self, serviceName, deviceHandle, protocolHandle, eventId, eventDescription):
        self._oprot.writeMessageBegin('onImageManagementServiceEvent', TMessageType.ONEWAY, self._seqid)
        args = onImageManagementServiceEvent_args()
        args.serviceName = serviceName
        args.deviceHandle = deviceHandle
        args.protocolHandle = protocolHandle
        args.eventId = eventId
        args.eventDescription = eventDescription
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onDeviceConfigServiceEvent(self, serviceName, deviceHandle, protocolHandle, eventId, eventDescription):
        """
        Parameters:
         - serviceName
         - deviceHandle
         - protocolHandle
         - eventId
         - eventDescription

        """
        self.send_onDeviceConfigServiceEvent(serviceName, deviceHandle, protocolHandle, eventId, eventDescription)

    def send_onDeviceConfigServiceEvent(self, serviceName, deviceHandle, protocolHandle, eventId, eventDescription):
        self._oprot.writeMessageBegin('onDeviceConfigServiceEvent', TMessageType.ONEWAY, self._seqid)
        args = onDeviceConfigServiceEvent_args()
        args.serviceName = serviceName
        args.deviceHandle = deviceHandle
        args.protocolHandle = protocolHandle
        args.eventId = eventId
        args.eventDescription = eventDescription
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onQShrinkStateUpdated(self, protocolHandle, newState):
        """
        Parameters:
         - protocolHandle
         - newState

        """
        self.send_onQShrinkStateUpdated(protocolHandle, newState)

    def send_onQShrinkStateUpdated(self, protocolHandle, newState):
        self._oprot.writeMessageBegin('onQShrinkStateUpdated', TMessageType.ONEWAY, self._seqid)
        args = onQShrinkStateUpdated_args()
        args.protocolHandle = protocolHandle
        args.newState = newState
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onDecryptionKeyStatusUpdate(self, protocolHandle, keyInfo):
        """
        Parameters:
         - protocolHandle
         - keyInfo

        """
        self.send_onDecryptionKeyStatusUpdate(protocolHandle, keyInfo)

    def send_onDecryptionKeyStatusUpdate(self, protocolHandle, keyInfo):
        self._oprot.writeMessageBegin('onDecryptionKeyStatusUpdate', TMessageType.ONEWAY, self._seqid)
        args = onDecryptionKeyStatusUpdate_args()
        args.protocolHandle = protocolHandle
        args.keyInfo = keyInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onLogSessionDecryptionKeyStatusUpdate(self, logSesssionInstance, protocolHandle, keyInfo):
        """
        Parameters:
         - logSesssionInstance
         - protocolHandle
         - keyInfo

        """
        self.send_onLogSessionDecryptionKeyStatusUpdate(logSesssionInstance, protocolHandle, keyInfo)

    def send_onLogSessionDecryptionKeyStatusUpdate(self, logSesssionInstance, protocolHandle, keyInfo):
        self._oprot.writeMessageBegin('onLogSessionDecryptionKeyStatusUpdate', TMessageType.ONEWAY, self._seqid)
        args = onLogSessionDecryptionKeyStatusUpdate_args()
        args.logSesssionInstance = logSesssionInstance
        args.protocolHandle = protocolHandle
        args.keyInfo = keyInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onServiceLockUpdate(self, lockInfo, lockState):
        """
        Parameters:
         - lockInfo
         - lockState

        """
        self.send_onServiceLockUpdate(lockInfo, lockState)

    def send_onServiceLockUpdate(self, lockInfo, lockState):
        self._oprot.writeMessageBegin('onServiceLockUpdate', TMessageType.ONEWAY, self._seqid)
        args = onServiceLockUpdate_args()
        args.lockInfo = lockInfo
        args.lockState = lockState
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onRestrictedLogLicenseStatusUpdate(self, restrictedLogLicenseInfo):
        """
        Parameters:
         - restrictedLogLicenseInfo

        """
        self.send_onRestrictedLogLicenseStatusUpdate(restrictedLogLicenseInfo)

    def send_onRestrictedLogLicenseStatusUpdate(self, restrictedLogLicenseInfo):
        self._oprot.writeMessageBegin('onRestrictedLogLicenseStatusUpdate', TMessageType.ONEWAY, self._seqid)
        args = onRestrictedLogLicenseStatusUpdate_args()
        args.restrictedLogLicenseInfo = restrictedLogLicenseInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onQspsMessage(self, profilerMessage):
        """
        Parameters:
         - profilerMessage

        """
        self.send_onQspsMessage(profilerMessage)

    def send_onQspsMessage(self, profilerMessage):
        self._oprot.writeMessageBegin('onQspsMessage', TMessageType.ONEWAY, self._seqid)
        args = onQspsMessage_args()
        args.profilerMessage = profilerMessage
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def onHyperVisorDataChanged(self, protocolHandle, hyperVisorConfiguration):
        """
        Parameters:
         - protocolHandle
         - hyperVisorConfiguration

        """
        self.send_onHyperVisorDataChanged(protocolHandle, hyperVisorConfiguration)

    def send_onHyperVisorDataChanged(self, protocolHandle, hyperVisorConfiguration):
        self._oprot.writeMessageBegin('onHyperVisorDataChanged', TMessageType.ONEWAY, self._seqid)
        args = onHyperVisorDataChanged_args()
        args.protocolHandle = protocolHandle
        args.hyperVisorConfiguration = hyperVisorConfiguration
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["onMessage"] = Processor.process_onMessage
        self._processMap["onDeviceConnected"] = Processor.process_onDeviceConnected
        self._processMap["onDeviceDisconnected"] = Processor.process_onDeviceDisconnected
        self._processMap["onDeviceModeChange"] = Processor.process_onDeviceModeChange
        self._processMap["onProtocolAdded"] = Processor.process_onProtocolAdded
        self._processMap["onProtocolRemoved"] = Processor.process_onProtocolRemoved
        self._processMap["onProtocolStateChange"] = Processor.process_onProtocolStateChange
        self._processMap["onProtocolFlowControlStatusChange"] = Processor.process_onProtocolFlowControlStatusChange
        self._processMap["onProtocolLockStatusChange"] = Processor.process_onProtocolLockStatusChange
        self._processMap["onProtocolMbnDownloadStatusChange"] = Processor.process_onProtocolMbnDownloadStatusChange
        self._processMap["onClientCloseRequest"] = Processor.process_onClientCloseRequest
        self._processMap["onMissingQShrinkHashFile"] = Processor.process_onMissingQShrinkHashFile
        self._processMap["onLogSessionMissingQShrinkHashFile"] = Processor.process_onLogSessionMissingQShrinkHashFile
        self._processMap["onAsyncResponse"] = Processor.process_onAsyncResponse
        self._processMap["onDataQueueUpdated"] = Processor.process_onDataQueueUpdated
        self._processMap["onDataViewUpdated"] = Processor.process_onDataViewUpdated
        self._processMap["onServiceAvailable"] = Processor.process_onServiceAvailable
        self._processMap["onServiceEnded"] = Processor.process_onServiceEnded
        self._processMap["onServiceEvent"] = Processor.process_onServiceEvent
        self._processMap["onImageManagementServiceEvent"] = Processor.process_onImageManagementServiceEvent
        self._processMap["onDeviceConfigServiceEvent"] = Processor.process_onDeviceConfigServiceEvent
        self._processMap["onQShrinkStateUpdated"] = Processor.process_onQShrinkStateUpdated
        self._processMap["onDecryptionKeyStatusUpdate"] = Processor.process_onDecryptionKeyStatusUpdate
        self._processMap["onLogSessionDecryptionKeyStatusUpdate"] = Processor.process_onLogSessionDecryptionKeyStatusUpdate
        self._processMap["onServiceLockUpdate"] = Processor.process_onServiceLockUpdate
        self._processMap["onRestrictedLogLicenseStatusUpdate"] = Processor.process_onRestrictedLogLicenseStatusUpdate
        self._processMap["onQspsMessage"] = Processor.process_onQspsMessage
        self._processMap["onHyperVisorDataChanged"] = Processor.process_onHyperVisorDataChanged
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_onMessage(self, seqid, iprot, oprot):
        args = onMessage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onMessage(args.level, args.location, args.title, args.description)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onDeviceConnected(self, seqid, iprot, oprot):
        args = onDeviceConnected_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onDeviceConnected(args.deviceInfo)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onDeviceDisconnected(self, seqid, iprot, oprot):
        args = onDeviceDisconnected_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onDeviceDisconnected(args.deviceInfo)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onDeviceModeChange(self, seqid, iprot, oprot):
        args = onDeviceModeChange_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onDeviceModeChange(args.deviceHandle, args.newMode)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onProtocolAdded(self, seqid, iprot, oprot):
        args = onProtocolAdded_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onProtocolAdded(args.deviceInfo, args.protocolInfo)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onProtocolRemoved(self, seqid, iprot, oprot):
        args = onProtocolRemoved_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onProtocolRemoved(args.deviceInfo, args.protocolInfo)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onProtocolStateChange(self, seqid, iprot, oprot):
        args = onProtocolStateChange_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onProtocolStateChange(args.protocolHandle, args.newState)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onProtocolFlowControlStatusChange(self, seqid, iprot, oprot):
        args = onProtocolFlowControlStatusChange_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onProtocolFlowControlStatusChange(args.protocolHandle, args.dir, args.newStatus)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onProtocolLockStatusChange(self, seqid, iprot, oprot):
        args = onProtocolLockStatusChange_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onProtocolLockStatusChange(args.protocolHandle, args.newStatus)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onProtocolMbnDownloadStatusChange(self, seqid, iprot, oprot):
        args = onProtocolMbnDownloadStatusChange_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onProtocolMbnDownloadStatusChange(args.protocolHandle, args.newStatus)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onClientCloseRequest(self, seqid, iprot, oprot):
        args = onClientCloseRequest_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onClientCloseRequest(args.closeReason)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onMissingQShrinkHashFile(self, seqid, iprot, oprot):
        args = onMissingQShrinkHashFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onMissingQShrinkHashFile(args.protocolHandle, args.missingFileGuid)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onLogSessionMissingQShrinkHashFile(self, seqid, iprot, oprot):
        args = onLogSessionMissingQShrinkHashFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onLogSessionMissingQShrinkHashFile(args.logSessionInstance, args.protocolHandle, args.missingFileGuid)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onAsyncResponse(self, seqid, iprot, oprot):
        args = onAsyncResponse_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onAsyncResponse(args.protocolHandle, args.transactionId)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onDataQueueUpdated(self, seqid, iprot, oprot):
        args = onDataQueueUpdated_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onDataQueueUpdated(args.queueName, args.queueSize)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onDataViewUpdated(self, seqid, iprot, oprot):
        args = onDataViewUpdated_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onDataViewUpdated(args.viewName, args.viewSize, args.finished)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onServiceAvailable(self, seqid, iprot, oprot):
        args = onServiceAvailable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onServiceAvailable(args.serviceName, args.deviceHandle)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onServiceEnded(self, seqid, iprot, oprot):
        args = onServiceEnded_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onServiceEnded(args.serviceName, args.deviceHandle)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onServiceEvent(self, seqid, iprot, oprot):
        args = onServiceEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onServiceEvent(args.serviceName, args.eventId, args.eventDescription)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onImageManagementServiceEvent(self, seqid, iprot, oprot):
        args = onImageManagementServiceEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onImageManagementServiceEvent(args.serviceName, args.deviceHandle, args.protocolHandle, args.eventId, args.eventDescription)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onDeviceConfigServiceEvent(self, seqid, iprot, oprot):
        args = onDeviceConfigServiceEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onDeviceConfigServiceEvent(args.serviceName, args.deviceHandle, args.protocolHandle, args.eventId, args.eventDescription)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onQShrinkStateUpdated(self, seqid, iprot, oprot):
        args = onQShrinkStateUpdated_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onQShrinkStateUpdated(args.protocolHandle, args.newState)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onDecryptionKeyStatusUpdate(self, seqid, iprot, oprot):
        args = onDecryptionKeyStatusUpdate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onDecryptionKeyStatusUpdate(args.protocolHandle, args.keyInfo)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onLogSessionDecryptionKeyStatusUpdate(self, seqid, iprot, oprot):
        args = onLogSessionDecryptionKeyStatusUpdate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onLogSessionDecryptionKeyStatusUpdate(args.logSesssionInstance, args.protocolHandle, args.keyInfo)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onServiceLockUpdate(self, seqid, iprot, oprot):
        args = onServiceLockUpdate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onServiceLockUpdate(args.lockInfo, args.lockState)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onRestrictedLogLicenseStatusUpdate(self, seqid, iprot, oprot):
        args = onRestrictedLogLicenseStatusUpdate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onRestrictedLogLicenseStatusUpdate(args.restrictedLogLicenseInfo)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onQspsMessage(self, seqid, iprot, oprot):
        args = onQspsMessage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onQspsMessage(args.profilerMessage)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_onHyperVisorDataChanged(self, seqid, iprot, oprot):
        args = onHyperVisorDataChanged_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.onHyperVisorDataChanged(args.protocolHandle, args.hyperVisorConfiguration)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

# HELPER FUNCTIONS AND STRUCTURES


class onMessage_args(object):
    """
    Attributes:
     - level
     - location
     - title
     - description

    """


    def __init__(self, level=None, location=None, title=None, description=None,):
        self.level = level
        self.location = location
        self.title = title
        self.description = description

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.level = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.location = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.title = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.description = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onMessage_args')
        if self.level is not None:
            oprot.writeFieldBegin('level', TType.I32, 1)
            oprot.writeI32(self.level)
            oprot.writeFieldEnd()
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRING, 2)
            oprot.writeString(self.location.encode('utf-8') if sys.version_info[0] == 2 else self.location)
            oprot.writeFieldEnd()
        if self.title is not None:
            oprot.writeFieldBegin('title', TType.STRING, 3)
            oprot.writeString(self.title.encode('utf-8') if sys.version_info[0] == 2 else self.title)
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin('description', TType.STRING, 4)
            oprot.writeString(self.description.encode('utf-8') if sys.version_info[0] == 2 else self.description)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onMessage_args)
onMessage_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'level', None, None, ),  # 1
    (2, TType.STRING, 'location', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'title', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'description', 'UTF8', None, ),  # 4
)


class onDeviceConnected_args(object):
    """
    Attributes:
     - deviceInfo

    """


    def __init__(self, deviceInfo=None,):
        self.deviceInfo = deviceInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.deviceInfo = Common.ttypes.DeviceInfo()
                    self.deviceInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onDeviceConnected_args')
        if self.deviceInfo is not None:
            oprot.writeFieldBegin('deviceInfo', TType.STRUCT, 1)
            self.deviceInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onDeviceConnected_args)
onDeviceConnected_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'deviceInfo', [Common.ttypes.DeviceInfo, None], None, ),  # 1
)


class onDeviceDisconnected_args(object):
    """
    Attributes:
     - deviceInfo

    """


    def __init__(self, deviceInfo=None,):
        self.deviceInfo = deviceInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.deviceInfo = Common.ttypes.DeviceInfo()
                    self.deviceInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onDeviceDisconnected_args')
        if self.deviceInfo is not None:
            oprot.writeFieldBegin('deviceInfo', TType.STRUCT, 1)
            self.deviceInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onDeviceDisconnected_args)
onDeviceDisconnected_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'deviceInfo', [Common.ttypes.DeviceInfo, None], None, ),  # 1
)


class onDeviceModeChange_args(object):
    """
    Attributes:
     - deviceHandle
     - newMode

    """


    def __init__(self, deviceHandle=None, newMode=None,):
        self.deviceHandle = deviceHandle
        self.newMode = newMode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.newMode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onDeviceModeChange_args')
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 1)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        if self.newMode is not None:
            oprot.writeFieldBegin('newMode', TType.I32, 2)
            oprot.writeI32(self.newMode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onDeviceModeChange_args)
onDeviceModeChange_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'deviceHandle', None, None, ),  # 1
    (2, TType.I32, 'newMode', None, None, ),  # 2
)


class onProtocolAdded_args(object):
    """
    Attributes:
     - deviceInfo
     - protocolInfo

    """


    def __init__(self, deviceInfo=None, protocolInfo=None,):
        self.deviceInfo = deviceInfo
        self.protocolInfo = protocolInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.deviceInfo = Common.ttypes.DeviceInfo()
                    self.deviceInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.protocolInfo = Common.ttypes.ProtocolInfo()
                    self.protocolInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onProtocolAdded_args')
        if self.deviceInfo is not None:
            oprot.writeFieldBegin('deviceInfo', TType.STRUCT, 1)
            self.deviceInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.protocolInfo is not None:
            oprot.writeFieldBegin('protocolInfo', TType.STRUCT, 2)
            self.protocolInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onProtocolAdded_args)
onProtocolAdded_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'deviceInfo', [Common.ttypes.DeviceInfo, None], None, ),  # 1
    (2, TType.STRUCT, 'protocolInfo', [Common.ttypes.ProtocolInfo, None], None, ),  # 2
)


class onProtocolRemoved_args(object):
    """
    Attributes:
     - deviceInfo
     - protocolInfo

    """


    def __init__(self, deviceInfo=None, protocolInfo=None,):
        self.deviceInfo = deviceInfo
        self.protocolInfo = protocolInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.deviceInfo = Common.ttypes.DeviceInfo()
                    self.deviceInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.protocolInfo = Common.ttypes.ProtocolInfo()
                    self.protocolInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onProtocolRemoved_args')
        if self.deviceInfo is not None:
            oprot.writeFieldBegin('deviceInfo', TType.STRUCT, 1)
            self.deviceInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.protocolInfo is not None:
            oprot.writeFieldBegin('protocolInfo', TType.STRUCT, 2)
            self.protocolInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onProtocolRemoved_args)
onProtocolRemoved_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'deviceInfo', [Common.ttypes.DeviceInfo, None], None, ),  # 1
    (2, TType.STRUCT, 'protocolInfo', [Common.ttypes.ProtocolInfo, None], None, ),  # 2
)


class onProtocolStateChange_args(object):
    """
    Attributes:
     - protocolHandle
     - newState

    """


    def __init__(self, protocolHandle=None, newState=None,):
        self.protocolHandle = protocolHandle
        self.newState = newState

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.newState = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onProtocolStateChange_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.newState is not None:
            oprot.writeFieldBegin('newState', TType.I32, 2)
            oprot.writeI32(self.newState)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onProtocolStateChange_args)
onProtocolStateChange_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
    (2, TType.I32, 'newState', None, None, ),  # 2
)


class onProtocolFlowControlStatusChange_args(object):
    """
    Attributes:
     - protocolHandle
     - dir
     - newStatus

    """


    def __init__(self, protocolHandle=None, dir=None, newStatus=None,):
        self.protocolHandle = protocolHandle
        self.dir = dir
        self.newStatus = newStatus

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dir = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.newStatus = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onProtocolFlowControlStatusChange_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.dir is not None:
            oprot.writeFieldBegin('dir', TType.I32, 2)
            oprot.writeI32(self.dir)
            oprot.writeFieldEnd()
        if self.newStatus is not None:
            oprot.writeFieldBegin('newStatus', TType.I32, 3)
            oprot.writeI32(self.newStatus)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onProtocolFlowControlStatusChange_args)
onProtocolFlowControlStatusChange_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
    (2, TType.I32, 'dir', None, None, ),  # 2
    (3, TType.I32, 'newStatus', None, None, ),  # 3
)


class onProtocolLockStatusChange_args(object):
    """
    Attributes:
     - protocolHandle
     - newStatus

    """


    def __init__(self, protocolHandle=None, newStatus=None,):
        self.protocolHandle = protocolHandle
        self.newStatus = newStatus

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.newStatus = Common.ttypes.LockStatus()
                    self.newStatus.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onProtocolLockStatusChange_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.newStatus is not None:
            oprot.writeFieldBegin('newStatus', TType.STRUCT, 2)
            self.newStatus.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onProtocolLockStatusChange_args)
onProtocolLockStatusChange_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
    (2, TType.STRUCT, 'newStatus', [Common.ttypes.LockStatus, None], None, ),  # 2
)


class onProtocolMbnDownloadStatusChange_args(object):
    """
    Attributes:
     - protocolHandle
     - newStatus

    """


    def __init__(self, protocolHandle=None, newStatus=None,):
        self.protocolHandle = protocolHandle
        self.newStatus = newStatus

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.newStatus = Common.ttypes.MbnDownloadStatus()
                    self.newStatus.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onProtocolMbnDownloadStatusChange_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.newStatus is not None:
            oprot.writeFieldBegin('newStatus', TType.STRUCT, 2)
            self.newStatus.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onProtocolMbnDownloadStatusChange_args)
onProtocolMbnDownloadStatusChange_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
    (2, TType.STRUCT, 'newStatus', [Common.ttypes.MbnDownloadStatus, None], None, ),  # 2
)


class onClientCloseRequest_args(object):
    """
    Attributes:
     - closeReason

    """


    def __init__(self, closeReason=None,):
        self.closeReason = closeReason

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.closeReason = Common.ttypes.ClientCloseReason()
                    self.closeReason.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onClientCloseRequest_args')
        if self.closeReason is not None:
            oprot.writeFieldBegin('closeReason', TType.STRUCT, 1)
            self.closeReason.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onClientCloseRequest_args)
onClientCloseRequest_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'closeReason', [Common.ttypes.ClientCloseReason, None], None, ),  # 1
)


class onMissingQShrinkHashFile_args(object):
    """
    Attributes:
     - protocolHandle
     - missingFileGuid

    """


    def __init__(self, protocolHandle=None, missingFileGuid=None,):
        self.protocolHandle = protocolHandle
        self.missingFileGuid = missingFileGuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.missingFileGuid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onMissingQShrinkHashFile_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.missingFileGuid is not None:
            oprot.writeFieldBegin('missingFileGuid', TType.STRING, 2)
            oprot.writeString(self.missingFileGuid.encode('utf-8') if sys.version_info[0] == 2 else self.missingFileGuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onMissingQShrinkHashFile_args)
onMissingQShrinkHashFile_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
    (2, TType.STRING, 'missingFileGuid', 'UTF8', None, ),  # 2
)


class onLogSessionMissingQShrinkHashFile_args(object):
    """
    Attributes:
     - logSessionInstance
     - protocolHandle
     - missingFileGuid

    """


    def __init__(self, logSessionInstance=None, protocolHandle=None, missingFileGuid=None,):
        self.logSessionInstance = logSessionInstance
        self.protocolHandle = protocolHandle
        self.missingFileGuid = missingFileGuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.logSessionInstance = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.missingFileGuid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onLogSessionMissingQShrinkHashFile_args')
        if self.logSessionInstance is not None:
            oprot.writeFieldBegin('logSessionInstance', TType.STRING, 1)
            oprot.writeString(self.logSessionInstance.encode('utf-8') if sys.version_info[0] == 2 else self.logSessionInstance)
            oprot.writeFieldEnd()
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 2)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.missingFileGuid is not None:
            oprot.writeFieldBegin('missingFileGuid', TType.STRING, 3)
            oprot.writeString(self.missingFileGuid.encode('utf-8') if sys.version_info[0] == 2 else self.missingFileGuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onLogSessionMissingQShrinkHashFile_args)
onLogSessionMissingQShrinkHashFile_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'logSessionInstance', 'UTF8', None, ),  # 1
    (2, TType.I64, 'protocolHandle', None, None, ),  # 2
    (3, TType.STRING, 'missingFileGuid', 'UTF8', None, ),  # 3
)


class onAsyncResponse_args(object):
    """
    Attributes:
     - protocolHandle
     - transactionId

    """


    def __init__(self, protocolHandle=None, transactionId=None,):
        self.protocolHandle = protocolHandle
        self.transactionId = transactionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.transactionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onAsyncResponse_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.transactionId is not None:
            oprot.writeFieldBegin('transactionId', TType.I64, 2)
            oprot.writeI64(self.transactionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onAsyncResponse_args)
onAsyncResponse_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
    (2, TType.I64, 'transactionId', None, None, ),  # 2
)


class onDataQueueUpdated_args(object):
    """
    Attributes:
     - queueName
     - queueSize

    """


    def __init__(self, queueName=None, queueSize=None,):
        self.queueName = queueName
        self.queueSize = queueSize

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queueName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.queueSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onDataQueueUpdated_args')
        if self.queueName is not None:
            oprot.writeFieldBegin('queueName', TType.STRING, 1)
            oprot.writeString(self.queueName.encode('utf-8') if sys.version_info[0] == 2 else self.queueName)
            oprot.writeFieldEnd()
        if self.queueSize is not None:
            oprot.writeFieldBegin('queueSize', TType.I32, 2)
            oprot.writeI32(self.queueSize)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onDataQueueUpdated_args)
onDataQueueUpdated_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queueName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'queueSize', None, None, ),  # 2
)


class onDataViewUpdated_args(object):
    """
    Attributes:
     - viewName
     - viewSize
     - finished

    """


    def __init__(self, viewName=None, viewSize=None, finished=None,):
        self.viewName = viewName
        self.viewSize = viewSize
        self.finished = finished

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.viewName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.viewSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.finished = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onDataViewUpdated_args')
        if self.viewName is not None:
            oprot.writeFieldBegin('viewName', TType.STRING, 1)
            oprot.writeString(self.viewName.encode('utf-8') if sys.version_info[0] == 2 else self.viewName)
            oprot.writeFieldEnd()
        if self.viewSize is not None:
            oprot.writeFieldBegin('viewSize', TType.I32, 2)
            oprot.writeI32(self.viewSize)
            oprot.writeFieldEnd()
        if self.finished is not None:
            oprot.writeFieldBegin('finished', TType.BOOL, 3)
            oprot.writeBool(self.finished)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onDataViewUpdated_args)
onDataViewUpdated_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'viewName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'viewSize', None, None, ),  # 2
    (3, TType.BOOL, 'finished', None, None, ),  # 3
)


class onServiceAvailable_args(object):
    """
    Attributes:
     - serviceName
     - deviceHandle

    """


    def __init__(self, serviceName=None, deviceHandle=None,):
        self.serviceName = serviceName
        self.deviceHandle = deviceHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.serviceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onServiceAvailable_args')
        if self.serviceName is not None:
            oprot.writeFieldBegin('serviceName', TType.STRING, 1)
            oprot.writeString(self.serviceName.encode('utf-8') if sys.version_info[0] == 2 else self.serviceName)
            oprot.writeFieldEnd()
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 2)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onServiceAvailable_args)
onServiceAvailable_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'serviceName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'deviceHandle', None, None, ),  # 2
)


class onServiceEnded_args(object):
    """
    Attributes:
     - serviceName
     - deviceHandle

    """


    def __init__(self, serviceName=None, deviceHandle=None,):
        self.serviceName = serviceName
        self.deviceHandle = deviceHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.serviceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onServiceEnded_args')
        if self.serviceName is not None:
            oprot.writeFieldBegin('serviceName', TType.STRING, 1)
            oprot.writeString(self.serviceName.encode('utf-8') if sys.version_info[0] == 2 else self.serviceName)
            oprot.writeFieldEnd()
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 2)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onServiceEnded_args)
onServiceEnded_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'serviceName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'deviceHandle', None, None, ),  # 2
)


class onServiceEvent_args(object):
    """
    Attributes:
     - serviceName
     - eventId
     - eventDescription

    """


    def __init__(self, serviceName=None, eventId=None, eventDescription=None,):
        self.serviceName = serviceName
        self.eventId = eventId
        self.eventDescription = eventDescription

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.serviceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.eventId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.eventDescription = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onServiceEvent_args')
        if self.serviceName is not None:
            oprot.writeFieldBegin('serviceName', TType.STRING, 1)
            oprot.writeString(self.serviceName.encode('utf-8') if sys.version_info[0] == 2 else self.serviceName)
            oprot.writeFieldEnd()
        if self.eventId is not None:
            oprot.writeFieldBegin('eventId', TType.I64, 2)
            oprot.writeI64(self.eventId)
            oprot.writeFieldEnd()
        if self.eventDescription is not None:
            oprot.writeFieldBegin('eventDescription', TType.STRING, 3)
            oprot.writeString(self.eventDescription.encode('utf-8') if sys.version_info[0] == 2 else self.eventDescription)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onServiceEvent_args)
onServiceEvent_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'serviceName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'eventId', None, None, ),  # 2
    (3, TType.STRING, 'eventDescription', 'UTF8', None, ),  # 3
)


class onImageManagementServiceEvent_args(object):
    """
    Attributes:
     - serviceName
     - deviceHandle
     - protocolHandle
     - eventId
     - eventDescription

    """


    def __init__(self, serviceName=None, deviceHandle=None, protocolHandle=None, eventId=None, eventDescription=None,):
        self.serviceName = serviceName
        self.deviceHandle = deviceHandle
        self.protocolHandle = protocolHandle
        self.eventId = eventId
        self.eventDescription = eventDescription

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.serviceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.eventId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.eventDescription = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onImageManagementServiceEvent_args')
        if self.serviceName is not None:
            oprot.writeFieldBegin('serviceName', TType.STRING, 1)
            oprot.writeString(self.serviceName.encode('utf-8') if sys.version_info[0] == 2 else self.serviceName)
            oprot.writeFieldEnd()
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 2)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 3)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.eventId is not None:
            oprot.writeFieldBegin('eventId', TType.I64, 4)
            oprot.writeI64(self.eventId)
            oprot.writeFieldEnd()
        if self.eventDescription is not None:
            oprot.writeFieldBegin('eventDescription', TType.STRING, 5)
            oprot.writeString(self.eventDescription.encode('utf-8') if sys.version_info[0] == 2 else self.eventDescription)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onImageManagementServiceEvent_args)
onImageManagementServiceEvent_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'serviceName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'deviceHandle', None, None, ),  # 2
    (3, TType.I64, 'protocolHandle', None, None, ),  # 3
    (4, TType.I64, 'eventId', None, None, ),  # 4
    (5, TType.STRING, 'eventDescription', 'UTF8', None, ),  # 5
)


class onDeviceConfigServiceEvent_args(object):
    """
    Attributes:
     - serviceName
     - deviceHandle
     - protocolHandle
     - eventId
     - eventDescription

    """


    def __init__(self, serviceName=None, deviceHandle=None, protocolHandle=None, eventId=None, eventDescription=None,):
        self.serviceName = serviceName
        self.deviceHandle = deviceHandle
        self.protocolHandle = protocolHandle
        self.eventId = eventId
        self.eventDescription = eventDescription

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.serviceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.eventId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.eventDescription = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onDeviceConfigServiceEvent_args')
        if self.serviceName is not None:
            oprot.writeFieldBegin('serviceName', TType.STRING, 1)
            oprot.writeString(self.serviceName.encode('utf-8') if sys.version_info[0] == 2 else self.serviceName)
            oprot.writeFieldEnd()
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 2)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 3)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.eventId is not None:
            oprot.writeFieldBegin('eventId', TType.I64, 4)
            oprot.writeI64(self.eventId)
            oprot.writeFieldEnd()
        if self.eventDescription is not None:
            oprot.writeFieldBegin('eventDescription', TType.STRING, 5)
            oprot.writeString(self.eventDescription.encode('utf-8') if sys.version_info[0] == 2 else self.eventDescription)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onDeviceConfigServiceEvent_args)
onDeviceConfigServiceEvent_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'serviceName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'deviceHandle', None, None, ),  # 2
    (3, TType.I64, 'protocolHandle', None, None, ),  # 3
    (4, TType.I64, 'eventId', None, None, ),  # 4
    (5, TType.STRING, 'eventDescription', 'UTF8', None, ),  # 5
)


class onQShrinkStateUpdated_args(object):
    """
    Attributes:
     - protocolHandle
     - newState

    """


    def __init__(self, protocolHandle=None, newState=None,):
        self.protocolHandle = protocolHandle
        self.newState = newState

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.newState = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onQShrinkStateUpdated_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.newState is not None:
            oprot.writeFieldBegin('newState', TType.I32, 2)
            oprot.writeI32(self.newState)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onQShrinkStateUpdated_args)
onQShrinkStateUpdated_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
    (2, TType.I32, 'newState', None, None, ),  # 2
)


class onDecryptionKeyStatusUpdate_args(object):
    """
    Attributes:
     - protocolHandle
     - keyInfo

    """


    def __init__(self, protocolHandle=None, keyInfo=None,):
        self.protocolHandle = protocolHandle
        self.keyInfo = keyInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.keyInfo = Common.ttypes.KeyInfo()
                    self.keyInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onDecryptionKeyStatusUpdate_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.keyInfo is not None:
            oprot.writeFieldBegin('keyInfo', TType.STRUCT, 2)
            self.keyInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onDecryptionKeyStatusUpdate_args)
onDecryptionKeyStatusUpdate_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
    (2, TType.STRUCT, 'keyInfo', [Common.ttypes.KeyInfo, None], None, ),  # 2
)


class onLogSessionDecryptionKeyStatusUpdate_args(object):
    """
    Attributes:
     - logSesssionInstance
     - protocolHandle
     - keyInfo

    """


    def __init__(self, logSesssionInstance=None, protocolHandle=None, keyInfo=None,):
        self.logSesssionInstance = logSesssionInstance
        self.protocolHandle = protocolHandle
        self.keyInfo = keyInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.logSesssionInstance = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.keyInfo = Common.ttypes.KeyInfo()
                    self.keyInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onLogSessionDecryptionKeyStatusUpdate_args')
        if self.logSesssionInstance is not None:
            oprot.writeFieldBegin('logSesssionInstance', TType.STRING, 1)
            oprot.writeString(self.logSesssionInstance.encode('utf-8') if sys.version_info[0] == 2 else self.logSesssionInstance)
            oprot.writeFieldEnd()
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 2)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.keyInfo is not None:
            oprot.writeFieldBegin('keyInfo', TType.STRUCT, 3)
            self.keyInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onLogSessionDecryptionKeyStatusUpdate_args)
onLogSessionDecryptionKeyStatusUpdate_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'logSesssionInstance', 'UTF8', None, ),  # 1
    (2, TType.I64, 'protocolHandle', None, None, ),  # 2
    (3, TType.STRUCT, 'keyInfo', [Common.ttypes.KeyInfo, None], None, ),  # 3
)


class onServiceLockUpdate_args(object):
    """
    Attributes:
     - lockInfo
     - lockState

    """


    def __init__(self, lockInfo=None, lockState=None,):
        self.lockInfo = lockInfo
        self.lockState = lockState

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.lockInfo = Common.ttypes.ServiceLockInfo()
                    self.lockInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.lockState = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onServiceLockUpdate_args')
        if self.lockInfo is not None:
            oprot.writeFieldBegin('lockInfo', TType.STRUCT, 1)
            self.lockInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.lockState is not None:
            oprot.writeFieldBegin('lockState', TType.I32, 2)
            oprot.writeI32(self.lockState)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onServiceLockUpdate_args)
onServiceLockUpdate_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'lockInfo', [Common.ttypes.ServiceLockInfo, None], None, ),  # 1
    (2, TType.I32, 'lockState', None, None, ),  # 2
)


class onRestrictedLogLicenseStatusUpdate_args(object):
    """
    Attributes:
     - restrictedLogLicenseInfo

    """


    def __init__(self, restrictedLogLicenseInfo=None,):
        self.restrictedLogLicenseInfo = restrictedLogLicenseInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.restrictedLogLicenseInfo = Common.ttypes.RestrictedLogLicenseInfo()
                    self.restrictedLogLicenseInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onRestrictedLogLicenseStatusUpdate_args')
        if self.restrictedLogLicenseInfo is not None:
            oprot.writeFieldBegin('restrictedLogLicenseInfo', TType.STRUCT, 1)
            self.restrictedLogLicenseInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onRestrictedLogLicenseStatusUpdate_args)
onRestrictedLogLicenseStatusUpdate_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'restrictedLogLicenseInfo', [Common.ttypes.RestrictedLogLicenseInfo, None], None, ),  # 1
)


class onQspsMessage_args(object):
    """
    Attributes:
     - profilerMessage

    """


    def __init__(self, profilerMessage=None,):
        self.profilerMessage = profilerMessage

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.profilerMessage = Common.ttypes.ProfilerMessage()
                    self.profilerMessage.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onQspsMessage_args')
        if self.profilerMessage is not None:
            oprot.writeFieldBegin('profilerMessage', TType.STRUCT, 1)
            self.profilerMessage.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onQspsMessage_args)
onQspsMessage_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'profilerMessage', [Common.ttypes.ProfilerMessage, None], None, ),  # 1
)


class onHyperVisorDataChanged_args(object):
    """
    Attributes:
     - protocolHandle
     - hyperVisorConfiguration

    """


    def __init__(self, protocolHandle=None, hyperVisorConfiguration=None,):
        self.protocolHandle = protocolHandle
        self.hyperVisorConfiguration = hyperVisorConfiguration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.hyperVisorConfiguration = Common.ttypes.HypervisorConfiguration()
                    self.hyperVisorConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onHyperVisorDataChanged_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.hyperVisorConfiguration is not None:
            oprot.writeFieldBegin('hyperVisorConfiguration', TType.STRUCT, 2)
            self.hyperVisorConfiguration.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onHyperVisorDataChanged_args)
onHyperVisorDataChanged_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
    (2, TType.STRUCT, 'hyperVisorConfiguration', [Common.ttypes.HypervisorConfiguration, None], None, ),  # 2
)
fix_spec(all_structs)
del all_structs
