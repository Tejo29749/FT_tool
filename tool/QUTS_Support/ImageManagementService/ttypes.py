#
# Autogenerated by Thrift Compiler (0.14.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import Common.ttypes

from thrift.transport import TTransport
all_structs = []


class DeviceImageMode(object):
    DEVICE_IMAGE_MODE_NONE = 0
    DEVICE_IMAGE_MODE_SAHARA_DOWNLOAD = 1
    DEVICE_IMAGE_MODE_SAHARA_CRASH = 2
    DEVICE_IMAGE_MODE_SAHARA_EFS_SYNC = 4

    _VALUES_TO_NAMES = {
        0: "DEVICE_IMAGE_MODE_NONE",
        1: "DEVICE_IMAGE_MODE_SAHARA_DOWNLOAD",
        2: "DEVICE_IMAGE_MODE_SAHARA_CRASH",
        4: "DEVICE_IMAGE_MODE_SAHARA_EFS_SYNC",
    }

    _NAMES_TO_VALUES = {
        "DEVICE_IMAGE_MODE_NONE": 0,
        "DEVICE_IMAGE_MODE_SAHARA_DOWNLOAD": 1,
        "DEVICE_IMAGE_MODE_SAHARA_CRASH": 2,
        "DEVICE_IMAGE_MODE_SAHARA_EFS_SYNC": 4,
    }


class MemoryType(object):
    MEMORY_TYPE_EMMC = 0
    MEMORY_TYPE_UFS = 1
    MEMORY_TYPE_NAND = 2
    MEMORY_TYPE_NVME = 3
    MEMORY_TYPE_SPINOR = 4
    MEMORY_TYPE_UNKNOWN = 5

    _VALUES_TO_NAMES = {
        0: "MEMORY_TYPE_EMMC",
        1: "MEMORY_TYPE_UFS",
        2: "MEMORY_TYPE_NAND",
        3: "MEMORY_TYPE_NVME",
        4: "MEMORY_TYPE_SPINOR",
        5: "MEMORY_TYPE_UNKNOWN",
    }

    _NAMES_TO_VALUES = {
        "MEMORY_TYPE_EMMC": 0,
        "MEMORY_TYPE_UFS": 1,
        "MEMORY_TYPE_NAND": 2,
        "MEMORY_TYPE_NVME": 3,
        "MEMORY_TYPE_SPINOR": 4,
        "MEMORY_TYPE_UNKNOWN": 5,
    }


class ValidationMode(object):
    VALIDATION_MODE_NONE = 0
    VALIDATION_MODE_BINARY_READBACK = 1
    VALIDATION_MODE_SHA256_READBACK = 2
    VALIDATION_MODE_BINARY_READBACK_WITH_DIGESTS_FILE = 3
    VALIDATION_MODE_SHA256_READBACK_WITH_DIGESTS_FILE = 4

    _VALUES_TO_NAMES = {
        0: "VALIDATION_MODE_NONE",
        1: "VALIDATION_MODE_BINARY_READBACK",
        2: "VALIDATION_MODE_SHA256_READBACK",
        3: "VALIDATION_MODE_BINARY_READBACK_WITH_DIGESTS_FILE",
        4: "VALIDATION_MODE_SHA256_READBACK_WITH_DIGESTS_FILE",
    }

    _NAMES_TO_VALUES = {
        "VALIDATION_MODE_NONE": 0,
        "VALIDATION_MODE_BINARY_READBACK": 1,
        "VALIDATION_MODE_SHA256_READBACK": 2,
        "VALIDATION_MODE_BINARY_READBACK_WITH_DIGESTS_FILE": 3,
        "VALIDATION_MODE_SHA256_READBACK_WITH_DIGESTS_FILE": 4,
    }


class PreservationMode(object):
    PRESERVATION_NONE = 0
    PRESERVATION_BACKUP_RESTORE = 1

    _VALUES_TO_NAMES = {
        0: "PRESERVATION_NONE",
        1: "PRESERVATION_BACKUP_RESTORE",
    }

    _NAMES_TO_VALUES = {
        "PRESERVATION_NONE": 0,
        "PRESERVATION_BACKUP_RESTORE": 1,
    }


class DigestHeaderType(object):
    DIGEST_HEADER_TYPE_NONE = 0
    DIGEST_HEADER_TYPE_ELF = 1
    DIGEST_HEADER_TYPE_MBN = 2

    _VALUES_TO_NAMES = {
        0: "DIGEST_HEADER_TYPE_NONE",
        1: "DIGEST_HEADER_TYPE_ELF",
        2: "DIGEST_HEADER_TYPE_MBN",
    }

    _NAMES_TO_VALUES = {
        "DIGEST_HEADER_TYPE_NONE": 0,
        "DIGEST_HEADER_TYPE_ELF": 1,
        "DIGEST_HEADER_TYPE_MBN": 2,
    }


class EdlDeviceInfo(object):
    """
    Attributes:
     - serialNumber
     - msmHwId

    """


    def __init__(self, serialNumber=None, msmHwId=None,):
        self.serialNumber = serialNumber
        self.msmHwId = msmHwId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.serialNumber = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.msmHwId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EdlDeviceInfo')
        if self.serialNumber is not None:
            oprot.writeFieldBegin('serialNumber', TType.STRING, 1)
            oprot.writeString(self.serialNumber.encode('utf-8') if sys.version_info[0] == 2 else self.serialNumber)
            oprot.writeFieldEnd()
        if self.msmHwId is not None:
            oprot.writeFieldBegin('msmHwId', TType.STRING, 2)
            oprot.writeString(self.msmHwId.encode('utf-8') if sys.version_info[0] == 2 else self.msmHwId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TransferImageResult(object):
    """
    Attributes:
     - errorCode
     - deviceImageMode

    """


    def __init__(self, errorCode=None, deviceImageMode=None,):
        self.errorCode = errorCode
        self.deviceImageMode = deviceImageMode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.errorCode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.deviceImageMode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TransferImageResult')
        if self.errorCode is not None:
            oprot.writeFieldBegin('errorCode', TType.I32, 1)
            oprot.writeI32(self.errorCode)
            oprot.writeFieldEnd()
        if self.deviceImageMode is not None:
            oprot.writeFieldBegin('deviceImageMode', TType.I32, 2)
            oprot.writeI32(self.deviceImageMode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PreservedPartitionInfo(object):
    """
    Attributes:
     - partitionIndex
     - name

    """


    def __init__(self, partitionIndex=None, name=None,):
        self.partitionIndex = partitionIndex
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.partitionIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PreservedPartitionInfo')
        if self.partitionIndex is not None:
            oprot.writeFieldBegin('partitionIndex', TType.STRING, 1)
            oprot.writeString(self.partitionIndex.encode('utf-8') if sys.version_info[0] == 2 else self.partitionIndex)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PreservationOption(object):
    """
    Attributes:
     - preservationMode
     - preservedPartitions

    """


    def __init__(self, preservationMode=None, preservedPartitions=None,):
        self.preservationMode = preservationMode
        self.preservedPartitions = preservedPartitions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.preservationMode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.preservedPartitions = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = PreservedPartitionInfo()
                        _elem5.read(iprot)
                        self.preservedPartitions.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PreservationOption')
        if self.preservationMode is not None:
            oprot.writeFieldBegin('preservationMode', TType.I32, 1)
            oprot.writeI32(self.preservationMode)
            oprot.writeFieldEnd()
        if self.preservedPartitions is not None:
            oprot.writeFieldBegin('preservedPartitions', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.preservedPartitions))
            for iter6 in self.preservedPartitions:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DownloadBuildOptions(object):
    """
    Attributes:
     - memoryType
     - erase
     - rawXmlList
     - patchXmlList
     - firehoseProgPath
     - signedDigestsPath
     - chainedDigestsPath
     - skipSahara
     - readImagesPath
     - ufsProvisioningPath
     - partitionIndexList
     - jsonPath
     - resetAfterDownload
     - maxPayloadSize
     - readImages
     - validationMode
     - edmaPath
     - preservationOption
     - singleImagePath
     - slot
     - digestHeaderType
     - firehoseInitializeTimeInMs
     - validationDigestsPath
     - activePartition
     - firmwarePath
     - downloadRxTimeoutInMs
     - lun
     - startSector
     - validateImageSize

    """


    def __init__(self, memoryType=None, erase=None, rawXmlList=None, patchXmlList=None, firehoseProgPath=None, signedDigestsPath=None, chainedDigestsPath=None, skipSahara=None, readImagesPath=None, ufsProvisioningPath=None, partitionIndexList=None, jsonPath=None, resetAfterDownload=None, maxPayloadSize=None, readImages=None, validationMode=None, edmaPath=None, preservationOption=None, singleImagePath=None, slot=None, digestHeaderType=None, firehoseInitializeTimeInMs=None, validationDigestsPath=None, activePartition=None, firmwarePath=None, downloadRxTimeoutInMs=None, lun=None, startSector=None, validateImageSize=None,):
        self.memoryType = memoryType
        self.erase = erase
        self.rawXmlList = rawXmlList
        self.patchXmlList = patchXmlList
        self.firehoseProgPath = firehoseProgPath
        self.signedDigestsPath = signedDigestsPath
        self.chainedDigestsPath = chainedDigestsPath
        self.skipSahara = skipSahara
        self.readImagesPath = readImagesPath
        self.ufsProvisioningPath = ufsProvisioningPath
        self.partitionIndexList = partitionIndexList
        self.jsonPath = jsonPath
        self.resetAfterDownload = resetAfterDownload
        self.maxPayloadSize = maxPayloadSize
        self.readImages = readImages
        self.validationMode = validationMode
        self.edmaPath = edmaPath
        self.preservationOption = preservationOption
        self.singleImagePath = singleImagePath
        self.slot = slot
        self.digestHeaderType = digestHeaderType
        self.firehoseInitializeTimeInMs = firehoseInitializeTimeInMs
        self.validationDigestsPath = validationDigestsPath
        self.activePartition = activePartition
        self.firmwarePath = firmwarePath
        self.downloadRxTimeoutInMs = downloadRxTimeoutInMs
        self.lun = lun
        self.startSector = startSector
        self.validateImageSize = validateImageSize

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.memoryType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.erase = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.rawXmlList = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.rawXmlList.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.patchXmlList = []
                    (_etype16, _size13) = iprot.readListBegin()
                    for _i17 in range(_size13):
                        _elem18 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.patchXmlList.append(_elem18)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.firehoseProgPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.signedDigestsPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.chainedDigestsPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.skipSahara = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.readImagesPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.ufsProvisioningPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.LIST:
                    self.partitionIndexList = []
                    (_etype22, _size19) = iprot.readListBegin()
                    for _i23 in range(_size19):
                        _elem24 = iprot.readI32()
                        self.partitionIndexList.append(_elem24)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRING:
                    self.jsonPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.BOOL:
                    self.resetAfterDownload = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I32:
                    self.maxPayloadSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.BOOL:
                    self.readImages = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.I32:
                    self.validationMode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.STRING:
                    self.edmaPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.STRUCT:
                    self.preservationOption = PreservationOption()
                    self.preservationOption.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.STRING:
                    self.singleImagePath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.I32:
                    self.slot = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.I32:
                    self.digestHeaderType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.I32:
                    self.firehoseInitializeTimeInMs = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.STRING:
                    self.validationDigestsPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.I32:
                    self.activePartition = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 25:
                if ftype == TType.STRING:
                    self.firmwarePath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 26:
                if ftype == TType.I32:
                    self.downloadRxTimeoutInMs = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 27:
                if ftype == TType.I32:
                    self.lun = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 28:
                if ftype == TType.I64:
                    self.startSector = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 29:
                if ftype == TType.BOOL:
                    self.validateImageSize = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DownloadBuildOptions')
        if self.memoryType is not None:
            oprot.writeFieldBegin('memoryType', TType.I32, 1)
            oprot.writeI32(self.memoryType)
            oprot.writeFieldEnd()
        if self.erase is not None:
            oprot.writeFieldBegin('erase', TType.BOOL, 2)
            oprot.writeBool(self.erase)
            oprot.writeFieldEnd()
        if self.rawXmlList is not None:
            oprot.writeFieldBegin('rawXmlList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.rawXmlList))
            for iter25 in self.rawXmlList:
                oprot.writeString(iter25.encode('utf-8') if sys.version_info[0] == 2 else iter25)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.patchXmlList is not None:
            oprot.writeFieldBegin('patchXmlList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.patchXmlList))
            for iter26 in self.patchXmlList:
                oprot.writeString(iter26.encode('utf-8') if sys.version_info[0] == 2 else iter26)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.firehoseProgPath is not None:
            oprot.writeFieldBegin('firehoseProgPath', TType.STRING, 5)
            oprot.writeString(self.firehoseProgPath.encode('utf-8') if sys.version_info[0] == 2 else self.firehoseProgPath)
            oprot.writeFieldEnd()
        if self.signedDigestsPath is not None:
            oprot.writeFieldBegin('signedDigestsPath', TType.STRING, 6)
            oprot.writeString(self.signedDigestsPath.encode('utf-8') if sys.version_info[0] == 2 else self.signedDigestsPath)
            oprot.writeFieldEnd()
        if self.chainedDigestsPath is not None:
            oprot.writeFieldBegin('chainedDigestsPath', TType.STRING, 7)
            oprot.writeString(self.chainedDigestsPath.encode('utf-8') if sys.version_info[0] == 2 else self.chainedDigestsPath)
            oprot.writeFieldEnd()
        if self.skipSahara is not None:
            oprot.writeFieldBegin('skipSahara', TType.BOOL, 8)
            oprot.writeBool(self.skipSahara)
            oprot.writeFieldEnd()
        if self.readImagesPath is not None:
            oprot.writeFieldBegin('readImagesPath', TType.STRING, 9)
            oprot.writeString(self.readImagesPath.encode('utf-8') if sys.version_info[0] == 2 else self.readImagesPath)
            oprot.writeFieldEnd()
        if self.ufsProvisioningPath is not None:
            oprot.writeFieldBegin('ufsProvisioningPath', TType.STRING, 10)
            oprot.writeString(self.ufsProvisioningPath.encode('utf-8') if sys.version_info[0] == 2 else self.ufsProvisioningPath)
            oprot.writeFieldEnd()
        if self.partitionIndexList is not None:
            oprot.writeFieldBegin('partitionIndexList', TType.LIST, 11)
            oprot.writeListBegin(TType.I32, len(self.partitionIndexList))
            for iter27 in self.partitionIndexList:
                oprot.writeI32(iter27)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.jsonPath is not None:
            oprot.writeFieldBegin('jsonPath', TType.STRING, 12)
            oprot.writeString(self.jsonPath.encode('utf-8') if sys.version_info[0] == 2 else self.jsonPath)
            oprot.writeFieldEnd()
        if self.resetAfterDownload is not None:
            oprot.writeFieldBegin('resetAfterDownload', TType.BOOL, 13)
            oprot.writeBool(self.resetAfterDownload)
            oprot.writeFieldEnd()
        if self.maxPayloadSize is not None:
            oprot.writeFieldBegin('maxPayloadSize', TType.I32, 14)
            oprot.writeI32(self.maxPayloadSize)
            oprot.writeFieldEnd()
        if self.readImages is not None:
            oprot.writeFieldBegin('readImages', TType.BOOL, 15)
            oprot.writeBool(self.readImages)
            oprot.writeFieldEnd()
        if self.validationMode is not None:
            oprot.writeFieldBegin('validationMode', TType.I32, 16)
            oprot.writeI32(self.validationMode)
            oprot.writeFieldEnd()
        if self.edmaPath is not None:
            oprot.writeFieldBegin('edmaPath', TType.STRING, 17)
            oprot.writeString(self.edmaPath.encode('utf-8') if sys.version_info[0] == 2 else self.edmaPath)
            oprot.writeFieldEnd()
        if self.preservationOption is not None:
            oprot.writeFieldBegin('preservationOption', TType.STRUCT, 18)
            self.preservationOption.write(oprot)
            oprot.writeFieldEnd()
        if self.singleImagePath is not None:
            oprot.writeFieldBegin('singleImagePath', TType.STRING, 19)
            oprot.writeString(self.singleImagePath.encode('utf-8') if sys.version_info[0] == 2 else self.singleImagePath)
            oprot.writeFieldEnd()
        if self.slot is not None:
            oprot.writeFieldBegin('slot', TType.I32, 20)
            oprot.writeI32(self.slot)
            oprot.writeFieldEnd()
        if self.digestHeaderType is not None:
            oprot.writeFieldBegin('digestHeaderType', TType.I32, 21)
            oprot.writeI32(self.digestHeaderType)
            oprot.writeFieldEnd()
        if self.firehoseInitializeTimeInMs is not None:
            oprot.writeFieldBegin('firehoseInitializeTimeInMs', TType.I32, 22)
            oprot.writeI32(self.firehoseInitializeTimeInMs)
            oprot.writeFieldEnd()
        if self.validationDigestsPath is not None:
            oprot.writeFieldBegin('validationDigestsPath', TType.STRING, 23)
            oprot.writeString(self.validationDigestsPath.encode('utf-8') if sys.version_info[0] == 2 else self.validationDigestsPath)
            oprot.writeFieldEnd()
        if self.activePartition is not None:
            oprot.writeFieldBegin('activePartition', TType.I32, 24)
            oprot.writeI32(self.activePartition)
            oprot.writeFieldEnd()
        if self.firmwarePath is not None:
            oprot.writeFieldBegin('firmwarePath', TType.STRING, 25)
            oprot.writeString(self.firmwarePath.encode('utf-8') if sys.version_info[0] == 2 else self.firmwarePath)
            oprot.writeFieldEnd()
        if self.downloadRxTimeoutInMs is not None:
            oprot.writeFieldBegin('downloadRxTimeoutInMs', TType.I32, 26)
            oprot.writeI32(self.downloadRxTimeoutInMs)
            oprot.writeFieldEnd()
        if self.lun is not None:
            oprot.writeFieldBegin('lun', TType.I32, 27)
            oprot.writeI32(self.lun)
            oprot.writeFieldEnd()
        if self.startSector is not None:
            oprot.writeFieldBegin('startSector', TType.I64, 28)
            oprot.writeI64(self.startSector)
            oprot.writeFieldEnd()
        if self.validateImageSize is not None:
            oprot.writeFieldBegin('validateImageSize', TType.BOOL, 29)
            oprot.writeBool(self.validateImageSize)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PartitionInfo(object):
    """
    Attributes:
     - lun
     - name
     - partitionTypeGuid
     - uniquePartitionGuid
     - startingLba
     - endingLba
     - attributes

    """


    def __init__(self, lun=None, name=None, partitionTypeGuid=None, uniquePartitionGuid=None, startingLba=None, endingLba=None, attributes=None,):
        self.lun = lun
        self.name = name
        self.partitionTypeGuid = partitionTypeGuid
        self.uniquePartitionGuid = uniquePartitionGuid
        self.startingLba = startingLba
        self.endingLba = endingLba
        self.attributes = attributes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.lun = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.partitionTypeGuid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.uniquePartitionGuid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.startingLba = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.endingLba = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.attributes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PartitionInfo')
        if self.lun is not None:
            oprot.writeFieldBegin('lun', TType.I32, 1)
            oprot.writeI32(self.lun)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.partitionTypeGuid is not None:
            oprot.writeFieldBegin('partitionTypeGuid', TType.STRING, 3)
            oprot.writeString(self.partitionTypeGuid.encode('utf-8') if sys.version_info[0] == 2 else self.partitionTypeGuid)
            oprot.writeFieldEnd()
        if self.uniquePartitionGuid is not None:
            oprot.writeFieldBegin('uniquePartitionGuid', TType.STRING, 4)
            oprot.writeString(self.uniquePartitionGuid.encode('utf-8') if sys.version_info[0] == 2 else self.uniquePartitionGuid)
            oprot.writeFieldEnd()
        if self.startingLba is not None:
            oprot.writeFieldBegin('startingLba', TType.I64, 5)
            oprot.writeI64(self.startingLba)
            oprot.writeFieldEnd()
        if self.endingLba is not None:
            oprot.writeFieldBegin('endingLba', TType.I64, 6)
            oprot.writeI64(self.endingLba)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.I64, 7)
            oprot.writeI64(self.attributes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FlashInfo(object):
    """
    Attributes:
     - totalBlocks
     - blockSize
     - pageSize
     - numPhysicalPartitions
     - manufacturerId
     - serialNum
     - fwVersion
     - memType
     - prodName

    """


    def __init__(self, totalBlocks=None, blockSize=None, pageSize=None, numPhysicalPartitions=None, manufacturerId=None, serialNum=None, fwVersion=None, memType=None, prodName=None,):
        self.totalBlocks = totalBlocks
        self.blockSize = blockSize
        self.pageSize = pageSize
        self.numPhysicalPartitions = numPhysicalPartitions
        self.manufacturerId = manufacturerId
        self.serialNum = serialNum
        self.fwVersion = fwVersion
        self.memType = memType
        self.prodName = prodName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.totalBlocks = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.blockSize = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.pageSize = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.numPhysicalPartitions = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.manufacturerId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.serialNum = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.fwVersion = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.memType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.prodName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FlashInfo')
        if self.totalBlocks is not None:
            oprot.writeFieldBegin('totalBlocks', TType.STRING, 1)
            oprot.writeString(self.totalBlocks.encode('utf-8') if sys.version_info[0] == 2 else self.totalBlocks)
            oprot.writeFieldEnd()
        if self.blockSize is not None:
            oprot.writeFieldBegin('blockSize', TType.STRING, 2)
            oprot.writeString(self.blockSize.encode('utf-8') if sys.version_info[0] == 2 else self.blockSize)
            oprot.writeFieldEnd()
        if self.pageSize is not None:
            oprot.writeFieldBegin('pageSize', TType.STRING, 3)
            oprot.writeString(self.pageSize.encode('utf-8') if sys.version_info[0] == 2 else self.pageSize)
            oprot.writeFieldEnd()
        if self.numPhysicalPartitions is not None:
            oprot.writeFieldBegin('numPhysicalPartitions', TType.STRING, 4)
            oprot.writeString(self.numPhysicalPartitions.encode('utf-8') if sys.version_info[0] == 2 else self.numPhysicalPartitions)
            oprot.writeFieldEnd()
        if self.manufacturerId is not None:
            oprot.writeFieldBegin('manufacturerId', TType.STRING, 5)
            oprot.writeString(self.manufacturerId.encode('utf-8') if sys.version_info[0] == 2 else self.manufacturerId)
            oprot.writeFieldEnd()
        if self.serialNum is not None:
            oprot.writeFieldBegin('serialNum', TType.STRING, 6)
            oprot.writeString(self.serialNum.encode('utf-8') if sys.version_info[0] == 2 else self.serialNum)
            oprot.writeFieldEnd()
        if self.fwVersion is not None:
            oprot.writeFieldBegin('fwVersion', TType.STRING, 7)
            oprot.writeString(self.fwVersion.encode('utf-8') if sys.version_info[0] == 2 else self.fwVersion)
            oprot.writeFieldEnd()
        if self.memType is not None:
            oprot.writeFieldBegin('memType', TType.STRING, 8)
            oprot.writeString(self.memType.encode('utf-8') if sys.version_info[0] == 2 else self.memType)
            oprot.writeFieldEnd()
        if self.prodName is not None:
            oprot.writeFieldBegin('prodName', TType.STRING, 9)
            oprot.writeString(self.prodName.encode('utf-8') if sys.version_info[0] == 2 else self.prodName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DataChunkOptions(object):
    """
    Attributes:
     - partitionIndex
     - startSector
     - sectorCount
     - imagePath

    """


    def __init__(self, partitionIndex=None, startSector=None, sectorCount=None, imagePath=None,):
        self.partitionIndex = partitionIndex
        self.startSector = startSector
        self.sectorCount = sectorCount
        self.imagePath = imagePath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.partitionIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.startSector = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.sectorCount = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.imagePath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DataChunkOptions')
        if self.partitionIndex is not None:
            oprot.writeFieldBegin('partitionIndex', TType.I32, 1)
            oprot.writeI32(self.partitionIndex)
            oprot.writeFieldEnd()
        if self.startSector is not None:
            oprot.writeFieldBegin('startSector', TType.STRING, 2)
            oprot.writeString(self.startSector.encode('utf-8') if sys.version_info[0] == 2 else self.startSector)
            oprot.writeFieldEnd()
        if self.sectorCount is not None:
            oprot.writeFieldBegin('sectorCount', TType.STRING, 3)
            oprot.writeString(self.sectorCount.encode('utf-8') if sys.version_info[0] == 2 else self.sectorCount)
            oprot.writeFieldEnd()
        if self.imagePath is not None:
            oprot.writeFieldBegin('imagePath', TType.STRING, 4)
            oprot.writeString(self.imagePath.encode('utf-8') if sys.version_info[0] == 2 else self.imagePath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MemoryDumpOptions(object):
    """
    Attributes:
     - pathName
     - sectionNameList

    """


    def __init__(self, pathName=None, sectionNameList=None,):
        self.pathName = pathName
        self.sectionNameList = sectionNameList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.sectionNameList = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.sectionNameList.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MemoryDumpOptions')
        if self.pathName is not None:
            oprot.writeFieldBegin('pathName', TType.STRING, 1)
            oprot.writeString(self.pathName.encode('utf-8') if sys.version_info[0] == 2 else self.pathName)
            oprot.writeFieldEnd()
        if self.sectionNameList is not None:
            oprot.writeFieldBegin('sectionNameList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.sectionNameList))
            for iter34 in self.sectionNameList:
                oprot.writeString(iter34.encode('utf-8') if sys.version_info[0] == 2 else iter34)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EdlDeviceInfo)
EdlDeviceInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'serialNumber', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'msmHwId', 'UTF8', None, ),  # 2
)
all_structs.append(TransferImageResult)
TransferImageResult.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'errorCode', None, None, ),  # 1
    (2, TType.I32, 'deviceImageMode', None, None, ),  # 2
)
all_structs.append(PreservedPartitionInfo)
PreservedPartitionInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'partitionIndex', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
)
all_structs.append(PreservationOption)
PreservationOption.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'preservationMode', None, None, ),  # 1
    (2, TType.LIST, 'preservedPartitions', (TType.STRUCT, [PreservedPartitionInfo, None], False), None, ),  # 2
)
all_structs.append(DownloadBuildOptions)
DownloadBuildOptions.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'memoryType', None, None, ),  # 1
    (2, TType.BOOL, 'erase', None, None, ),  # 2
    (3, TType.LIST, 'rawXmlList', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'patchXmlList', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.STRING, 'firehoseProgPath', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'signedDigestsPath', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'chainedDigestsPath', 'UTF8', None, ),  # 7
    (8, TType.BOOL, 'skipSahara', None, None, ),  # 8
    (9, TType.STRING, 'readImagesPath', 'UTF8', None, ),  # 9
    (10, TType.STRING, 'ufsProvisioningPath', 'UTF8', None, ),  # 10
    (11, TType.LIST, 'partitionIndexList', (TType.I32, None, False), None, ),  # 11
    (12, TType.STRING, 'jsonPath', 'UTF8', None, ),  # 12
    (13, TType.BOOL, 'resetAfterDownload', None, None, ),  # 13
    (14, TType.I32, 'maxPayloadSize', None, None, ),  # 14
    (15, TType.BOOL, 'readImages', None, None, ),  # 15
    (16, TType.I32, 'validationMode', None, None, ),  # 16
    (17, TType.STRING, 'edmaPath', 'UTF8', None, ),  # 17
    (18, TType.STRUCT, 'preservationOption', [PreservationOption, None], None, ),  # 18
    (19, TType.STRING, 'singleImagePath', 'UTF8', None, ),  # 19
    (20, TType.I32, 'slot', None, None, ),  # 20
    (21, TType.I32, 'digestHeaderType', None, None, ),  # 21
    (22, TType.I32, 'firehoseInitializeTimeInMs', None, None, ),  # 22
    (23, TType.STRING, 'validationDigestsPath', 'UTF8', None, ),  # 23
    (24, TType.I32, 'activePartition', None, None, ),  # 24
    (25, TType.STRING, 'firmwarePath', 'UTF8', None, ),  # 25
    (26, TType.I32, 'downloadRxTimeoutInMs', None, None, ),  # 26
    (27, TType.I32, 'lun', None, None, ),  # 27
    (28, TType.I64, 'startSector', None, None, ),  # 28
    (29, TType.BOOL, 'validateImageSize', None, None, ),  # 29
)
all_structs.append(PartitionInfo)
PartitionInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'lun', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'partitionTypeGuid', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'uniquePartitionGuid', 'UTF8', None, ),  # 4
    (5, TType.I64, 'startingLba', None, None, ),  # 5
    (6, TType.I64, 'endingLba', None, None, ),  # 6
    (7, TType.I64, 'attributes', None, None, ),  # 7
)
all_structs.append(FlashInfo)
FlashInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'totalBlocks', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'blockSize', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'pageSize', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'numPhysicalPartitions', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'manufacturerId', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'serialNum', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'fwVersion', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'memType', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'prodName', 'UTF8', None, ),  # 9
)
all_structs.append(DataChunkOptions)
DataChunkOptions.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'partitionIndex', None, None, ),  # 1
    (2, TType.STRING, 'startSector', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'sectorCount', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'imagePath', 'UTF8', None, ),  # 4
)
all_structs.append(MemoryDumpOptions)
MemoryDumpOptions.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathName', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'sectionNameList', (TType.STRING, 'UTF8', False), None, ),  # 2
)
fix_spec(all_structs)
del all_structs
