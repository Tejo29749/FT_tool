#!/usr/bin/env python
#
# Autogenerated by Thrift Compiler (0.14.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

import sys
import pprint
if sys.version_info[0] > 2:
    from urllib.parse import urlparse
else:
    from urlparse import urlparse
from thrift.transport import TTransport, TSocket, TSSLSocket, THttpClient
from thrift.protocol.TBinaryProtocol import TBinaryProtocol

from ImageManagementService import ImageManagementService
from ImageManagementService.ttypes import *

if len(sys.argv) <= 1 or sys.argv[1] == '--help':
    print('')
    print('Usage: ' + sys.argv[0] + ' [-h host[:port]] [-u url] [-f[ramed]] [-s[sl]] [-novalidate] [-ca_certs certs] [-keyfile keyfile] [-certfile certfile] function [arg1 [arg2...]]')
    print('')
    print('Functions:')
    print('  ErrorType getLastError()')
    print('  ErrorCode initializeService()')
    print('  ErrorCode destroyService()')
    print('  DeviceImageMode getDeviceImageMode()')
    print('  TransferImageResult transferImages( imageList)')
    print('  EdlDeviceInfo getDeviceInfo()')
    print('  ErrorCode collectPblDumpV3(string pathName)')
    print('  ErrorCode downloadBuild(string buildPath, DownloadBuildOptions options)')
    print('  ErrorCode collectMemoryDump(string pathName)')
    print('  ErrorCode collectMemoryDumpWithOptions(MemoryDumpOptions options)')
    print('  ErrorCode startRemoteEfsSync(string pathName)')
    print('  ErrorCode stopRemoteEfsSync()')
    print('  ErrorCode setDdrStorePath(string ddrStorePath)')
    print('  ErrorCode resetDevice(i32 timeout)')
    print('  ErrorCode switchToEdl()')
    print('  ErrorCode switchToMemoryDebug()')
    print('  ErrorCode erasePartition(DownloadBuildOptions options)')
    print('   getFlashInfo(DownloadBuildOptions options)')
    print('   initPartitionTable(DownloadBuildOptions options)')
    print('  ErrorCode readPartitionData( dataChunks)')
    print('  ErrorCode writePartitionData( dataChunks)')
    print('  ErrorCode erasePartitionData( dataChunks)')
    print('')
    sys.exit(0)

pp = pprint.PrettyPrinter(indent=2)
host = 'localhost'
port = 9090
uri = ''
framed = False
ssl = False
validate = True
ca_certs = None
keyfile = None
certfile = None
http = False
argi = 1

if sys.argv[argi] == '-h':
    parts = sys.argv[argi + 1].split(':')
    host = parts[0]
    if len(parts) > 1:
        port = int(parts[1])
    argi += 2

if sys.argv[argi] == '-u':
    url = urlparse(sys.argv[argi + 1])
    parts = url[1].split(':')
    host = parts[0]
    if len(parts) > 1:
        port = int(parts[1])
    else:
        port = 80
    uri = url[2]
    if url[4]:
        uri += '?%s' % url[4]
    http = True
    argi += 2

if sys.argv[argi] == '-f' or sys.argv[argi] == '-framed':
    framed = True
    argi += 1

if sys.argv[argi] == '-s' or sys.argv[argi] == '-ssl':
    ssl = True
    argi += 1

if sys.argv[argi] == '-novalidate':
    validate = False
    argi += 1

if sys.argv[argi] == '-ca_certs':
    ca_certs = sys.argv[argi+1]
    argi += 2

if sys.argv[argi] == '-keyfile':
    keyfile = sys.argv[argi+1]
    argi += 2

if sys.argv[argi] == '-certfile':
    certfile = sys.argv[argi+1]
    argi += 2

cmd = sys.argv[argi]
args = sys.argv[argi + 1:]

if http:
    transport = THttpClient.THttpClient(host, port, uri)
else:
    if ssl:
        socket = TSSLSocket.TSSLSocket(host, port, validate=validate, ca_certs=ca_certs, keyfile=keyfile, certfile=certfile)
    else:
        socket = TSocket.TSocket(host, port)
    if framed:
        transport = TTransport.TFramedTransport(socket)
    else:
        transport = TTransport.TBufferedTransport(socket)
protocol = TBinaryProtocol(transport)
client = ImageManagementService.Client(protocol)
transport.open()

if cmd == 'getLastError':
    if len(args) != 0:
        print('getLastError requires 0 args')
        sys.exit(1)
    pp.pprint(client.getLastError())

elif cmd == 'initializeService':
    if len(args) != 0:
        print('initializeService requires 0 args')
        sys.exit(1)
    pp.pprint(client.initializeService())

elif cmd == 'destroyService':
    if len(args) != 0:
        print('destroyService requires 0 args')
        sys.exit(1)
    pp.pprint(client.destroyService())

elif cmd == 'getDeviceImageMode':
    if len(args) != 0:
        print('getDeviceImageMode requires 0 args')
        sys.exit(1)
    pp.pprint(client.getDeviceImageMode())

elif cmd == 'transferImages':
    if len(args) != 1:
        print('transferImages requires 1 args')
        sys.exit(1)
    pp.pprint(client.transferImages(eval(args[0]),))

elif cmd == 'getDeviceInfo':
    if len(args) != 0:
        print('getDeviceInfo requires 0 args')
        sys.exit(1)
    pp.pprint(client.getDeviceInfo())

elif cmd == 'collectPblDumpV3':
    if len(args) != 1:
        print('collectPblDumpV3 requires 1 args')
        sys.exit(1)
    pp.pprint(client.collectPblDumpV3(args[0],))

elif cmd == 'downloadBuild':
    if len(args) != 2:
        print('downloadBuild requires 2 args')
        sys.exit(1)
    pp.pprint(client.downloadBuild(args[0], eval(args[1]),))

elif cmd == 'collectMemoryDump':
    if len(args) != 1:
        print('collectMemoryDump requires 1 args')
        sys.exit(1)
    pp.pprint(client.collectMemoryDump(args[0],))

elif cmd == 'collectMemoryDumpWithOptions':
    if len(args) != 1:
        print('collectMemoryDumpWithOptions requires 1 args')
        sys.exit(1)
    pp.pprint(client.collectMemoryDumpWithOptions(eval(args[0]),))

elif cmd == 'startRemoteEfsSync':
    if len(args) != 1:
        print('startRemoteEfsSync requires 1 args')
        sys.exit(1)
    pp.pprint(client.startRemoteEfsSync(args[0],))

elif cmd == 'stopRemoteEfsSync':
    if len(args) != 0:
        print('stopRemoteEfsSync requires 0 args')
        sys.exit(1)
    pp.pprint(client.stopRemoteEfsSync())

elif cmd == 'setDdrStorePath':
    if len(args) != 1:
        print('setDdrStorePath requires 1 args')
        sys.exit(1)
    pp.pprint(client.setDdrStorePath(args[0],))

elif cmd == 'resetDevice':
    if len(args) != 1:
        print('resetDevice requires 1 args')
        sys.exit(1)
    pp.pprint(client.resetDevice(eval(args[0]),))

elif cmd == 'switchToEdl':
    if len(args) != 0:
        print('switchToEdl requires 0 args')
        sys.exit(1)
    pp.pprint(client.switchToEdl())

elif cmd == 'switchToMemoryDebug':
    if len(args) != 0:
        print('switchToMemoryDebug requires 0 args')
        sys.exit(1)
    pp.pprint(client.switchToMemoryDebug())

elif cmd == 'erasePartition':
    if len(args) != 1:
        print('erasePartition requires 1 args')
        sys.exit(1)
    pp.pprint(client.erasePartition(eval(args[0]),))

elif cmd == 'getFlashInfo':
    if len(args) != 1:
        print('getFlashInfo requires 1 args')
        sys.exit(1)
    pp.pprint(client.getFlashInfo(eval(args[0]),))

elif cmd == 'initPartitionTable':
    if len(args) != 1:
        print('initPartitionTable requires 1 args')
        sys.exit(1)
    pp.pprint(client.initPartitionTable(eval(args[0]),))

elif cmd == 'readPartitionData':
    if len(args) != 1:
        print('readPartitionData requires 1 args')
        sys.exit(1)
    pp.pprint(client.readPartitionData(eval(args[0]),))

elif cmd == 'writePartitionData':
    if len(args) != 1:
        print('writePartitionData requires 1 args')
        sys.exit(1)
    pp.pprint(client.writePartitionData(eval(args[0]),))

elif cmd == 'erasePartitionData':
    if len(args) != 1:
        print('erasePartitionData requires 1 args')
        sys.exit(1)
    pp.pprint(client.erasePartitionData(eval(args[0]),))

else:
    print('Unrecognized method %s' % cmd)
    sys.exit(1)

transport.close()
