#
# Autogenerated by Thrift Compiler (0.14.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def getLastError(self):
        pass

    def getServicesList(self):
        pass

    def getDevicesForService(self, serviceName):
        """
        Parameters:
         - serviceName

        """
        pass

    def getServicesForDevice(self, deviceHandle):
        """
        Parameters:
         - deviceHandle

        """
        pass

    def createService(self, serviceName, deviceHandle):
        """
        Parameters:
         - serviceName
         - deviceHandle

        """
        pass

    def createLogSessionService(self, serviceName, logSession, deviceHandle):
        """
        Parameters:
         - serviceName
         - logSession
         - deviceHandle

        """
        pass

    def getDeviceList(self):
        pass

    def getDeviceHandleFromProtocol(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        pass

    def mergeDevice(self, sourceDeviceHandle, destinationDeviceHandle):
        """
        Parameters:
         - sourceDeviceHandle
         - destinationDeviceHandle

        """
        pass

    def getDeviceBuildId(self, deviceHandle):
        """
        Parameters:
         - deviceHandle

        """
        pass

    def getDeviceImageInfoByProtocol(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        pass

    def getChipName(self, deviceHandle, protocolHandle):
        """
        Parameters:
         - deviceHandle
         - protocolHandle

        """
        pass

    def getDeviceMode(self, deviceHandle):
        """
        Parameters:
         - deviceHandle

        """
        pass

    def getProtocolList(self, deviceHandle):
        """
        Parameters:
         - deviceHandle

        """
        pass

    def getActiveLogSession(self):
        pass

    def removeDevice(self, deviceHandle):
        """
        Parameters:
         - deviceHandle

        """
        pass

    def overrideUnknownProtocol(self, protocolHandle, newType):
        """
        Parameters:
         - protocolHandle
         - newType

        """
        pass

    def addTcpConnection(self, deviceHandle, protocolType, bIsClient, description, host, port):
        """
        Parameters:
         - deviceHandle
         - protocolType
         - bIsClient
         - description
         - host
         - port

        """
        pass

    def addTcpConnectionWithOptions(self, host, port, options):
        """
        Parameters:
         - host
         - port
         - options

        """
        pass

    def removeTcpConnection(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        pass

    def startTcpServer(self, protocolType, port):
        """
        Parameters:
         - protocolType
         - port

        """
        pass

    def startTcpServerWithOptions(self, port, options):
        """
        Parameters:
         - port
         - options

        """
        pass

    def stopTcpServer(self, port):
        """
        Parameters:
         - port

        """
        pass

    def getTcpServerList(self):
        pass

    def startLogging(self):
        pass

    def resetLogFiles(self):
        pass

    def saveLogFiles(self, saveFolder):
        """
        Parameters:
         - saveFolder

        """
        pass

    def saveLogFilesWithFilenames(self, logNameConfig):
        """
        Parameters:
         - logNameConfig

        """
        pass

    def saveLogFilesWithSettings(self, saveLogFileSettings):
        """
        Parameters:
         - saveLogFileSettings

        """
        pass

    def getCurrentLogFileSize(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        pass

    def openLogSession(self, logFiles):
        """
        Parameters:
         - logFiles

        """
        pass

    def openLogSessionWithAdvanceOptions(self, logFiles, openFileOptions):
        """
        Parameters:
         - logFiles
         - openFileOptions

        """
        pass

    def openLogSessionWithOptions(self, openFileOptions):
        """
        Parameters:
         - openFileOptions

        """
        pass

    def mergeLogFiles(self, logFiles, destinationFolder, saveFileName, bUseDiagTimestamp):
        """
        Parameters:
         - logFiles
         - destinationFolder
         - saveFileName
         - bUseDiagTimestamp

        """
        pass

    def attachToLogSession(self, clientId, logSession):
        """
        Parameters:
         - clientId
         - logSession

        """
        pass

    def logAnnotation(self, annotation, messageId, protocolHandle):
        """
        Parameters:
         - annotation
         - messageId
         - protocolHandle

        """
        pass

    def resetPhone(self, deviceHandle, resetTimeout):
        """
        Parameters:
         - deviceHandle
         - resetTimeout

        """
        pass

    def resetPhoneByProtocol(self, deviceHandle, protocolHandle, resetTimeout):
        """
        Parameters:
         - deviceHandle
         - protocolHandle
         - resetTimeout

        """
        pass

    def restartQmiReadyScan(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        pass

    def setOperatingMode(self, deviceHandle, protocolHandle, mode):
        """
        Parameters:
         - deviceHandle
         - protocolHandle
         - mode

        """
        pass

    def getThroughputStatistics(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        pass

    def getEsn(self, deviceHandle, protocolHandle):
        """
        Parameters:
         - deviceHandle
         - protocolHandle

        """
        pass

    def setEsn(self, deviceHandle, protocolHandle, esn):
        """
        Parameters:
         - deviceHandle
         - protocolHandle
         - esn

        """
        pass

    def getImei(self, deviceHandle, protocolHandle, subscriptionId):
        """
        Parameters:
         - deviceHandle
         - protocolHandle
         - subscriptionId

        """
        pass

    def setImei(self, deviceHandle, protocolHandle, imei, subscriptionId):
        """
        Parameters:
         - deviceHandle
         - protocolHandle
         - imei
         - subscriptionId

        """
        pass

    def getMeid(self, deviceHandle, protocolHandle, subscriptionId):
        """
        Parameters:
         - deviceHandle
         - protocolHandle
         - subscriptionId

        """
        pass

    def setMeid(self, deviceHandle, protocolHandle, meid, subscriptionId):
        """
        Parameters:
         - deviceHandle
         - protocolHandle
         - meid
         - subscriptionId

        """
        pass

    def checkSpc(self, deviceHandle, protocolHandle, spc):
        """
        Parameters:
         - deviceHandle
         - protocolHandle
         - spc

        """
        pass

    def getOperatingMode(self, deviceHandle, protocolHandle):
        """
        Parameters:
         - deviceHandle
         - protocolHandle

        """
        pass

    def transferImageBhi(self, programmerPath):
        """
        Parameters:
         - programmerPath

        """
        pass

    def transferFileToDevice(self, hostPath, devicePath, options):
        """
        Parameters:
         - hostPath
         - devicePath
         - options

        """
        pass

    def transferFileToHost(self, devicePath, hostPath, options):
        """
        Parameters:
         - devicePath
         - hostPath
         - options

        """
        pass

    def getFileListFromDevice(self, devicePath, options):
        """
        Parameters:
         - devicePath
         - options

        """
        pass

    def getProtocolLockStatus(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        pass

    def getDeviceUsageIndicators(self, deviceHandle):
        """
        Parameters:
         - deviceHandle

        """
        pass

    def enableFunctionLog(self, deviceHandle, areas, options):
        """
        Parameters:
         - deviceHandle
         - areas
         - options

        """
        pass

    def disableFunctionLog(self, deviceHandle, areas):
        """
        Parameters:
         - deviceHandle
         - areas

        """
        pass

    def enableProtocolLog(self, protocolHandle, options):
        """
        Parameters:
         - protocolHandle
         - options

        """
        pass

    def disableProtocolLog(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        pass

    def configureProtocol(self, protocolConfiguration):
        """
        Parameters:
         - protocolConfiguration

        """
        pass

    def getProtocolConfiguration(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        pass

    def enableProtocolDataMonitoring(self, protocolHandleList, enable):
        """
        Parameters:
         - protocolHandleList
         - enable

        """
        pass

    def enableDeviceDataMonitoring(self, deviceHandleList, enable):
        """
        Parameters:
         - deviceHandleList
         - enable

        """
        pass

    def enableDevicePriority(self, deviceHandleList, enable):
        """
        Parameters:
         - deviceHandleList
         - enable

        """
        pass

    def configParameter(self, name, value):
        """
        Parameters:
         - name
         - value

        """
        pass

    def getRegistrationPort(self):
        pass

    def exitQutsApplication(self):
        pass

    def lockService(self, lockInfo):
        """
        Parameters:
         - lockInfo

        """
        pass

    def unlockService(self, lockInfo):
        """
        Parameters:
         - lockInfo

        """
        pass

    def getServiceLockInfo(self, lockInfo):
        """
        Parameters:
         - lockInfo

        """
        pass

    def configLogOptions(self, status, logOptions):
        """
        Parameters:
         - status
         - logOptions

        """
        pass

    def getDeviceQdssConfiguration(self, queryQdssInformation):
        """
        Parameters:
         - queryQdssInformation

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def getLastError(self):
        self.send_getLastError()
        return self.recv_getLastError()

    def send_getLastError(self):
        self._oprot.writeMessageBegin('getLastError', TMessageType.CALL, self._seqid)
        args = getLastError_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getLastError(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getLastError_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getLastError failed: unknown result")

    def getServicesList(self):
        self.send_getServicesList()
        return self.recv_getServicesList()

    def send_getServicesList(self):
        self._oprot.writeMessageBegin('getServicesList', TMessageType.CALL, self._seqid)
        args = getServicesList_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getServicesList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getServicesList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getServicesList failed: unknown result")

    def getDevicesForService(self, serviceName):
        """
        Parameters:
         - serviceName

        """
        self.send_getDevicesForService(serviceName)
        return self.recv_getDevicesForService()

    def send_getDevicesForService(self, serviceName):
        self._oprot.writeMessageBegin('getDevicesForService', TMessageType.CALL, self._seqid)
        args = getDevicesForService_args()
        args.serviceName = serviceName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDevicesForService(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDevicesForService_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDevicesForService failed: unknown result")

    def getServicesForDevice(self, deviceHandle):
        """
        Parameters:
         - deviceHandle

        """
        self.send_getServicesForDevice(deviceHandle)
        return self.recv_getServicesForDevice()

    def send_getServicesForDevice(self, deviceHandle):
        self._oprot.writeMessageBegin('getServicesForDevice', TMessageType.CALL, self._seqid)
        args = getServicesForDevice_args()
        args.deviceHandle = deviceHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getServicesForDevice(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getServicesForDevice_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getServicesForDevice failed: unknown result")

    def createService(self, serviceName, deviceHandle):
        """
        Parameters:
         - serviceName
         - deviceHandle

        """
        self.send_createService(serviceName, deviceHandle)
        return self.recv_createService()

    def send_createService(self, serviceName, deviceHandle):
        self._oprot.writeMessageBegin('createService', TMessageType.CALL, self._seqid)
        args = createService_args()
        args.serviceName = serviceName
        args.deviceHandle = deviceHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createService(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createService_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createService failed: unknown result")

    def createLogSessionService(self, serviceName, logSession, deviceHandle):
        """
        Parameters:
         - serviceName
         - logSession
         - deviceHandle

        """
        self.send_createLogSessionService(serviceName, logSession, deviceHandle)
        return self.recv_createLogSessionService()

    def send_createLogSessionService(self, serviceName, logSession, deviceHandle):
        self._oprot.writeMessageBegin('createLogSessionService', TMessageType.CALL, self._seqid)
        args = createLogSessionService_args()
        args.serviceName = serviceName
        args.logSession = logSession
        args.deviceHandle = deviceHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createLogSessionService(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createLogSessionService_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createLogSessionService failed: unknown result")

    def getDeviceList(self):
        self.send_getDeviceList()
        return self.recv_getDeviceList()

    def send_getDeviceList(self):
        self._oprot.writeMessageBegin('getDeviceList', TMessageType.CALL, self._seqid)
        args = getDeviceList_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDeviceList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDeviceList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDeviceList failed: unknown result")

    def getDeviceHandleFromProtocol(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        self.send_getDeviceHandleFromProtocol(protocolHandle)
        return self.recv_getDeviceHandleFromProtocol()

    def send_getDeviceHandleFromProtocol(self, protocolHandle):
        self._oprot.writeMessageBegin('getDeviceHandleFromProtocol', TMessageType.CALL, self._seqid)
        args = getDeviceHandleFromProtocol_args()
        args.protocolHandle = protocolHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDeviceHandleFromProtocol(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDeviceHandleFromProtocol_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDeviceHandleFromProtocol failed: unknown result")

    def mergeDevice(self, sourceDeviceHandle, destinationDeviceHandle):
        """
        Parameters:
         - sourceDeviceHandle
         - destinationDeviceHandle

        """
        self.send_mergeDevice(sourceDeviceHandle, destinationDeviceHandle)
        return self.recv_mergeDevice()

    def send_mergeDevice(self, sourceDeviceHandle, destinationDeviceHandle):
        self._oprot.writeMessageBegin('mergeDevice', TMessageType.CALL, self._seqid)
        args = mergeDevice_args()
        args.sourceDeviceHandle = sourceDeviceHandle
        args.destinationDeviceHandle = destinationDeviceHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mergeDevice(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mergeDevice_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mergeDevice failed: unknown result")

    def getDeviceBuildId(self, deviceHandle):
        """
        Parameters:
         - deviceHandle

        """
        self.send_getDeviceBuildId(deviceHandle)
        return self.recv_getDeviceBuildId()

    def send_getDeviceBuildId(self, deviceHandle):
        self._oprot.writeMessageBegin('getDeviceBuildId', TMessageType.CALL, self._seqid)
        args = getDeviceBuildId_args()
        args.deviceHandle = deviceHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDeviceBuildId(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDeviceBuildId_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDeviceBuildId failed: unknown result")

    def getDeviceImageInfoByProtocol(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        self.send_getDeviceImageInfoByProtocol(protocolHandle)
        return self.recv_getDeviceImageInfoByProtocol()

    def send_getDeviceImageInfoByProtocol(self, protocolHandle):
        self._oprot.writeMessageBegin('getDeviceImageInfoByProtocol', TMessageType.CALL, self._seqid)
        args = getDeviceImageInfoByProtocol_args()
        args.protocolHandle = protocolHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDeviceImageInfoByProtocol(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDeviceImageInfoByProtocol_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDeviceImageInfoByProtocol failed: unknown result")

    def getChipName(self, deviceHandle, protocolHandle):
        """
        Parameters:
         - deviceHandle
         - protocolHandle

        """
        self.send_getChipName(deviceHandle, protocolHandle)
        return self.recv_getChipName()

    def send_getChipName(self, deviceHandle, protocolHandle):
        self._oprot.writeMessageBegin('getChipName', TMessageType.CALL, self._seqid)
        args = getChipName_args()
        args.deviceHandle = deviceHandle
        args.protocolHandle = protocolHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getChipName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getChipName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getChipName failed: unknown result")

    def getDeviceMode(self, deviceHandle):
        """
        Parameters:
         - deviceHandle

        """
        self.send_getDeviceMode(deviceHandle)
        return self.recv_getDeviceMode()

    def send_getDeviceMode(self, deviceHandle):
        self._oprot.writeMessageBegin('getDeviceMode', TMessageType.CALL, self._seqid)
        args = getDeviceMode_args()
        args.deviceHandle = deviceHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDeviceMode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDeviceMode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDeviceMode failed: unknown result")

    def getProtocolList(self, deviceHandle):
        """
        Parameters:
         - deviceHandle

        """
        self.send_getProtocolList(deviceHandle)
        return self.recv_getProtocolList()

    def send_getProtocolList(self, deviceHandle):
        self._oprot.writeMessageBegin('getProtocolList', TMessageType.CALL, self._seqid)
        args = getProtocolList_args()
        args.deviceHandle = deviceHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getProtocolList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getProtocolList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getProtocolList failed: unknown result")

    def getActiveLogSession(self):
        self.send_getActiveLogSession()
        return self.recv_getActiveLogSession()

    def send_getActiveLogSession(self):
        self._oprot.writeMessageBegin('getActiveLogSession', TMessageType.CALL, self._seqid)
        args = getActiveLogSession_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getActiveLogSession(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getActiveLogSession_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getActiveLogSession failed: unknown result")

    def removeDevice(self, deviceHandle):
        """
        Parameters:
         - deviceHandle

        """
        self.send_removeDevice(deviceHandle)
        return self.recv_removeDevice()

    def send_removeDevice(self, deviceHandle):
        self._oprot.writeMessageBegin('removeDevice', TMessageType.CALL, self._seqid)
        args = removeDevice_args()
        args.deviceHandle = deviceHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeDevice(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeDevice_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "removeDevice failed: unknown result")

    def overrideUnknownProtocol(self, protocolHandle, newType):
        """
        Parameters:
         - protocolHandle
         - newType

        """
        self.send_overrideUnknownProtocol(protocolHandle, newType)
        return self.recv_overrideUnknownProtocol()

    def send_overrideUnknownProtocol(self, protocolHandle, newType):
        self._oprot.writeMessageBegin('overrideUnknownProtocol', TMessageType.CALL, self._seqid)
        args = overrideUnknownProtocol_args()
        args.protocolHandle = protocolHandle
        args.newType = newType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_overrideUnknownProtocol(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = overrideUnknownProtocol_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "overrideUnknownProtocol failed: unknown result")

    def addTcpConnection(self, deviceHandle, protocolType, bIsClient, description, host, port):
        """
        Parameters:
         - deviceHandle
         - protocolType
         - bIsClient
         - description
         - host
         - port

        """
        self.send_addTcpConnection(deviceHandle, protocolType, bIsClient, description, host, port)
        return self.recv_addTcpConnection()

    def send_addTcpConnection(self, deviceHandle, protocolType, bIsClient, description, host, port):
        self._oprot.writeMessageBegin('addTcpConnection', TMessageType.CALL, self._seqid)
        args = addTcpConnection_args()
        args.deviceHandle = deviceHandle
        args.protocolType = protocolType
        args.bIsClient = bIsClient
        args.description = description
        args.host = host
        args.port = port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_addTcpConnection(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = addTcpConnection_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "addTcpConnection failed: unknown result")

    def addTcpConnectionWithOptions(self, host, port, options):
        """
        Parameters:
         - host
         - port
         - options

        """
        self.send_addTcpConnectionWithOptions(host, port, options)
        return self.recv_addTcpConnectionWithOptions()

    def send_addTcpConnectionWithOptions(self, host, port, options):
        self._oprot.writeMessageBegin('addTcpConnectionWithOptions', TMessageType.CALL, self._seqid)
        args = addTcpConnectionWithOptions_args()
        args.host = host
        args.port = port
        args.options = options
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_addTcpConnectionWithOptions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = addTcpConnectionWithOptions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "addTcpConnectionWithOptions failed: unknown result")

    def removeTcpConnection(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        self.send_removeTcpConnection(protocolHandle)
        return self.recv_removeTcpConnection()

    def send_removeTcpConnection(self, protocolHandle):
        self._oprot.writeMessageBegin('removeTcpConnection', TMessageType.CALL, self._seqid)
        args = removeTcpConnection_args()
        args.protocolHandle = protocolHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeTcpConnection(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeTcpConnection_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "removeTcpConnection failed: unknown result")

    def startTcpServer(self, protocolType, port):
        """
        Parameters:
         - protocolType
         - port

        """
        self.send_startTcpServer(protocolType, port)
        return self.recv_startTcpServer()

    def send_startTcpServer(self, protocolType, port):
        self._oprot.writeMessageBegin('startTcpServer', TMessageType.CALL, self._seqid)
        args = startTcpServer_args()
        args.protocolType = protocolType
        args.port = port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_startTcpServer(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = startTcpServer_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "startTcpServer failed: unknown result")

    def startTcpServerWithOptions(self, port, options):
        """
        Parameters:
         - port
         - options

        """
        self.send_startTcpServerWithOptions(port, options)
        return self.recv_startTcpServerWithOptions()

    def send_startTcpServerWithOptions(self, port, options):
        self._oprot.writeMessageBegin('startTcpServerWithOptions', TMessageType.CALL, self._seqid)
        args = startTcpServerWithOptions_args()
        args.port = port
        args.options = options
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_startTcpServerWithOptions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = startTcpServerWithOptions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "startTcpServerWithOptions failed: unknown result")

    def stopTcpServer(self, port):
        """
        Parameters:
         - port

        """
        self.send_stopTcpServer(port)
        return self.recv_stopTcpServer()

    def send_stopTcpServer(self, port):
        self._oprot.writeMessageBegin('stopTcpServer', TMessageType.CALL, self._seqid)
        args = stopTcpServer_args()
        args.port = port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_stopTcpServer(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = stopTcpServer_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "stopTcpServer failed: unknown result")

    def getTcpServerList(self):
        self.send_getTcpServerList()
        return self.recv_getTcpServerList()

    def send_getTcpServerList(self):
        self._oprot.writeMessageBegin('getTcpServerList', TMessageType.CALL, self._seqid)
        args = getTcpServerList_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTcpServerList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTcpServerList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getTcpServerList failed: unknown result")

    def startLogging(self):
        self.send_startLogging()
        return self.recv_startLogging()

    def send_startLogging(self):
        self._oprot.writeMessageBegin('startLogging', TMessageType.CALL, self._seqid)
        args = startLogging_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_startLogging(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = startLogging_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "startLogging failed: unknown result")

    def resetLogFiles(self):
        self.send_resetLogFiles()
        return self.recv_resetLogFiles()

    def send_resetLogFiles(self):
        self._oprot.writeMessageBegin('resetLogFiles', TMessageType.CALL, self._seqid)
        args = resetLogFiles_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_resetLogFiles(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = resetLogFiles_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "resetLogFiles failed: unknown result")

    def saveLogFiles(self, saveFolder):
        """
        Parameters:
         - saveFolder

        """
        self.send_saveLogFiles(saveFolder)
        return self.recv_saveLogFiles()

    def send_saveLogFiles(self, saveFolder):
        self._oprot.writeMessageBegin('saveLogFiles', TMessageType.CALL, self._seqid)
        args = saveLogFiles_args()
        args.saveFolder = saveFolder
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_saveLogFiles(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = saveLogFiles_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "saveLogFiles failed: unknown result")

    def saveLogFilesWithFilenames(self, logNameConfig):
        """
        Parameters:
         - logNameConfig

        """
        self.send_saveLogFilesWithFilenames(logNameConfig)
        return self.recv_saveLogFilesWithFilenames()

    def send_saveLogFilesWithFilenames(self, logNameConfig):
        self._oprot.writeMessageBegin('saveLogFilesWithFilenames', TMessageType.CALL, self._seqid)
        args = saveLogFilesWithFilenames_args()
        args.logNameConfig = logNameConfig
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_saveLogFilesWithFilenames(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = saveLogFilesWithFilenames_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "saveLogFilesWithFilenames failed: unknown result")

    def saveLogFilesWithSettings(self, saveLogFileSettings):
        """
        Parameters:
         - saveLogFileSettings

        """
        self.send_saveLogFilesWithSettings(saveLogFileSettings)
        return self.recv_saveLogFilesWithSettings()

    def send_saveLogFilesWithSettings(self, saveLogFileSettings):
        self._oprot.writeMessageBegin('saveLogFilesWithSettings', TMessageType.CALL, self._seqid)
        args = saveLogFilesWithSettings_args()
        args.saveLogFileSettings = saveLogFileSettings
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_saveLogFilesWithSettings(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = saveLogFilesWithSettings_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "saveLogFilesWithSettings failed: unknown result")

    def getCurrentLogFileSize(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        self.send_getCurrentLogFileSize(protocolHandle)
        return self.recv_getCurrentLogFileSize()

    def send_getCurrentLogFileSize(self, protocolHandle):
        self._oprot.writeMessageBegin('getCurrentLogFileSize', TMessageType.CALL, self._seqid)
        args = getCurrentLogFileSize_args()
        args.protocolHandle = protocolHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCurrentLogFileSize(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCurrentLogFileSize_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCurrentLogFileSize failed: unknown result")

    def openLogSession(self, logFiles):
        """
        Parameters:
         - logFiles

        """
        self.send_openLogSession(logFiles)
        return self.recv_openLogSession()

    def send_openLogSession(self, logFiles):
        self._oprot.writeMessageBegin('openLogSession', TMessageType.CALL, self._seqid)
        args = openLogSession_args()
        args.logFiles = logFiles
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_openLogSession(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = openLogSession_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "openLogSession failed: unknown result")

    def openLogSessionWithAdvanceOptions(self, logFiles, openFileOptions):
        """
        Parameters:
         - logFiles
         - openFileOptions

        """
        self.send_openLogSessionWithAdvanceOptions(logFiles, openFileOptions)
        return self.recv_openLogSessionWithAdvanceOptions()

    def send_openLogSessionWithAdvanceOptions(self, logFiles, openFileOptions):
        self._oprot.writeMessageBegin('openLogSessionWithAdvanceOptions', TMessageType.CALL, self._seqid)
        args = openLogSessionWithAdvanceOptions_args()
        args.logFiles = logFiles
        args.openFileOptions = openFileOptions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_openLogSessionWithAdvanceOptions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = openLogSessionWithAdvanceOptions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "openLogSessionWithAdvanceOptions failed: unknown result")

    def openLogSessionWithOptions(self, openFileOptions):
        """
        Parameters:
         - openFileOptions

        """
        self.send_openLogSessionWithOptions(openFileOptions)
        return self.recv_openLogSessionWithOptions()

    def send_openLogSessionWithOptions(self, openFileOptions):
        self._oprot.writeMessageBegin('openLogSessionWithOptions', TMessageType.CALL, self._seqid)
        args = openLogSessionWithOptions_args()
        args.openFileOptions = openFileOptions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_openLogSessionWithOptions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = openLogSessionWithOptions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "openLogSessionWithOptions failed: unknown result")

    def mergeLogFiles(self, logFiles, destinationFolder, saveFileName, bUseDiagTimestamp):
        """
        Parameters:
         - logFiles
         - destinationFolder
         - saveFileName
         - bUseDiagTimestamp

        """
        self.send_mergeLogFiles(logFiles, destinationFolder, saveFileName, bUseDiagTimestamp)
        return self.recv_mergeLogFiles()

    def send_mergeLogFiles(self, logFiles, destinationFolder, saveFileName, bUseDiagTimestamp):
        self._oprot.writeMessageBegin('mergeLogFiles', TMessageType.CALL, self._seqid)
        args = mergeLogFiles_args()
        args.logFiles = logFiles
        args.destinationFolder = destinationFolder
        args.saveFileName = saveFileName
        args.bUseDiagTimestamp = bUseDiagTimestamp
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mergeLogFiles(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mergeLogFiles_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mergeLogFiles failed: unknown result")

    def attachToLogSession(self, clientId, logSession):
        """
        Parameters:
         - clientId
         - logSession

        """
        self.send_attachToLogSession(clientId, logSession)
        return self.recv_attachToLogSession()

    def send_attachToLogSession(self, clientId, logSession):
        self._oprot.writeMessageBegin('attachToLogSession', TMessageType.CALL, self._seqid)
        args = attachToLogSession_args()
        args.clientId = clientId
        args.logSession = logSession
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_attachToLogSession(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = attachToLogSession_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "attachToLogSession failed: unknown result")

    def logAnnotation(self, annotation, messageId, protocolHandle):
        """
        Parameters:
         - annotation
         - messageId
         - protocolHandle

        """
        self.send_logAnnotation(annotation, messageId, protocolHandle)
        return self.recv_logAnnotation()

    def send_logAnnotation(self, annotation, messageId, protocolHandle):
        self._oprot.writeMessageBegin('logAnnotation', TMessageType.CALL, self._seqid)
        args = logAnnotation_args()
        args.annotation = annotation
        args.messageId = messageId
        args.protocolHandle = protocolHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_logAnnotation(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = logAnnotation_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "logAnnotation failed: unknown result")

    def resetPhone(self, deviceHandle, resetTimeout):
        """
        Parameters:
         - deviceHandle
         - resetTimeout

        """
        self.send_resetPhone(deviceHandle, resetTimeout)
        return self.recv_resetPhone()

    def send_resetPhone(self, deviceHandle, resetTimeout):
        self._oprot.writeMessageBegin('resetPhone', TMessageType.CALL, self._seqid)
        args = resetPhone_args()
        args.deviceHandle = deviceHandle
        args.resetTimeout = resetTimeout
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_resetPhone(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = resetPhone_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "resetPhone failed: unknown result")

    def resetPhoneByProtocol(self, deviceHandle, protocolHandle, resetTimeout):
        """
        Parameters:
         - deviceHandle
         - protocolHandle
         - resetTimeout

        """
        self.send_resetPhoneByProtocol(deviceHandle, protocolHandle, resetTimeout)
        return self.recv_resetPhoneByProtocol()

    def send_resetPhoneByProtocol(self, deviceHandle, protocolHandle, resetTimeout):
        self._oprot.writeMessageBegin('resetPhoneByProtocol', TMessageType.CALL, self._seqid)
        args = resetPhoneByProtocol_args()
        args.deviceHandle = deviceHandle
        args.protocolHandle = protocolHandle
        args.resetTimeout = resetTimeout
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_resetPhoneByProtocol(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = resetPhoneByProtocol_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "resetPhoneByProtocol failed: unknown result")

    def restartQmiReadyScan(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        self.send_restartQmiReadyScan(protocolHandle)
        return self.recv_restartQmiReadyScan()

    def send_restartQmiReadyScan(self, protocolHandle):
        self._oprot.writeMessageBegin('restartQmiReadyScan', TMessageType.CALL, self._seqid)
        args = restartQmiReadyScan_args()
        args.protocolHandle = protocolHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_restartQmiReadyScan(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = restartQmiReadyScan_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "restartQmiReadyScan failed: unknown result")

    def setOperatingMode(self, deviceHandle, protocolHandle, mode):
        """
        Parameters:
         - deviceHandle
         - protocolHandle
         - mode

        """
        self.send_setOperatingMode(deviceHandle, protocolHandle, mode)
        return self.recv_setOperatingMode()

    def send_setOperatingMode(self, deviceHandle, protocolHandle, mode):
        self._oprot.writeMessageBegin('setOperatingMode', TMessageType.CALL, self._seqid)
        args = setOperatingMode_args()
        args.deviceHandle = deviceHandle
        args.protocolHandle = protocolHandle
        args.mode = mode
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setOperatingMode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setOperatingMode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "setOperatingMode failed: unknown result")

    def getThroughputStatistics(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        self.send_getThroughputStatistics(protocolHandle)
        return self.recv_getThroughputStatistics()

    def send_getThroughputStatistics(self, protocolHandle):
        self._oprot.writeMessageBegin('getThroughputStatistics', TMessageType.CALL, self._seqid)
        args = getThroughputStatistics_args()
        args.protocolHandle = protocolHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getThroughputStatistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getThroughputStatistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getThroughputStatistics failed: unknown result")

    def getEsn(self, deviceHandle, protocolHandle):
        """
        Parameters:
         - deviceHandle
         - protocolHandle

        """
        self.send_getEsn(deviceHandle, protocolHandle)
        return self.recv_getEsn()

    def send_getEsn(self, deviceHandle, protocolHandle):
        self._oprot.writeMessageBegin('getEsn', TMessageType.CALL, self._seqid)
        args = getEsn_args()
        args.deviceHandle = deviceHandle
        args.protocolHandle = protocolHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getEsn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getEsn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getEsn failed: unknown result")

    def setEsn(self, deviceHandle, protocolHandle, esn):
        """
        Parameters:
         - deviceHandle
         - protocolHandle
         - esn

        """
        self.send_setEsn(deviceHandle, protocolHandle, esn)
        return self.recv_setEsn()

    def send_setEsn(self, deviceHandle, protocolHandle, esn):
        self._oprot.writeMessageBegin('setEsn', TMessageType.CALL, self._seqid)
        args = setEsn_args()
        args.deviceHandle = deviceHandle
        args.protocolHandle = protocolHandle
        args.esn = esn
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setEsn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setEsn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "setEsn failed: unknown result")

    def getImei(self, deviceHandle, protocolHandle, subscriptionId):
        """
        Parameters:
         - deviceHandle
         - protocolHandle
         - subscriptionId

        """
        self.send_getImei(deviceHandle, protocolHandle, subscriptionId)
        return self.recv_getImei()

    def send_getImei(self, deviceHandle, protocolHandle, subscriptionId):
        self._oprot.writeMessageBegin('getImei', TMessageType.CALL, self._seqid)
        args = getImei_args()
        args.deviceHandle = deviceHandle
        args.protocolHandle = protocolHandle
        args.subscriptionId = subscriptionId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getImei(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getImei_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getImei failed: unknown result")

    def setImei(self, deviceHandle, protocolHandle, imei, subscriptionId):
        """
        Parameters:
         - deviceHandle
         - protocolHandle
         - imei
         - subscriptionId

        """
        self.send_setImei(deviceHandle, protocolHandle, imei, subscriptionId)
        return self.recv_setImei()

    def send_setImei(self, deviceHandle, protocolHandle, imei, subscriptionId):
        self._oprot.writeMessageBegin('setImei', TMessageType.CALL, self._seqid)
        args = setImei_args()
        args.deviceHandle = deviceHandle
        args.protocolHandle = protocolHandle
        args.imei = imei
        args.subscriptionId = subscriptionId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setImei(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setImei_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "setImei failed: unknown result")

    def getMeid(self, deviceHandle, protocolHandle, subscriptionId):
        """
        Parameters:
         - deviceHandle
         - protocolHandle
         - subscriptionId

        """
        self.send_getMeid(deviceHandle, protocolHandle, subscriptionId)
        return self.recv_getMeid()

    def send_getMeid(self, deviceHandle, protocolHandle, subscriptionId):
        self._oprot.writeMessageBegin('getMeid', TMessageType.CALL, self._seqid)
        args = getMeid_args()
        args.deviceHandle = deviceHandle
        args.protocolHandle = protocolHandle
        args.subscriptionId = subscriptionId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMeid(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMeid_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getMeid failed: unknown result")

    def setMeid(self, deviceHandle, protocolHandle, meid, subscriptionId):
        """
        Parameters:
         - deviceHandle
         - protocolHandle
         - meid
         - subscriptionId

        """
        self.send_setMeid(deviceHandle, protocolHandle, meid, subscriptionId)
        return self.recv_setMeid()

    def send_setMeid(self, deviceHandle, protocolHandle, meid, subscriptionId):
        self._oprot.writeMessageBegin('setMeid', TMessageType.CALL, self._seqid)
        args = setMeid_args()
        args.deviceHandle = deviceHandle
        args.protocolHandle = protocolHandle
        args.meid = meid
        args.subscriptionId = subscriptionId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setMeid(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setMeid_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "setMeid failed: unknown result")

    def checkSpc(self, deviceHandle, protocolHandle, spc):
        """
        Parameters:
         - deviceHandle
         - protocolHandle
         - spc

        """
        self.send_checkSpc(deviceHandle, protocolHandle, spc)
        return self.recv_checkSpc()

    def send_checkSpc(self, deviceHandle, protocolHandle, spc):
        self._oprot.writeMessageBegin('checkSpc', TMessageType.CALL, self._seqid)
        args = checkSpc_args()
        args.deviceHandle = deviceHandle
        args.protocolHandle = protocolHandle
        args.spc = spc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_checkSpc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = checkSpc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "checkSpc failed: unknown result")

    def getOperatingMode(self, deviceHandle, protocolHandle):
        """
        Parameters:
         - deviceHandle
         - protocolHandle

        """
        self.send_getOperatingMode(deviceHandle, protocolHandle)
        return self.recv_getOperatingMode()

    def send_getOperatingMode(self, deviceHandle, protocolHandle):
        self._oprot.writeMessageBegin('getOperatingMode', TMessageType.CALL, self._seqid)
        args = getOperatingMode_args()
        args.deviceHandle = deviceHandle
        args.protocolHandle = protocolHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getOperatingMode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getOperatingMode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getOperatingMode failed: unknown result")

    def transferImageBhi(self, programmerPath):
        """
        Parameters:
         - programmerPath

        """
        self.send_transferImageBhi(programmerPath)
        return self.recv_transferImageBhi()

    def send_transferImageBhi(self, programmerPath):
        self._oprot.writeMessageBegin('transferImageBhi', TMessageType.CALL, self._seqid)
        args = transferImageBhi_args()
        args.programmerPath = programmerPath
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_transferImageBhi(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = transferImageBhi_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "transferImageBhi failed: unknown result")

    def transferFileToDevice(self, hostPath, devicePath, options):
        """
        Parameters:
         - hostPath
         - devicePath
         - options

        """
        self.send_transferFileToDevice(hostPath, devicePath, options)
        return self.recv_transferFileToDevice()

    def send_transferFileToDevice(self, hostPath, devicePath, options):
        self._oprot.writeMessageBegin('transferFileToDevice', TMessageType.CALL, self._seqid)
        args = transferFileToDevice_args()
        args.hostPath = hostPath
        args.devicePath = devicePath
        args.options = options
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_transferFileToDevice(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = transferFileToDevice_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "transferFileToDevice failed: unknown result")

    def transferFileToHost(self, devicePath, hostPath, options):
        """
        Parameters:
         - devicePath
         - hostPath
         - options

        """
        self.send_transferFileToHost(devicePath, hostPath, options)
        return self.recv_transferFileToHost()

    def send_transferFileToHost(self, devicePath, hostPath, options):
        self._oprot.writeMessageBegin('transferFileToHost', TMessageType.CALL, self._seqid)
        args = transferFileToHost_args()
        args.devicePath = devicePath
        args.hostPath = hostPath
        args.options = options
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_transferFileToHost(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = transferFileToHost_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "transferFileToHost failed: unknown result")

    def getFileListFromDevice(self, devicePath, options):
        """
        Parameters:
         - devicePath
         - options

        """
        self.send_getFileListFromDevice(devicePath, options)
        return self.recv_getFileListFromDevice()

    def send_getFileListFromDevice(self, devicePath, options):
        self._oprot.writeMessageBegin('getFileListFromDevice', TMessageType.CALL, self._seqid)
        args = getFileListFromDevice_args()
        args.devicePath = devicePath
        args.options = options
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getFileListFromDevice(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getFileListFromDevice_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getFileListFromDevice failed: unknown result")

    def getProtocolLockStatus(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        self.send_getProtocolLockStatus(protocolHandle)
        return self.recv_getProtocolLockStatus()

    def send_getProtocolLockStatus(self, protocolHandle):
        self._oprot.writeMessageBegin('getProtocolLockStatus', TMessageType.CALL, self._seqid)
        args = getProtocolLockStatus_args()
        args.protocolHandle = protocolHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getProtocolLockStatus(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getProtocolLockStatus_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getProtocolLockStatus failed: unknown result")

    def getDeviceUsageIndicators(self, deviceHandle):
        """
        Parameters:
         - deviceHandle

        """
        self.send_getDeviceUsageIndicators(deviceHandle)
        return self.recv_getDeviceUsageIndicators()

    def send_getDeviceUsageIndicators(self, deviceHandle):
        self._oprot.writeMessageBegin('getDeviceUsageIndicators', TMessageType.CALL, self._seqid)
        args = getDeviceUsageIndicators_args()
        args.deviceHandle = deviceHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDeviceUsageIndicators(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDeviceUsageIndicators_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDeviceUsageIndicators failed: unknown result")

    def enableFunctionLog(self, deviceHandle, areas, options):
        """
        Parameters:
         - deviceHandle
         - areas
         - options

        """
        self.send_enableFunctionLog(deviceHandle, areas, options)
        return self.recv_enableFunctionLog()

    def send_enableFunctionLog(self, deviceHandle, areas, options):
        self._oprot.writeMessageBegin('enableFunctionLog', TMessageType.CALL, self._seqid)
        args = enableFunctionLog_args()
        args.deviceHandle = deviceHandle
        args.areas = areas
        args.options = options
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enableFunctionLog(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enableFunctionLog_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "enableFunctionLog failed: unknown result")

    def disableFunctionLog(self, deviceHandle, areas):
        """
        Parameters:
         - deviceHandle
         - areas

        """
        self.send_disableFunctionLog(deviceHandle, areas)
        return self.recv_disableFunctionLog()

    def send_disableFunctionLog(self, deviceHandle, areas):
        self._oprot.writeMessageBegin('disableFunctionLog', TMessageType.CALL, self._seqid)
        args = disableFunctionLog_args()
        args.deviceHandle = deviceHandle
        args.areas = areas
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disableFunctionLog(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disableFunctionLog_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "disableFunctionLog failed: unknown result")

    def enableProtocolLog(self, protocolHandle, options):
        """
        Parameters:
         - protocolHandle
         - options

        """
        self.send_enableProtocolLog(protocolHandle, options)
        return self.recv_enableProtocolLog()

    def send_enableProtocolLog(self, protocolHandle, options):
        self._oprot.writeMessageBegin('enableProtocolLog', TMessageType.CALL, self._seqid)
        args = enableProtocolLog_args()
        args.protocolHandle = protocolHandle
        args.options = options
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enableProtocolLog(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enableProtocolLog_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "enableProtocolLog failed: unknown result")

    def disableProtocolLog(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        self.send_disableProtocolLog(protocolHandle)
        return self.recv_disableProtocolLog()

    def send_disableProtocolLog(self, protocolHandle):
        self._oprot.writeMessageBegin('disableProtocolLog', TMessageType.CALL, self._seqid)
        args = disableProtocolLog_args()
        args.protocolHandle = protocolHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disableProtocolLog(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disableProtocolLog_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "disableProtocolLog failed: unknown result")

    def configureProtocol(self, protocolConfiguration):
        """
        Parameters:
         - protocolConfiguration

        """
        self.send_configureProtocol(protocolConfiguration)
        return self.recv_configureProtocol()

    def send_configureProtocol(self, protocolConfiguration):
        self._oprot.writeMessageBegin('configureProtocol', TMessageType.CALL, self._seqid)
        args = configureProtocol_args()
        args.protocolConfiguration = protocolConfiguration
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_configureProtocol(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = configureProtocol_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "configureProtocol failed: unknown result")

    def getProtocolConfiguration(self, protocolHandle):
        """
        Parameters:
         - protocolHandle

        """
        self.send_getProtocolConfiguration(protocolHandle)
        return self.recv_getProtocolConfiguration()

    def send_getProtocolConfiguration(self, protocolHandle):
        self._oprot.writeMessageBegin('getProtocolConfiguration', TMessageType.CALL, self._seqid)
        args = getProtocolConfiguration_args()
        args.protocolHandle = protocolHandle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getProtocolConfiguration(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getProtocolConfiguration_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getProtocolConfiguration failed: unknown result")

    def enableProtocolDataMonitoring(self, protocolHandleList, enable):
        """
        Parameters:
         - protocolHandleList
         - enable

        """
        self.send_enableProtocolDataMonitoring(protocolHandleList, enable)
        return self.recv_enableProtocolDataMonitoring()

    def send_enableProtocolDataMonitoring(self, protocolHandleList, enable):
        self._oprot.writeMessageBegin('enableProtocolDataMonitoring', TMessageType.CALL, self._seqid)
        args = enableProtocolDataMonitoring_args()
        args.protocolHandleList = protocolHandleList
        args.enable = enable
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enableProtocolDataMonitoring(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enableProtocolDataMonitoring_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "enableProtocolDataMonitoring failed: unknown result")

    def enableDeviceDataMonitoring(self, deviceHandleList, enable):
        """
        Parameters:
         - deviceHandleList
         - enable

        """
        self.send_enableDeviceDataMonitoring(deviceHandleList, enable)
        return self.recv_enableDeviceDataMonitoring()

    def send_enableDeviceDataMonitoring(self, deviceHandleList, enable):
        self._oprot.writeMessageBegin('enableDeviceDataMonitoring', TMessageType.CALL, self._seqid)
        args = enableDeviceDataMonitoring_args()
        args.deviceHandleList = deviceHandleList
        args.enable = enable
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enableDeviceDataMonitoring(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enableDeviceDataMonitoring_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "enableDeviceDataMonitoring failed: unknown result")

    def enableDevicePriority(self, deviceHandleList, enable):
        """
        Parameters:
         - deviceHandleList
         - enable

        """
        self.send_enableDevicePriority(deviceHandleList, enable)
        return self.recv_enableDevicePriority()

    def send_enableDevicePriority(self, deviceHandleList, enable):
        self._oprot.writeMessageBegin('enableDevicePriority', TMessageType.CALL, self._seqid)
        args = enableDevicePriority_args()
        args.deviceHandleList = deviceHandleList
        args.enable = enable
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enableDevicePriority(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enableDevicePriority_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "enableDevicePriority failed: unknown result")

    def configParameter(self, name, value):
        """
        Parameters:
         - name
         - value

        """
        self.send_configParameter(name, value)
        return self.recv_configParameter()

    def send_configParameter(self, name, value):
        self._oprot.writeMessageBegin('configParameter', TMessageType.CALL, self._seqid)
        args = configParameter_args()
        args.name = name
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_configParameter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = configParameter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "configParameter failed: unknown result")

    def getRegistrationPort(self):
        self.send_getRegistrationPort()
        return self.recv_getRegistrationPort()

    def send_getRegistrationPort(self):
        self._oprot.writeMessageBegin('getRegistrationPort', TMessageType.CALL, self._seqid)
        args = getRegistrationPort_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRegistrationPort(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRegistrationPort_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRegistrationPort failed: unknown result")

    def exitQutsApplication(self):
        self.send_exitQutsApplication()
        return self.recv_exitQutsApplication()

    def send_exitQutsApplication(self):
        self._oprot.writeMessageBegin('exitQutsApplication', TMessageType.CALL, self._seqid)
        args = exitQutsApplication_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_exitQutsApplication(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = exitQutsApplication_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "exitQutsApplication failed: unknown result")

    def lockService(self, lockInfo):
        """
        Parameters:
         - lockInfo

        """
        self.send_lockService(lockInfo)
        return self.recv_lockService()

    def send_lockService(self, lockInfo):
        self._oprot.writeMessageBegin('lockService', TMessageType.CALL, self._seqid)
        args = lockService_args()
        args.lockInfo = lockInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_lockService(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = lockService_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "lockService failed: unknown result")

    def unlockService(self, lockInfo):
        """
        Parameters:
         - lockInfo

        """
        self.send_unlockService(lockInfo)
        return self.recv_unlockService()

    def send_unlockService(self, lockInfo):
        self._oprot.writeMessageBegin('unlockService', TMessageType.CALL, self._seqid)
        args = unlockService_args()
        args.lockInfo = lockInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_unlockService(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = unlockService_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "unlockService failed: unknown result")

    def getServiceLockInfo(self, lockInfo):
        """
        Parameters:
         - lockInfo

        """
        self.send_getServiceLockInfo(lockInfo)
        return self.recv_getServiceLockInfo()

    def send_getServiceLockInfo(self, lockInfo):
        self._oprot.writeMessageBegin('getServiceLockInfo', TMessageType.CALL, self._seqid)
        args = getServiceLockInfo_args()
        args.lockInfo = lockInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getServiceLockInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getServiceLockInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getServiceLockInfo failed: unknown result")

    def configLogOptions(self, status, logOptions):
        """
        Parameters:
         - status
         - logOptions

        """
        self.send_configLogOptions(status, logOptions)
        return self.recv_configLogOptions()

    def send_configLogOptions(self, status, logOptions):
        self._oprot.writeMessageBegin('configLogOptions', TMessageType.CALL, self._seqid)
        args = configLogOptions_args()
        args.status = status
        args.logOptions = logOptions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_configLogOptions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = configLogOptions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "configLogOptions failed: unknown result")

    def getDeviceQdssConfiguration(self, queryQdssInformation):
        """
        Parameters:
         - queryQdssInformation

        """
        self.send_getDeviceQdssConfiguration(queryQdssInformation)
        return self.recv_getDeviceQdssConfiguration()

    def send_getDeviceQdssConfiguration(self, queryQdssInformation):
        self._oprot.writeMessageBegin('getDeviceQdssConfiguration', TMessageType.CALL, self._seqid)
        args = getDeviceQdssConfiguration_args()
        args.queryQdssInformation = queryQdssInformation
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDeviceQdssConfiguration(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDeviceQdssConfiguration_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDeviceQdssConfiguration failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["getLastError"] = Processor.process_getLastError
        self._processMap["getServicesList"] = Processor.process_getServicesList
        self._processMap["getDevicesForService"] = Processor.process_getDevicesForService
        self._processMap["getServicesForDevice"] = Processor.process_getServicesForDevice
        self._processMap["createService"] = Processor.process_createService
        self._processMap["createLogSessionService"] = Processor.process_createLogSessionService
        self._processMap["getDeviceList"] = Processor.process_getDeviceList
        self._processMap["getDeviceHandleFromProtocol"] = Processor.process_getDeviceHandleFromProtocol
        self._processMap["mergeDevice"] = Processor.process_mergeDevice
        self._processMap["getDeviceBuildId"] = Processor.process_getDeviceBuildId
        self._processMap["getDeviceImageInfoByProtocol"] = Processor.process_getDeviceImageInfoByProtocol
        self._processMap["getChipName"] = Processor.process_getChipName
        self._processMap["getDeviceMode"] = Processor.process_getDeviceMode
        self._processMap["getProtocolList"] = Processor.process_getProtocolList
        self._processMap["getActiveLogSession"] = Processor.process_getActiveLogSession
        self._processMap["removeDevice"] = Processor.process_removeDevice
        self._processMap["overrideUnknownProtocol"] = Processor.process_overrideUnknownProtocol
        self._processMap["addTcpConnection"] = Processor.process_addTcpConnection
        self._processMap["addTcpConnectionWithOptions"] = Processor.process_addTcpConnectionWithOptions
        self._processMap["removeTcpConnection"] = Processor.process_removeTcpConnection
        self._processMap["startTcpServer"] = Processor.process_startTcpServer
        self._processMap["startTcpServerWithOptions"] = Processor.process_startTcpServerWithOptions
        self._processMap["stopTcpServer"] = Processor.process_stopTcpServer
        self._processMap["getTcpServerList"] = Processor.process_getTcpServerList
        self._processMap["startLogging"] = Processor.process_startLogging
        self._processMap["resetLogFiles"] = Processor.process_resetLogFiles
        self._processMap["saveLogFiles"] = Processor.process_saveLogFiles
        self._processMap["saveLogFilesWithFilenames"] = Processor.process_saveLogFilesWithFilenames
        self._processMap["saveLogFilesWithSettings"] = Processor.process_saveLogFilesWithSettings
        self._processMap["getCurrentLogFileSize"] = Processor.process_getCurrentLogFileSize
        self._processMap["openLogSession"] = Processor.process_openLogSession
        self._processMap["openLogSessionWithAdvanceOptions"] = Processor.process_openLogSessionWithAdvanceOptions
        self._processMap["openLogSessionWithOptions"] = Processor.process_openLogSessionWithOptions
        self._processMap["mergeLogFiles"] = Processor.process_mergeLogFiles
        self._processMap["attachToLogSession"] = Processor.process_attachToLogSession
        self._processMap["logAnnotation"] = Processor.process_logAnnotation
        self._processMap["resetPhone"] = Processor.process_resetPhone
        self._processMap["resetPhoneByProtocol"] = Processor.process_resetPhoneByProtocol
        self._processMap["restartQmiReadyScan"] = Processor.process_restartQmiReadyScan
        self._processMap["setOperatingMode"] = Processor.process_setOperatingMode
        self._processMap["getThroughputStatistics"] = Processor.process_getThroughputStatistics
        self._processMap["getEsn"] = Processor.process_getEsn
        self._processMap["setEsn"] = Processor.process_setEsn
        self._processMap["getImei"] = Processor.process_getImei
        self._processMap["setImei"] = Processor.process_setImei
        self._processMap["getMeid"] = Processor.process_getMeid
        self._processMap["setMeid"] = Processor.process_setMeid
        self._processMap["checkSpc"] = Processor.process_checkSpc
        self._processMap["getOperatingMode"] = Processor.process_getOperatingMode
        self._processMap["transferImageBhi"] = Processor.process_transferImageBhi
        self._processMap["transferFileToDevice"] = Processor.process_transferFileToDevice
        self._processMap["transferFileToHost"] = Processor.process_transferFileToHost
        self._processMap["getFileListFromDevice"] = Processor.process_getFileListFromDevice
        self._processMap["getProtocolLockStatus"] = Processor.process_getProtocolLockStatus
        self._processMap["getDeviceUsageIndicators"] = Processor.process_getDeviceUsageIndicators
        self._processMap["enableFunctionLog"] = Processor.process_enableFunctionLog
        self._processMap["disableFunctionLog"] = Processor.process_disableFunctionLog
        self._processMap["enableProtocolLog"] = Processor.process_enableProtocolLog
        self._processMap["disableProtocolLog"] = Processor.process_disableProtocolLog
        self._processMap["configureProtocol"] = Processor.process_configureProtocol
        self._processMap["getProtocolConfiguration"] = Processor.process_getProtocolConfiguration
        self._processMap["enableProtocolDataMonitoring"] = Processor.process_enableProtocolDataMonitoring
        self._processMap["enableDeviceDataMonitoring"] = Processor.process_enableDeviceDataMonitoring
        self._processMap["enableDevicePriority"] = Processor.process_enableDevicePriority
        self._processMap["configParameter"] = Processor.process_configParameter
        self._processMap["getRegistrationPort"] = Processor.process_getRegistrationPort
        self._processMap["exitQutsApplication"] = Processor.process_exitQutsApplication
        self._processMap["lockService"] = Processor.process_lockService
        self._processMap["unlockService"] = Processor.process_unlockService
        self._processMap["getServiceLockInfo"] = Processor.process_getServiceLockInfo
        self._processMap["configLogOptions"] = Processor.process_configLogOptions
        self._processMap["getDeviceQdssConfiguration"] = Processor.process_getDeviceQdssConfiguration
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_getLastError(self, seqid, iprot, oprot):
        args = getLastError_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getLastError_result()
        try:
            result.success = self._handler.getLastError()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getLastError", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getServicesList(self, seqid, iprot, oprot):
        args = getServicesList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getServicesList_result()
        try:
            result.success = self._handler.getServicesList()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getServicesList", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDevicesForService(self, seqid, iprot, oprot):
        args = getDevicesForService_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDevicesForService_result()
        try:
            result.success = self._handler.getDevicesForService(args.serviceName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDevicesForService", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getServicesForDevice(self, seqid, iprot, oprot):
        args = getServicesForDevice_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getServicesForDevice_result()
        try:
            result.success = self._handler.getServicesForDevice(args.deviceHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getServicesForDevice", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createService(self, seqid, iprot, oprot):
        args = createService_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createService_result()
        try:
            result.success = self._handler.createService(args.serviceName, args.deviceHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createService", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createLogSessionService(self, seqid, iprot, oprot):
        args = createLogSessionService_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createLogSessionService_result()
        try:
            result.success = self._handler.createLogSessionService(args.serviceName, args.logSession, args.deviceHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createLogSessionService", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDeviceList(self, seqid, iprot, oprot):
        args = getDeviceList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDeviceList_result()
        try:
            result.success = self._handler.getDeviceList()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDeviceList", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDeviceHandleFromProtocol(self, seqid, iprot, oprot):
        args = getDeviceHandleFromProtocol_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDeviceHandleFromProtocol_result()
        try:
            result.success = self._handler.getDeviceHandleFromProtocol(args.protocolHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDeviceHandleFromProtocol", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mergeDevice(self, seqid, iprot, oprot):
        args = mergeDevice_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mergeDevice_result()
        try:
            result.success = self._handler.mergeDevice(args.sourceDeviceHandle, args.destinationDeviceHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mergeDevice", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDeviceBuildId(self, seqid, iprot, oprot):
        args = getDeviceBuildId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDeviceBuildId_result()
        try:
            result.success = self._handler.getDeviceBuildId(args.deviceHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDeviceBuildId", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDeviceImageInfoByProtocol(self, seqid, iprot, oprot):
        args = getDeviceImageInfoByProtocol_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDeviceImageInfoByProtocol_result()
        try:
            result.success = self._handler.getDeviceImageInfoByProtocol(args.protocolHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDeviceImageInfoByProtocol", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getChipName(self, seqid, iprot, oprot):
        args = getChipName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getChipName_result()
        try:
            result.success = self._handler.getChipName(args.deviceHandle, args.protocolHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getChipName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDeviceMode(self, seqid, iprot, oprot):
        args = getDeviceMode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDeviceMode_result()
        try:
            result.success = self._handler.getDeviceMode(args.deviceHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDeviceMode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getProtocolList(self, seqid, iprot, oprot):
        args = getProtocolList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getProtocolList_result()
        try:
            result.success = self._handler.getProtocolList(args.deviceHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getProtocolList", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getActiveLogSession(self, seqid, iprot, oprot):
        args = getActiveLogSession_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getActiveLogSession_result()
        try:
            result.success = self._handler.getActiveLogSession()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getActiveLogSession", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeDevice(self, seqid, iprot, oprot):
        args = removeDevice_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeDevice_result()
        try:
            result.success = self._handler.removeDevice(args.deviceHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeDevice", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_overrideUnknownProtocol(self, seqid, iprot, oprot):
        args = overrideUnknownProtocol_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = overrideUnknownProtocol_result()
        try:
            result.success = self._handler.overrideUnknownProtocol(args.protocolHandle, args.newType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("overrideUnknownProtocol", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_addTcpConnection(self, seqid, iprot, oprot):
        args = addTcpConnection_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addTcpConnection_result()
        try:
            result.success = self._handler.addTcpConnection(args.deviceHandle, args.protocolType, args.bIsClient, args.description, args.host, args.port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("addTcpConnection", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_addTcpConnectionWithOptions(self, seqid, iprot, oprot):
        args = addTcpConnectionWithOptions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addTcpConnectionWithOptions_result()
        try:
            result.success = self._handler.addTcpConnectionWithOptions(args.host, args.port, args.options)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("addTcpConnectionWithOptions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeTcpConnection(self, seqid, iprot, oprot):
        args = removeTcpConnection_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeTcpConnection_result()
        try:
            result.success = self._handler.removeTcpConnection(args.protocolHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeTcpConnection", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_startTcpServer(self, seqid, iprot, oprot):
        args = startTcpServer_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = startTcpServer_result()
        try:
            result.success = self._handler.startTcpServer(args.protocolType, args.port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("startTcpServer", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_startTcpServerWithOptions(self, seqid, iprot, oprot):
        args = startTcpServerWithOptions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = startTcpServerWithOptions_result()
        try:
            result.success = self._handler.startTcpServerWithOptions(args.port, args.options)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("startTcpServerWithOptions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_stopTcpServer(self, seqid, iprot, oprot):
        args = stopTcpServer_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = stopTcpServer_result()
        try:
            result.success = self._handler.stopTcpServer(args.port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("stopTcpServer", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTcpServerList(self, seqid, iprot, oprot):
        args = getTcpServerList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTcpServerList_result()
        try:
            result.success = self._handler.getTcpServerList()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getTcpServerList", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_startLogging(self, seqid, iprot, oprot):
        args = startLogging_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = startLogging_result()
        try:
            result.success = self._handler.startLogging()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("startLogging", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_resetLogFiles(self, seqid, iprot, oprot):
        args = resetLogFiles_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = resetLogFiles_result()
        try:
            result.success = self._handler.resetLogFiles()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("resetLogFiles", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_saveLogFiles(self, seqid, iprot, oprot):
        args = saveLogFiles_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = saveLogFiles_result()
        try:
            result.success = self._handler.saveLogFiles(args.saveFolder)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("saveLogFiles", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_saveLogFilesWithFilenames(self, seqid, iprot, oprot):
        args = saveLogFilesWithFilenames_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = saveLogFilesWithFilenames_result()
        try:
            result.success = self._handler.saveLogFilesWithFilenames(args.logNameConfig)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("saveLogFilesWithFilenames", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_saveLogFilesWithSettings(self, seqid, iprot, oprot):
        args = saveLogFilesWithSettings_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = saveLogFilesWithSettings_result()
        try:
            result.success = self._handler.saveLogFilesWithSettings(args.saveLogFileSettings)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("saveLogFilesWithSettings", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCurrentLogFileSize(self, seqid, iprot, oprot):
        args = getCurrentLogFileSize_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCurrentLogFileSize_result()
        try:
            result.success = self._handler.getCurrentLogFileSize(args.protocolHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCurrentLogFileSize", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_openLogSession(self, seqid, iprot, oprot):
        args = openLogSession_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = openLogSession_result()
        try:
            result.success = self._handler.openLogSession(args.logFiles)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("openLogSession", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_openLogSessionWithAdvanceOptions(self, seqid, iprot, oprot):
        args = openLogSessionWithAdvanceOptions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = openLogSessionWithAdvanceOptions_result()
        try:
            result.success = self._handler.openLogSessionWithAdvanceOptions(args.logFiles, args.openFileOptions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("openLogSessionWithAdvanceOptions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_openLogSessionWithOptions(self, seqid, iprot, oprot):
        args = openLogSessionWithOptions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = openLogSessionWithOptions_result()
        try:
            result.success = self._handler.openLogSessionWithOptions(args.openFileOptions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("openLogSessionWithOptions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mergeLogFiles(self, seqid, iprot, oprot):
        args = mergeLogFiles_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mergeLogFiles_result()
        try:
            result.success = self._handler.mergeLogFiles(args.logFiles, args.destinationFolder, args.saveFileName, args.bUseDiagTimestamp)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mergeLogFiles", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_attachToLogSession(self, seqid, iprot, oprot):
        args = attachToLogSession_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = attachToLogSession_result()
        try:
            result.success = self._handler.attachToLogSession(args.clientId, args.logSession)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("attachToLogSession", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_logAnnotation(self, seqid, iprot, oprot):
        args = logAnnotation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = logAnnotation_result()
        try:
            result.success = self._handler.logAnnotation(args.annotation, args.messageId, args.protocolHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("logAnnotation", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_resetPhone(self, seqid, iprot, oprot):
        args = resetPhone_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = resetPhone_result()
        try:
            result.success = self._handler.resetPhone(args.deviceHandle, args.resetTimeout)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("resetPhone", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_resetPhoneByProtocol(self, seqid, iprot, oprot):
        args = resetPhoneByProtocol_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = resetPhoneByProtocol_result()
        try:
            result.success = self._handler.resetPhoneByProtocol(args.deviceHandle, args.protocolHandle, args.resetTimeout)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("resetPhoneByProtocol", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_restartQmiReadyScan(self, seqid, iprot, oprot):
        args = restartQmiReadyScan_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = restartQmiReadyScan_result()
        try:
            result.success = self._handler.restartQmiReadyScan(args.protocolHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("restartQmiReadyScan", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setOperatingMode(self, seqid, iprot, oprot):
        args = setOperatingMode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setOperatingMode_result()
        try:
            result.success = self._handler.setOperatingMode(args.deviceHandle, args.protocolHandle, args.mode)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setOperatingMode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getThroughputStatistics(self, seqid, iprot, oprot):
        args = getThroughputStatistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getThroughputStatistics_result()
        try:
            result.success = self._handler.getThroughputStatistics(args.protocolHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getThroughputStatistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getEsn(self, seqid, iprot, oprot):
        args = getEsn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getEsn_result()
        try:
            result.success = self._handler.getEsn(args.deviceHandle, args.protocolHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getEsn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setEsn(self, seqid, iprot, oprot):
        args = setEsn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setEsn_result()
        try:
            result.success = self._handler.setEsn(args.deviceHandle, args.protocolHandle, args.esn)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setEsn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getImei(self, seqid, iprot, oprot):
        args = getImei_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getImei_result()
        try:
            result.success = self._handler.getImei(args.deviceHandle, args.protocolHandle, args.subscriptionId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getImei", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setImei(self, seqid, iprot, oprot):
        args = setImei_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setImei_result()
        try:
            result.success = self._handler.setImei(args.deviceHandle, args.protocolHandle, args.imei, args.subscriptionId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setImei", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getMeid(self, seqid, iprot, oprot):
        args = getMeid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMeid_result()
        try:
            result.success = self._handler.getMeid(args.deviceHandle, args.protocolHandle, args.subscriptionId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getMeid", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setMeid(self, seqid, iprot, oprot):
        args = setMeid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setMeid_result()
        try:
            result.success = self._handler.setMeid(args.deviceHandle, args.protocolHandle, args.meid, args.subscriptionId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setMeid", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_checkSpc(self, seqid, iprot, oprot):
        args = checkSpc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = checkSpc_result()
        try:
            result.success = self._handler.checkSpc(args.deviceHandle, args.protocolHandle, args.spc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("checkSpc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getOperatingMode(self, seqid, iprot, oprot):
        args = getOperatingMode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getOperatingMode_result()
        try:
            result.success = self._handler.getOperatingMode(args.deviceHandle, args.protocolHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getOperatingMode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_transferImageBhi(self, seqid, iprot, oprot):
        args = transferImageBhi_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = transferImageBhi_result()
        try:
            result.success = self._handler.transferImageBhi(args.programmerPath)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("transferImageBhi", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_transferFileToDevice(self, seqid, iprot, oprot):
        args = transferFileToDevice_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = transferFileToDevice_result()
        try:
            result.success = self._handler.transferFileToDevice(args.hostPath, args.devicePath, args.options)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("transferFileToDevice", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_transferFileToHost(self, seqid, iprot, oprot):
        args = transferFileToHost_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = transferFileToHost_result()
        try:
            result.success = self._handler.transferFileToHost(args.devicePath, args.hostPath, args.options)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("transferFileToHost", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getFileListFromDevice(self, seqid, iprot, oprot):
        args = getFileListFromDevice_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getFileListFromDevice_result()
        try:
            result.success = self._handler.getFileListFromDevice(args.devicePath, args.options)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getFileListFromDevice", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getProtocolLockStatus(self, seqid, iprot, oprot):
        args = getProtocolLockStatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getProtocolLockStatus_result()
        try:
            result.success = self._handler.getProtocolLockStatus(args.protocolHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getProtocolLockStatus", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDeviceUsageIndicators(self, seqid, iprot, oprot):
        args = getDeviceUsageIndicators_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDeviceUsageIndicators_result()
        try:
            result.success = self._handler.getDeviceUsageIndicators(args.deviceHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDeviceUsageIndicators", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enableFunctionLog(self, seqid, iprot, oprot):
        args = enableFunctionLog_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enableFunctionLog_result()
        try:
            result.success = self._handler.enableFunctionLog(args.deviceHandle, args.areas, args.options)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enableFunctionLog", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disableFunctionLog(self, seqid, iprot, oprot):
        args = disableFunctionLog_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disableFunctionLog_result()
        try:
            result.success = self._handler.disableFunctionLog(args.deviceHandle, args.areas)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disableFunctionLog", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enableProtocolLog(self, seqid, iprot, oprot):
        args = enableProtocolLog_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enableProtocolLog_result()
        try:
            result.success = self._handler.enableProtocolLog(args.protocolHandle, args.options)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enableProtocolLog", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disableProtocolLog(self, seqid, iprot, oprot):
        args = disableProtocolLog_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disableProtocolLog_result()
        try:
            result.success = self._handler.disableProtocolLog(args.protocolHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disableProtocolLog", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_configureProtocol(self, seqid, iprot, oprot):
        args = configureProtocol_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = configureProtocol_result()
        try:
            result.success = self._handler.configureProtocol(args.protocolConfiguration)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("configureProtocol", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getProtocolConfiguration(self, seqid, iprot, oprot):
        args = getProtocolConfiguration_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getProtocolConfiguration_result()
        try:
            result.success = self._handler.getProtocolConfiguration(args.protocolHandle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getProtocolConfiguration", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enableProtocolDataMonitoring(self, seqid, iprot, oprot):
        args = enableProtocolDataMonitoring_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enableProtocolDataMonitoring_result()
        try:
            result.success = self._handler.enableProtocolDataMonitoring(args.protocolHandleList, args.enable)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enableProtocolDataMonitoring", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enableDeviceDataMonitoring(self, seqid, iprot, oprot):
        args = enableDeviceDataMonitoring_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enableDeviceDataMonitoring_result()
        try:
            result.success = self._handler.enableDeviceDataMonitoring(args.deviceHandleList, args.enable)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enableDeviceDataMonitoring", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enableDevicePriority(self, seqid, iprot, oprot):
        args = enableDevicePriority_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enableDevicePriority_result()
        try:
            result.success = self._handler.enableDevicePriority(args.deviceHandleList, args.enable)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enableDevicePriority", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_configParameter(self, seqid, iprot, oprot):
        args = configParameter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = configParameter_result()
        try:
            result.success = self._handler.configParameter(args.name, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("configParameter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRegistrationPort(self, seqid, iprot, oprot):
        args = getRegistrationPort_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRegistrationPort_result()
        try:
            result.success = self._handler.getRegistrationPort()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRegistrationPort", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_exitQutsApplication(self, seqid, iprot, oprot):
        args = exitQutsApplication_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = exitQutsApplication_result()
        try:
            result.success = self._handler.exitQutsApplication()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("exitQutsApplication", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_lockService(self, seqid, iprot, oprot):
        args = lockService_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = lockService_result()
        try:
            result.success = self._handler.lockService(args.lockInfo)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("lockService", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_unlockService(self, seqid, iprot, oprot):
        args = unlockService_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = unlockService_result()
        try:
            result.success = self._handler.unlockService(args.lockInfo)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("unlockService", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getServiceLockInfo(self, seqid, iprot, oprot):
        args = getServiceLockInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getServiceLockInfo_result()
        try:
            result.success = self._handler.getServiceLockInfo(args.lockInfo)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getServiceLockInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_configLogOptions(self, seqid, iprot, oprot):
        args = configLogOptions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = configLogOptions_result()
        try:
            result.success = self._handler.configLogOptions(args.status, args.logOptions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("configLogOptions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDeviceQdssConfiguration(self, seqid, iprot, oprot):
        args = getDeviceQdssConfiguration_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDeviceQdssConfiguration_result()
        try:
            result.success = self._handler.getDeviceQdssConfiguration(args.queryQdssInformation)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Common.ttypes.AppException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDeviceQdssConfiguration", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class getLastError_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLastError_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLastError_args)
getLastError_args.thrift_spec = (
)


class getLastError_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Common.ttypes.ErrorType()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLastError_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLastError_result)
getLastError_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Common.ttypes.ErrorType, None], None, ),  # 0
)


class getServicesList_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getServicesList_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getServicesList_args)
getServicesList_args.thrift_spec = (
)


class getServicesList_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getServicesList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter41 in self.success:
                oprot.writeString(iter41.encode('utf-8') if sys.version_info[0] == 2 else iter41)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getServicesList_result)
getServicesList_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getDevicesForService_args(object):
    """
    Attributes:
     - serviceName

    """


    def __init__(self, serviceName=None,):
        self.serviceName = serviceName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.serviceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDevicesForService_args')
        if self.serviceName is not None:
            oprot.writeFieldBegin('serviceName', TType.STRING, 1)
            oprot.writeString(self.serviceName.encode('utf-8') if sys.version_info[0] == 2 else self.serviceName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDevicesForService_args)
getDevicesForService_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'serviceName', 'UTF8', None, ),  # 1
)


class getDevicesForService_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = iprot.readI64()
                        self.success.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDevicesForService_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I64, len(self.success))
            for iter48 in self.success:
                oprot.writeI64(iter48)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDevicesForService_result)
getDevicesForService_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getServicesForDevice_args(object):
    """
    Attributes:
     - deviceHandle

    """


    def __init__(self, deviceHandle=None,):
        self.deviceHandle = deviceHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getServicesForDevice_args')
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 1)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getServicesForDevice_args)
getServicesForDevice_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'deviceHandle', None, None, ),  # 1
)


class getServicesForDevice_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getServicesForDevice_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter55 in self.success:
                oprot.writeString(iter55.encode('utf-8') if sys.version_info[0] == 2 else iter55)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getServicesForDevice_result)
getServicesForDevice_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class createService_args(object):
    """
    Attributes:
     - serviceName
     - deviceHandle

    """


    def __init__(self, serviceName=None, deviceHandle=None,):
        self.serviceName = serviceName
        self.deviceHandle = deviceHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.serviceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createService_args')
        if self.serviceName is not None:
            oprot.writeFieldBegin('serviceName', TType.STRING, 1)
            oprot.writeString(self.serviceName.encode('utf-8') if sys.version_info[0] == 2 else self.serviceName)
            oprot.writeFieldEnd()
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 2)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createService_args)
createService_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'serviceName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'deviceHandle', None, None, ),  # 2
)


class createService_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createService_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createService_result)
createService_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class createLogSessionService_args(object):
    """
    Attributes:
     - serviceName
     - logSession
     - deviceHandle

    """


    def __init__(self, serviceName=None, logSession=None, deviceHandle=None,):
        self.serviceName = serviceName
        self.logSession = logSession
        self.deviceHandle = deviceHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.serviceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.logSession = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createLogSessionService_args')
        if self.serviceName is not None:
            oprot.writeFieldBegin('serviceName', TType.STRING, 1)
            oprot.writeString(self.serviceName.encode('utf-8') if sys.version_info[0] == 2 else self.serviceName)
            oprot.writeFieldEnd()
        if self.logSession is not None:
            oprot.writeFieldBegin('logSession', TType.STRING, 2)
            oprot.writeString(self.logSession.encode('utf-8') if sys.version_info[0] == 2 else self.logSession)
            oprot.writeFieldEnd()
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 3)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createLogSessionService_args)
createLogSessionService_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'serviceName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'logSession', 'UTF8', None, ),  # 2
    (3, TType.I64, 'deviceHandle', None, None, ),  # 3
)


class createLogSessionService_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createLogSessionService_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createLogSessionService_result)
createLogSessionService_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getDeviceList_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDeviceList_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDeviceList_args)
getDeviceList_args.thrift_spec = (
)


class getDeviceList_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = Common.ttypes.DeviceInfo()
                        _elem61.read(iprot)
                        self.success.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDeviceList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter62 in self.success:
                iter62.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDeviceList_result)
getDeviceList_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Common.ttypes.DeviceInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getDeviceHandleFromProtocol_args(object):
    """
    Attributes:
     - protocolHandle

    """


    def __init__(self, protocolHandle=None,):
        self.protocolHandle = protocolHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDeviceHandleFromProtocol_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDeviceHandleFromProtocol_args)
getDeviceHandleFromProtocol_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
)


class getDeviceHandleFromProtocol_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDeviceHandleFromProtocol_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDeviceHandleFromProtocol_result)
getDeviceHandleFromProtocol_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class mergeDevice_args(object):
    """
    Attributes:
     - sourceDeviceHandle
     - destinationDeviceHandle

    """


    def __init__(self, sourceDeviceHandle=None, destinationDeviceHandle=None,):
        self.sourceDeviceHandle = sourceDeviceHandle
        self.destinationDeviceHandle = destinationDeviceHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sourceDeviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.destinationDeviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mergeDevice_args')
        if self.sourceDeviceHandle is not None:
            oprot.writeFieldBegin('sourceDeviceHandle', TType.I64, 1)
            oprot.writeI64(self.sourceDeviceHandle)
            oprot.writeFieldEnd()
        if self.destinationDeviceHandle is not None:
            oprot.writeFieldBegin('destinationDeviceHandle', TType.I64, 2)
            oprot.writeI64(self.destinationDeviceHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mergeDevice_args)
mergeDevice_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sourceDeviceHandle', None, None, ),  # 1
    (2, TType.I64, 'destinationDeviceHandle', None, None, ),  # 2
)


class mergeDevice_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mergeDevice_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mergeDevice_result)
mergeDevice_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getDeviceBuildId_args(object):
    """
    Attributes:
     - deviceHandle

    """


    def __init__(self, deviceHandle=None,):
        self.deviceHandle = deviceHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDeviceBuildId_args')
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 1)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDeviceBuildId_args)
getDeviceBuildId_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'deviceHandle', None, None, ),  # 1
)


class getDeviceBuildId_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Common.ttypes.BuildInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDeviceBuildId_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDeviceBuildId_result)
getDeviceBuildId_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Common.ttypes.BuildInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getDeviceImageInfoByProtocol_args(object):
    """
    Attributes:
     - protocolHandle

    """


    def __init__(self, protocolHandle=None,):
        self.protocolHandle = protocolHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDeviceImageInfoByProtocol_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDeviceImageInfoByProtocol_args)
getDeviceImageInfoByProtocol_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
)


class getDeviceImageInfoByProtocol_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = Common.ttypes.ImageInfo()
                        _elem68.read(iprot)
                        self.success.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDeviceImageInfoByProtocol_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter69 in self.success:
                iter69.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDeviceImageInfoByProtocol_result)
getDeviceImageInfoByProtocol_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Common.ttypes.ImageInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getChipName_args(object):
    """
    Attributes:
     - deviceHandle
     - protocolHandle

    """


    def __init__(self, deviceHandle=None, protocolHandle=None,):
        self.deviceHandle = deviceHandle
        self.protocolHandle = protocolHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getChipName_args')
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 1)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 2)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getChipName_args)
getChipName_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'deviceHandle', None, None, ),  # 1
    (2, TType.I64, 'protocolHandle', None, None, ),  # 2
)


class getChipName_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getChipName_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getChipName_result)
getChipName_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getDeviceMode_args(object):
    """
    Attributes:
     - deviceHandle

    """


    def __init__(self, deviceHandle=None,):
        self.deviceHandle = deviceHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDeviceMode_args')
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 1)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDeviceMode_args)
getDeviceMode_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'deviceHandle', None, None, ),  # 1
)


class getDeviceMode_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDeviceMode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDeviceMode_result)
getDeviceMode_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getProtocolList_args(object):
    """
    Attributes:
     - deviceHandle

    """


    def __init__(self, deviceHandle=None,):
        self.deviceHandle = deviceHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getProtocolList_args')
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 1)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getProtocolList_args)
getProtocolList_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'deviceHandle', None, None, ),  # 1
)


class getProtocolList_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype73, _size70) = iprot.readListBegin()
                    for _i74 in range(_size70):
                        _elem75 = Common.ttypes.ProtocolInfo()
                        _elem75.read(iprot)
                        self.success.append(_elem75)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getProtocolList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter76 in self.success:
                iter76.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getProtocolList_result)
getProtocolList_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Common.ttypes.ProtocolInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getActiveLogSession_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getActiveLogSession_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getActiveLogSession_args)
getActiveLogSession_args.thrift_spec = (
)


class getActiveLogSession_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getActiveLogSession_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getActiveLogSession_result)
getActiveLogSession_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class removeDevice_args(object):
    """
    Attributes:
     - deviceHandle

    """


    def __init__(self, deviceHandle=None,):
        self.deviceHandle = deviceHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeDevice_args')
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 1)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeDevice_args)
removeDevice_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'deviceHandle', None, None, ),  # 1
)


class removeDevice_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeDevice_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeDevice_result)
removeDevice_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class overrideUnknownProtocol_args(object):
    """
    Attributes:
     - protocolHandle
     - newType

    """


    def __init__(self, protocolHandle=None, newType=None,):
        self.protocolHandle = protocolHandle
        self.newType = newType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.newType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('overrideUnknownProtocol_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.newType is not None:
            oprot.writeFieldBegin('newType', TType.I32, 2)
            oprot.writeI32(self.newType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(overrideUnknownProtocol_args)
overrideUnknownProtocol_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
    (2, TType.I32, 'newType', None, None, ),  # 2
)


class overrideUnknownProtocol_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('overrideUnknownProtocol_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(overrideUnknownProtocol_result)
overrideUnknownProtocol_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class addTcpConnection_args(object):
    """
    Attributes:
     - deviceHandle
     - protocolType
     - bIsClient
     - description
     - host
     - port

    """


    def __init__(self, deviceHandle=None, protocolType=None, bIsClient=None, description=None, host=None, port=None,):
        self.deviceHandle = deviceHandle
        self.protocolType = protocolType
        self.bIsClient = bIsClient
        self.description = description
        self.host = host
        self.port = port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.protocolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.bIsClient = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.description = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.host = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addTcpConnection_args')
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 1)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        if self.protocolType is not None:
            oprot.writeFieldBegin('protocolType', TType.I32, 2)
            oprot.writeI32(self.protocolType)
            oprot.writeFieldEnd()
        if self.bIsClient is not None:
            oprot.writeFieldBegin('bIsClient', TType.BOOL, 3)
            oprot.writeBool(self.bIsClient)
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin('description', TType.STRING, 4)
            oprot.writeString(self.description.encode('utf-8') if sys.version_info[0] == 2 else self.description)
            oprot.writeFieldEnd()
        if self.host is not None:
            oprot.writeFieldBegin('host', TType.STRING, 5)
            oprot.writeString(self.host.encode('utf-8') if sys.version_info[0] == 2 else self.host)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 6)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addTcpConnection_args)
addTcpConnection_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'deviceHandle', None, None, ),  # 1
    (2, TType.I32, 'protocolType', None, None, ),  # 2
    (3, TType.BOOL, 'bIsClient', None, None, ),  # 3
    (4, TType.STRING, 'description', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'host', 'UTF8', None, ),  # 5
    (6, TType.I32, 'port', None, None, ),  # 6
)


class addTcpConnection_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Common.ttypes.ProtocolInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addTcpConnection_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addTcpConnection_result)
addTcpConnection_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Common.ttypes.ProtocolInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class addTcpConnectionWithOptions_args(object):
    """
    Attributes:
     - host
     - port
     - options

    """


    def __init__(self, host=None, port=None, options=None,):
        self.host = host
        self.port = port
        self.options = options

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.host = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.options = Common.ttypes.TcpOptions()
                    self.options.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addTcpConnectionWithOptions_args')
        if self.host is not None:
            oprot.writeFieldBegin('host', TType.STRING, 1)
            oprot.writeString(self.host.encode('utf-8') if sys.version_info[0] == 2 else self.host)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 2)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin('options', TType.STRUCT, 3)
            self.options.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addTcpConnectionWithOptions_args)
addTcpConnectionWithOptions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'host', 'UTF8', None, ),  # 1
    (2, TType.I32, 'port', None, None, ),  # 2
    (3, TType.STRUCT, 'options', [Common.ttypes.TcpOptions, None], None, ),  # 3
)


class addTcpConnectionWithOptions_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Common.ttypes.ProtocolInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addTcpConnectionWithOptions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addTcpConnectionWithOptions_result)
addTcpConnectionWithOptions_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Common.ttypes.ProtocolInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class removeTcpConnection_args(object):
    """
    Attributes:
     - protocolHandle

    """


    def __init__(self, protocolHandle=None,):
        self.protocolHandle = protocolHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeTcpConnection_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeTcpConnection_args)
removeTcpConnection_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
)


class removeTcpConnection_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeTcpConnection_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeTcpConnection_result)
removeTcpConnection_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class startTcpServer_args(object):
    """
    Attributes:
     - protocolType
     - port

    """


    def __init__(self, protocolType=None, port=None,):
        self.protocolType = protocolType
        self.port = port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('startTcpServer_args')
        if self.protocolType is not None:
            oprot.writeFieldBegin('protocolType', TType.I32, 1)
            oprot.writeI32(self.protocolType)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 2)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(startTcpServer_args)
startTcpServer_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocolType', None, None, ),  # 1
    (2, TType.I32, 'port', None, None, ),  # 2
)


class startTcpServer_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('startTcpServer_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(startTcpServer_result)
startTcpServer_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class startTcpServerWithOptions_args(object):
    """
    Attributes:
     - port
     - options

    """


    def __init__(self, port=None, options=None,):
        self.port = port
        self.options = options

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.options = Common.ttypes.TcpOptions()
                    self.options.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('startTcpServerWithOptions_args')
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 1)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin('options', TType.STRUCT, 2)
            self.options.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(startTcpServerWithOptions_args)
startTcpServerWithOptions_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'port', None, None, ),  # 1
    (2, TType.STRUCT, 'options', [Common.ttypes.TcpOptions, None], None, ),  # 2
)


class startTcpServerWithOptions_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('startTcpServerWithOptions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(startTcpServerWithOptions_result)
startTcpServerWithOptions_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class stopTcpServer_args(object):
    """
    Attributes:
     - port

    """


    def __init__(self, port=None,):
        self.port = port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stopTcpServer_args')
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 1)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stopTcpServer_args)
stopTcpServer_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'port', None, None, ),  # 1
)


class stopTcpServer_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stopTcpServer_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stopTcpServer_result)
stopTcpServer_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getTcpServerList_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTcpServerList_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTcpServerList_args)
getTcpServerList_args.thrift_spec = (
)


class getTcpServerList_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype80, _size77) = iprot.readListBegin()
                    for _i81 in range(_size77):
                        _elem82 = iprot.readI32()
                        self.success.append(_elem82)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTcpServerList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter83 in self.success:
                oprot.writeI32(iter83)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTcpServerList_result)
getTcpServerList_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class startLogging_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('startLogging_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(startLogging_args)
startLogging_args.thrift_spec = (
)


class startLogging_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('startLogging_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(startLogging_result)
startLogging_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class resetLogFiles_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resetLogFiles_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resetLogFiles_args)
resetLogFiles_args.thrift_spec = (
)


class resetLogFiles_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resetLogFiles_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resetLogFiles_result)
resetLogFiles_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class saveLogFiles_args(object):
    """
    Attributes:
     - saveFolder

    """


    def __init__(self, saveFolder=None,):
        self.saveFolder = saveFolder

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.saveFolder = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('saveLogFiles_args')
        if self.saveFolder is not None:
            oprot.writeFieldBegin('saveFolder', TType.STRING, 1)
            oprot.writeString(self.saveFolder.encode('utf-8') if sys.version_info[0] == 2 else self.saveFolder)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(saveLogFiles_args)
saveLogFiles_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'saveFolder', 'UTF8', None, ),  # 1
)


class saveLogFiles_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype87, _size84) = iprot.readListBegin()
                    for _i88 in range(_size84):
                        _elem89 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem89)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('saveLogFiles_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter90 in self.success:
                oprot.writeString(iter90.encode('utf-8') if sys.version_info[0] == 2 else iter90)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(saveLogFiles_result)
saveLogFiles_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class saveLogFilesWithFilenames_args(object):
    """
    Attributes:
     - logNameConfig

    """


    def __init__(self, logNameConfig=None,):
        self.logNameConfig = logNameConfig

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.logNameConfig = {}
                    (_ktype92, _vtype93, _size91) = iprot.readMapBegin()
                    for _i95 in range(_size91):
                        _key96 = iprot.readI64()
                        _val97 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.logNameConfig[_key96] = _val97
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('saveLogFilesWithFilenames_args')
        if self.logNameConfig is not None:
            oprot.writeFieldBegin('logNameConfig', TType.MAP, 1)
            oprot.writeMapBegin(TType.I64, TType.STRING, len(self.logNameConfig))
            for kiter98, viter99 in self.logNameConfig.items():
                oprot.writeI64(kiter98)
                oprot.writeString(viter99.encode('utf-8') if sys.version_info[0] == 2 else viter99)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(saveLogFilesWithFilenames_args)
saveLogFilesWithFilenames_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'logNameConfig', (TType.I64, None, TType.STRING, 'UTF8', False), None, ),  # 1
)


class saveLogFilesWithFilenames_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype103, _size100) = iprot.readListBegin()
                    for _i104 in range(_size100):
                        _elem105 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem105)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('saveLogFilesWithFilenames_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter106 in self.success:
                oprot.writeString(iter106.encode('utf-8') if sys.version_info[0] == 2 else iter106)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(saveLogFilesWithFilenames_result)
saveLogFilesWithFilenames_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class saveLogFilesWithSettings_args(object):
    """
    Attributes:
     - saveLogFileSettings

    """


    def __init__(self, saveLogFileSettings=None,):
        self.saveLogFileSettings = saveLogFileSettings

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.saveLogFileSettings = []
                    (_etype110, _size107) = iprot.readListBegin()
                    for _i111 in range(_size107):
                        _elem112 = SaveLogFileSettings()
                        _elem112.read(iprot)
                        self.saveLogFileSettings.append(_elem112)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('saveLogFilesWithSettings_args')
        if self.saveLogFileSettings is not None:
            oprot.writeFieldBegin('saveLogFileSettings', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.saveLogFileSettings))
            for iter113 in self.saveLogFileSettings:
                iter113.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(saveLogFilesWithSettings_args)
saveLogFilesWithSettings_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'saveLogFileSettings', (TType.STRUCT, [SaveLogFileSettings, None], False), None, ),  # 1
)


class saveLogFilesWithSettings_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype117, _size114) = iprot.readListBegin()
                    for _i118 in range(_size114):
                        _elem119 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem119)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('saveLogFilesWithSettings_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter120 in self.success:
                oprot.writeString(iter120.encode('utf-8') if sys.version_info[0] == 2 else iter120)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(saveLogFilesWithSettings_result)
saveLogFilesWithSettings_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getCurrentLogFileSize_args(object):
    """
    Attributes:
     - protocolHandle

    """


    def __init__(self, protocolHandle=None,):
        self.protocolHandle = protocolHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCurrentLogFileSize_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCurrentLogFileSize_args)
getCurrentLogFileSize_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
)


class getCurrentLogFileSize_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCurrentLogFileSize_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCurrentLogFileSize_result)
getCurrentLogFileSize_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class openLogSession_args(object):
    """
    Attributes:
     - logFiles

    """


    def __init__(self, logFiles=None,):
        self.logFiles = logFiles

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.logFiles = []
                    (_etype124, _size121) = iprot.readListBegin()
                    for _i125 in range(_size121):
                        _elem126 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.logFiles.append(_elem126)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('openLogSession_args')
        if self.logFiles is not None:
            oprot.writeFieldBegin('logFiles', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.logFiles))
            for iter127 in self.logFiles:
                oprot.writeString(iter127.encode('utf-8') if sys.version_info[0] == 2 else iter127)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(openLogSession_args)
openLogSession_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'logFiles', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class openLogSession_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('openLogSession_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(openLogSession_result)
openLogSession_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class openLogSessionWithAdvanceOptions_args(object):
    """
    Attributes:
     - logFiles
     - openFileOptions

    """


    def __init__(self, logFiles=None, openFileOptions=None,):
        self.logFiles = logFiles
        self.openFileOptions = openFileOptions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.logFiles = []
                    (_etype131, _size128) = iprot.readListBegin()
                    for _i132 in range(_size128):
                        _elem133 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.logFiles.append(_elem133)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.openFileOptions = OpenFileOptions()
                    self.openFileOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('openLogSessionWithAdvanceOptions_args')
        if self.logFiles is not None:
            oprot.writeFieldBegin('logFiles', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.logFiles))
            for iter134 in self.logFiles:
                oprot.writeString(iter134.encode('utf-8') if sys.version_info[0] == 2 else iter134)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.openFileOptions is not None:
            oprot.writeFieldBegin('openFileOptions', TType.STRUCT, 2)
            self.openFileOptions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(openLogSessionWithAdvanceOptions_args)
openLogSessionWithAdvanceOptions_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'logFiles', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRUCT, 'openFileOptions', [OpenFileOptions, None], None, ),  # 2
)


class openLogSessionWithAdvanceOptions_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('openLogSessionWithAdvanceOptions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(openLogSessionWithAdvanceOptions_result)
openLogSessionWithAdvanceOptions_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class openLogSessionWithOptions_args(object):
    """
    Attributes:
     - openFileOptions

    """


    def __init__(self, openFileOptions=None,):
        self.openFileOptions = openFileOptions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.openFileOptions = OpenFileOptionsCustom()
                    self.openFileOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('openLogSessionWithOptions_args')
        if self.openFileOptions is not None:
            oprot.writeFieldBegin('openFileOptions', TType.STRUCT, 1)
            self.openFileOptions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(openLogSessionWithOptions_args)
openLogSessionWithOptions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'openFileOptions', [OpenFileOptionsCustom, None], None, ),  # 1
)


class openLogSessionWithOptions_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('openLogSessionWithOptions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(openLogSessionWithOptions_result)
openLogSessionWithOptions_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class mergeLogFiles_args(object):
    """
    Attributes:
     - logFiles
     - destinationFolder
     - saveFileName
     - bUseDiagTimestamp

    """


    def __init__(self, logFiles=None, destinationFolder=None, saveFileName=None, bUseDiagTimestamp=None,):
        self.logFiles = logFiles
        self.destinationFolder = destinationFolder
        self.saveFileName = saveFileName
        self.bUseDiagTimestamp = bUseDiagTimestamp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.logFiles = []
                    (_etype138, _size135) = iprot.readListBegin()
                    for _i139 in range(_size135):
                        _elem140 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.logFiles.append(_elem140)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.destinationFolder = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.saveFileName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.bUseDiagTimestamp = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mergeLogFiles_args')
        if self.logFiles is not None:
            oprot.writeFieldBegin('logFiles', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.logFiles))
            for iter141 in self.logFiles:
                oprot.writeString(iter141.encode('utf-8') if sys.version_info[0] == 2 else iter141)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.destinationFolder is not None:
            oprot.writeFieldBegin('destinationFolder', TType.STRING, 2)
            oprot.writeString(self.destinationFolder.encode('utf-8') if sys.version_info[0] == 2 else self.destinationFolder)
            oprot.writeFieldEnd()
        if self.saveFileName is not None:
            oprot.writeFieldBegin('saveFileName', TType.STRING, 3)
            oprot.writeString(self.saveFileName.encode('utf-8') if sys.version_info[0] == 2 else self.saveFileName)
            oprot.writeFieldEnd()
        if self.bUseDiagTimestamp is not None:
            oprot.writeFieldBegin('bUseDiagTimestamp', TType.BOOL, 4)
            oprot.writeBool(self.bUseDiagTimestamp)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mergeLogFiles_args)
mergeLogFiles_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'logFiles', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'destinationFolder', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'saveFileName', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'bUseDiagTimestamp', None, None, ),  # 4
)


class mergeLogFiles_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mergeLogFiles_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mergeLogFiles_result)
mergeLogFiles_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class attachToLogSession_args(object):
    """
    Attributes:
     - clientId
     - logSession

    """


    def __init__(self, clientId=None, logSession=None,):
        self.clientId = clientId
        self.logSession = logSession

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.clientId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.logSession = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('attachToLogSession_args')
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.I32, 1)
            oprot.writeI32(self.clientId)
            oprot.writeFieldEnd()
        if self.logSession is not None:
            oprot.writeFieldBegin('logSession', TType.STRING, 2)
            oprot.writeString(self.logSession.encode('utf-8') if sys.version_info[0] == 2 else self.logSession)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(attachToLogSession_args)
attachToLogSession_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'clientId', None, None, ),  # 1
    (2, TType.STRING, 'logSession', 'UTF8', None, ),  # 2
)


class attachToLogSession_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('attachToLogSession_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(attachToLogSession_result)
attachToLogSession_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class logAnnotation_args(object):
    """
    Attributes:
     - annotation
     - messageId
     - protocolHandle

    """


    def __init__(self, annotation=None, messageId=None, protocolHandle=None,):
        self.annotation = annotation
        self.messageId = messageId
        self.protocolHandle = protocolHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.annotation = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.messageId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('logAnnotation_args')
        if self.annotation is not None:
            oprot.writeFieldBegin('annotation', TType.STRING, 1)
            oprot.writeString(self.annotation.encode('utf-8') if sys.version_info[0] == 2 else self.annotation)
            oprot.writeFieldEnd()
        if self.messageId is not None:
            oprot.writeFieldBegin('messageId', TType.I64, 2)
            oprot.writeI64(self.messageId)
            oprot.writeFieldEnd()
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 3)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(logAnnotation_args)
logAnnotation_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'annotation', 'UTF8', None, ),  # 1
    (2, TType.I64, 'messageId', None, None, ),  # 2
    (3, TType.I64, 'protocolHandle', None, None, ),  # 3
)


class logAnnotation_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('logAnnotation_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(logAnnotation_result)
logAnnotation_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class resetPhone_args(object):
    """
    Attributes:
     - deviceHandle
     - resetTimeout

    """


    def __init__(self, deviceHandle=None, resetTimeout=None,):
        self.deviceHandle = deviceHandle
        self.resetTimeout = resetTimeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.resetTimeout = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resetPhone_args')
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 1)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        if self.resetTimeout is not None:
            oprot.writeFieldBegin('resetTimeout', TType.I32, 2)
            oprot.writeI32(self.resetTimeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resetPhone_args)
resetPhone_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'deviceHandle', None, None, ),  # 1
    (2, TType.I32, 'resetTimeout', None, None, ),  # 2
)


class resetPhone_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resetPhone_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resetPhone_result)
resetPhone_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class resetPhoneByProtocol_args(object):
    """
    Attributes:
     - deviceHandle
     - protocolHandle
     - resetTimeout

    """


    def __init__(self, deviceHandle=None, protocolHandle=None, resetTimeout=None,):
        self.deviceHandle = deviceHandle
        self.protocolHandle = protocolHandle
        self.resetTimeout = resetTimeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.resetTimeout = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resetPhoneByProtocol_args')
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 1)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 2)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.resetTimeout is not None:
            oprot.writeFieldBegin('resetTimeout', TType.I32, 3)
            oprot.writeI32(self.resetTimeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resetPhoneByProtocol_args)
resetPhoneByProtocol_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'deviceHandle', None, None, ),  # 1
    (2, TType.I64, 'protocolHandle', None, None, ),  # 2
    (3, TType.I32, 'resetTimeout', None, None, ),  # 3
)


class resetPhoneByProtocol_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resetPhoneByProtocol_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resetPhoneByProtocol_result)
resetPhoneByProtocol_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class restartQmiReadyScan_args(object):
    """
    Attributes:
     - protocolHandle

    """


    def __init__(self, protocolHandle=None,):
        self.protocolHandle = protocolHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('restartQmiReadyScan_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(restartQmiReadyScan_args)
restartQmiReadyScan_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
)


class restartQmiReadyScan_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('restartQmiReadyScan_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(restartQmiReadyScan_result)
restartQmiReadyScan_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class setOperatingMode_args(object):
    """
    Attributes:
     - deviceHandle
     - protocolHandle
     - mode

    """


    def __init__(self, deviceHandle=None, protocolHandle=None, mode=None,):
        self.deviceHandle = deviceHandle
        self.protocolHandle = protocolHandle
        self.mode = mode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setOperatingMode_args')
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 1)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 2)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 3)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setOperatingMode_args)
setOperatingMode_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'deviceHandle', None, None, ),  # 1
    (2, TType.I64, 'protocolHandle', None, None, ),  # 2
    (3, TType.I32, 'mode', None, None, ),  # 3
)


class setOperatingMode_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setOperatingMode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setOperatingMode_result)
setOperatingMode_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getThroughputStatistics_args(object):
    """
    Attributes:
     - protocolHandle

    """


    def __init__(self, protocolHandle=None,):
        self.protocolHandle = protocolHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getThroughputStatistics_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getThroughputStatistics_args)
getThroughputStatistics_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
)


class getThroughputStatistics_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Common.ttypes.RxTxInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getThroughputStatistics_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getThroughputStatistics_result)
getThroughputStatistics_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Common.ttypes.RxTxInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getEsn_args(object):
    """
    Attributes:
     - deviceHandle
     - protocolHandle

    """


    def __init__(self, deviceHandle=None, protocolHandle=None,):
        self.deviceHandle = deviceHandle
        self.protocolHandle = protocolHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getEsn_args')
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 1)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 2)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getEsn_args)
getEsn_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'deviceHandle', None, None, ),  # 1
    (2, TType.I64, 'protocolHandle', None, None, ),  # 2
)


class getEsn_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getEsn_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getEsn_result)
getEsn_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class setEsn_args(object):
    """
    Attributes:
     - deviceHandle
     - protocolHandle
     - esn

    """


    def __init__(self, deviceHandle=None, protocolHandle=None, esn=None,):
        self.deviceHandle = deviceHandle
        self.protocolHandle = protocolHandle
        self.esn = esn

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.esn = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setEsn_args')
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 1)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 2)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.esn is not None:
            oprot.writeFieldBegin('esn', TType.I32, 3)
            oprot.writeI32(self.esn)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setEsn_args)
setEsn_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'deviceHandle', None, None, ),  # 1
    (2, TType.I64, 'protocolHandle', None, None, ),  # 2
    (3, TType.I32, 'esn', None, None, ),  # 3
)


class setEsn_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setEsn_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setEsn_result)
setEsn_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getImei_args(object):
    """
    Attributes:
     - deviceHandle
     - protocolHandle
     - subscriptionId

    """


    def __init__(self, deviceHandle=None, protocolHandle=None, subscriptionId=None,):
        self.deviceHandle = deviceHandle
        self.protocolHandle = protocolHandle
        self.subscriptionId = subscriptionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.subscriptionId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getImei_args')
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 1)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 2)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.subscriptionId is not None:
            oprot.writeFieldBegin('subscriptionId', TType.I32, 3)
            oprot.writeI32(self.subscriptionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getImei_args)
getImei_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'deviceHandle', None, None, ),  # 1
    (2, TType.I64, 'protocolHandle', None, None, ),  # 2
    (3, TType.I32, 'subscriptionId', None, None, ),  # 3
)


class getImei_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getImei_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getImei_result)
getImei_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class setImei_args(object):
    """
    Attributes:
     - deviceHandle
     - protocolHandle
     - imei
     - subscriptionId

    """


    def __init__(self, deviceHandle=None, protocolHandle=None, imei=None, subscriptionId=None,):
        self.deviceHandle = deviceHandle
        self.protocolHandle = protocolHandle
        self.imei = imei
        self.subscriptionId = subscriptionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.imei = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.subscriptionId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setImei_args')
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 1)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 2)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.imei is not None:
            oprot.writeFieldBegin('imei', TType.STRING, 3)
            oprot.writeBinary(self.imei)
            oprot.writeFieldEnd()
        if self.subscriptionId is not None:
            oprot.writeFieldBegin('subscriptionId', TType.I32, 4)
            oprot.writeI32(self.subscriptionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setImei_args)
setImei_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'deviceHandle', None, None, ),  # 1
    (2, TType.I64, 'protocolHandle', None, None, ),  # 2
    (3, TType.STRING, 'imei', 'BINARY', None, ),  # 3
    (4, TType.I32, 'subscriptionId', None, None, ),  # 4
)


class setImei_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setImei_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setImei_result)
setImei_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getMeid_args(object):
    """
    Attributes:
     - deviceHandle
     - protocolHandle
     - subscriptionId

    """


    def __init__(self, deviceHandle=None, protocolHandle=None, subscriptionId=None,):
        self.deviceHandle = deviceHandle
        self.protocolHandle = protocolHandle
        self.subscriptionId = subscriptionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.subscriptionId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMeid_args')
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 1)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 2)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.subscriptionId is not None:
            oprot.writeFieldBegin('subscriptionId', TType.I32, 3)
            oprot.writeI32(self.subscriptionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMeid_args)
getMeid_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'deviceHandle', None, None, ),  # 1
    (2, TType.I64, 'protocolHandle', None, None, ),  # 2
    (3, TType.I32, 'subscriptionId', None, None, ),  # 3
)


class getMeid_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMeid_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMeid_result)
getMeid_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class setMeid_args(object):
    """
    Attributes:
     - deviceHandle
     - protocolHandle
     - meid
     - subscriptionId

    """


    def __init__(self, deviceHandle=None, protocolHandle=None, meid=None, subscriptionId=None,):
        self.deviceHandle = deviceHandle
        self.protocolHandle = protocolHandle
        self.meid = meid
        self.subscriptionId = subscriptionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.meid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.subscriptionId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setMeid_args')
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 1)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 2)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.meid is not None:
            oprot.writeFieldBegin('meid', TType.I64, 3)
            oprot.writeI64(self.meid)
            oprot.writeFieldEnd()
        if self.subscriptionId is not None:
            oprot.writeFieldBegin('subscriptionId', TType.I32, 4)
            oprot.writeI32(self.subscriptionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setMeid_args)
setMeid_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'deviceHandle', None, None, ),  # 1
    (2, TType.I64, 'protocolHandle', None, None, ),  # 2
    (3, TType.I64, 'meid', None, None, ),  # 3
    (4, TType.I32, 'subscriptionId', None, None, ),  # 4
)


class setMeid_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setMeid_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setMeid_result)
setMeid_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class checkSpc_args(object):
    """
    Attributes:
     - deviceHandle
     - protocolHandle
     - spc

    """


    def __init__(self, deviceHandle=None, protocolHandle=None, spc=None,):
        self.deviceHandle = deviceHandle
        self.protocolHandle = protocolHandle
        self.spc = spc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.spc = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('checkSpc_args')
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 1)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 2)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.spc is not None:
            oprot.writeFieldBegin('spc', TType.STRING, 3)
            oprot.writeString(self.spc.encode('utf-8') if sys.version_info[0] == 2 else self.spc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(checkSpc_args)
checkSpc_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'deviceHandle', None, None, ),  # 1
    (2, TType.I64, 'protocolHandle', None, None, ),  # 2
    (3, TType.STRING, 'spc', 'UTF8', None, ),  # 3
)


class checkSpc_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SpcStatus()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('checkSpc_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(checkSpc_result)
checkSpc_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [SpcStatus, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getOperatingMode_args(object):
    """
    Attributes:
     - deviceHandle
     - protocolHandle

    """


    def __init__(self, deviceHandle=None, protocolHandle=None,):
        self.deviceHandle = deviceHandle
        self.protocolHandle = protocolHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getOperatingMode_args')
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 1)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 2)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getOperatingMode_args)
getOperatingMode_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'deviceHandle', None, None, ),  # 1
    (2, TType.I64, 'protocolHandle', None, None, ),  # 2
)


class getOperatingMode_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = OperatingModeInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getOperatingMode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getOperatingMode_result)
getOperatingMode_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [OperatingModeInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class transferImageBhi_args(object):
    """
    Attributes:
     - programmerPath

    """


    def __init__(self, programmerPath=None,):
        self.programmerPath = programmerPath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.programmerPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('transferImageBhi_args')
        if self.programmerPath is not None:
            oprot.writeFieldBegin('programmerPath', TType.STRING, 1)
            oprot.writeString(self.programmerPath.encode('utf-8') if sys.version_info[0] == 2 else self.programmerPath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(transferImageBhi_args)
transferImageBhi_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'programmerPath', 'UTF8', None, ),  # 1
)


class transferImageBhi_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('transferImageBhi_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(transferImageBhi_result)
transferImageBhi_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class transferFileToDevice_args(object):
    """
    Attributes:
     - hostPath
     - devicePath
     - options

    """


    def __init__(self, hostPath=None, devicePath=None, options=None,):
        self.hostPath = hostPath
        self.devicePath = devicePath
        self.options = options

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.hostPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.devicePath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.options = Common.ttypes.TransferFileOptions()
                    self.options.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('transferFileToDevice_args')
        if self.hostPath is not None:
            oprot.writeFieldBegin('hostPath', TType.STRING, 1)
            oprot.writeString(self.hostPath.encode('utf-8') if sys.version_info[0] == 2 else self.hostPath)
            oprot.writeFieldEnd()
        if self.devicePath is not None:
            oprot.writeFieldBegin('devicePath', TType.STRING, 2)
            oprot.writeString(self.devicePath.encode('utf-8') if sys.version_info[0] == 2 else self.devicePath)
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin('options', TType.STRUCT, 3)
            self.options.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(transferFileToDevice_args)
transferFileToDevice_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'hostPath', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'devicePath', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'options', [Common.ttypes.TransferFileOptions, None], None, ),  # 3
)


class transferFileToDevice_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Common.ttypes.TransferFileResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('transferFileToDevice_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(transferFileToDevice_result)
transferFileToDevice_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Common.ttypes.TransferFileResult, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class transferFileToHost_args(object):
    """
    Attributes:
     - devicePath
     - hostPath
     - options

    """


    def __init__(self, devicePath=None, hostPath=None, options=None,):
        self.devicePath = devicePath
        self.hostPath = hostPath
        self.options = options

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.devicePath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.hostPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.options = Common.ttypes.TransferFileOptions()
                    self.options.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('transferFileToHost_args')
        if self.devicePath is not None:
            oprot.writeFieldBegin('devicePath', TType.STRING, 1)
            oprot.writeString(self.devicePath.encode('utf-8') if sys.version_info[0] == 2 else self.devicePath)
            oprot.writeFieldEnd()
        if self.hostPath is not None:
            oprot.writeFieldBegin('hostPath', TType.STRING, 2)
            oprot.writeString(self.hostPath.encode('utf-8') if sys.version_info[0] == 2 else self.hostPath)
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin('options', TType.STRUCT, 3)
            self.options.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(transferFileToHost_args)
transferFileToHost_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'devicePath', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'hostPath', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'options', [Common.ttypes.TransferFileOptions, None], None, ),  # 3
)


class transferFileToHost_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Common.ttypes.TransferFileResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('transferFileToHost_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(transferFileToHost_result)
transferFileToHost_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Common.ttypes.TransferFileResult, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getFileListFromDevice_args(object):
    """
    Attributes:
     - devicePath
     - options

    """


    def __init__(self, devicePath=None, options=None,):
        self.devicePath = devicePath
        self.options = options

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.devicePath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.options = Common.ttypes.TransferFileOptions()
                    self.options.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getFileListFromDevice_args')
        if self.devicePath is not None:
            oprot.writeFieldBegin('devicePath', TType.STRING, 1)
            oprot.writeString(self.devicePath.encode('utf-8') if sys.version_info[0] == 2 else self.devicePath)
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin('options', TType.STRUCT, 2)
            self.options.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getFileListFromDevice_args)
getFileListFromDevice_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'devicePath', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'options', [Common.ttypes.TransferFileOptions, None], None, ),  # 2
)


class getFileListFromDevice_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype145, _size142) = iprot.readListBegin()
                    for _i146 in range(_size142):
                        _elem147 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem147)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getFileListFromDevice_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter148 in self.success:
                oprot.writeString(iter148.encode('utf-8') if sys.version_info[0] == 2 else iter148)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getFileListFromDevice_result)
getFileListFromDevice_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getProtocolLockStatus_args(object):
    """
    Attributes:
     - protocolHandle

    """


    def __init__(self, protocolHandle=None,):
        self.protocolHandle = protocolHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getProtocolLockStatus_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getProtocolLockStatus_args)
getProtocolLockStatus_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
)


class getProtocolLockStatus_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Common.ttypes.LockStatus()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getProtocolLockStatus_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getProtocolLockStatus_result)
getProtocolLockStatus_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Common.ttypes.LockStatus, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getDeviceUsageIndicators_args(object):
    """
    Attributes:
     - deviceHandle

    """


    def __init__(self, deviceHandle=None,):
        self.deviceHandle = deviceHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDeviceUsageIndicators_args')
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 1)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDeviceUsageIndicators_args)
getDeviceUsageIndicators_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'deviceHandle', None, None, ),  # 1
)


class getDeviceUsageIndicators_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Common.ttypes.UsageIndicators()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDeviceUsageIndicators_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDeviceUsageIndicators_result)
getDeviceUsageIndicators_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Common.ttypes.UsageIndicators, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class enableFunctionLog_args(object):
    """
    Attributes:
     - deviceHandle
     - areas
     - options

    """


    def __init__(self, deviceHandle=None, areas=None, options=None,):
        self.deviceHandle = deviceHandle
        self.areas = areas
        self.options = options

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.areas = []
                    (_etype152, _size149) = iprot.readListBegin()
                    for _i153 in range(_size149):
                        _elem154 = iprot.readI32()
                        self.areas.append(_elem154)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.options = Common.ttypes.LogOptions()
                    self.options.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enableFunctionLog_args')
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 1)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        if self.areas is not None:
            oprot.writeFieldBegin('areas', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.areas))
            for iter155 in self.areas:
                oprot.writeI32(iter155)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin('options', TType.STRUCT, 3)
            self.options.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enableFunctionLog_args)
enableFunctionLog_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'deviceHandle', None, None, ),  # 1
    (2, TType.LIST, 'areas', (TType.I32, None, False), None, ),  # 2
    (3, TType.STRUCT, 'options', [Common.ttypes.LogOptions, None], None, ),  # 3
)


class enableFunctionLog_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enableFunctionLog_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enableFunctionLog_result)
enableFunctionLog_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class disableFunctionLog_args(object):
    """
    Attributes:
     - deviceHandle
     - areas

    """


    def __init__(self, deviceHandle=None, areas=None,):
        self.deviceHandle = deviceHandle
        self.areas = areas

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.deviceHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.areas = []
                    (_etype159, _size156) = iprot.readListBegin()
                    for _i160 in range(_size156):
                        _elem161 = iprot.readI32()
                        self.areas.append(_elem161)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disableFunctionLog_args')
        if self.deviceHandle is not None:
            oprot.writeFieldBegin('deviceHandle', TType.I64, 1)
            oprot.writeI64(self.deviceHandle)
            oprot.writeFieldEnd()
        if self.areas is not None:
            oprot.writeFieldBegin('areas', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.areas))
            for iter162 in self.areas:
                oprot.writeI32(iter162)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disableFunctionLog_args)
disableFunctionLog_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'deviceHandle', None, None, ),  # 1
    (2, TType.LIST, 'areas', (TType.I32, None, False), None, ),  # 2
)


class disableFunctionLog_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disableFunctionLog_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disableFunctionLog_result)
disableFunctionLog_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class enableProtocolLog_args(object):
    """
    Attributes:
     - protocolHandle
     - options

    """


    def __init__(self, protocolHandle=None, options=None,):
        self.protocolHandle = protocolHandle
        self.options = options

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.options = Common.ttypes.LogOptions()
                    self.options.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enableProtocolLog_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin('options', TType.STRUCT, 2)
            self.options.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enableProtocolLog_args)
enableProtocolLog_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
    (2, TType.STRUCT, 'options', [Common.ttypes.LogOptions, None], None, ),  # 2
)


class enableProtocolLog_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enableProtocolLog_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enableProtocolLog_result)
enableProtocolLog_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class disableProtocolLog_args(object):
    """
    Attributes:
     - protocolHandle

    """


    def __init__(self, protocolHandle=None,):
        self.protocolHandle = protocolHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disableProtocolLog_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disableProtocolLog_args)
disableProtocolLog_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
)


class disableProtocolLog_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disableProtocolLog_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disableProtocolLog_result)
disableProtocolLog_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class configureProtocol_args(object):
    """
    Attributes:
     - protocolConfiguration

    """


    def __init__(self, protocolConfiguration=None,):
        self.protocolConfiguration = protocolConfiguration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.protocolConfiguration = Common.ttypes.ProtocolConfiguration()
                    self.protocolConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('configureProtocol_args')
        if self.protocolConfiguration is not None:
            oprot.writeFieldBegin('protocolConfiguration', TType.STRUCT, 1)
            self.protocolConfiguration.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(configureProtocol_args)
configureProtocol_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'protocolConfiguration', [Common.ttypes.ProtocolConfiguration, None], None, ),  # 1
)


class configureProtocol_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('configureProtocol_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(configureProtocol_result)
configureProtocol_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getProtocolConfiguration_args(object):
    """
    Attributes:
     - protocolHandle

    """


    def __init__(self, protocolHandle=None,):
        self.protocolHandle = protocolHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.protocolHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getProtocolConfiguration_args')
        if self.protocolHandle is not None:
            oprot.writeFieldBegin('protocolHandle', TType.I64, 1)
            oprot.writeI64(self.protocolHandle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getProtocolConfiguration_args)
getProtocolConfiguration_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'protocolHandle', None, None, ),  # 1
)


class getProtocolConfiguration_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Common.ttypes.ProtocolConfigurationResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getProtocolConfiguration_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getProtocolConfiguration_result)
getProtocolConfiguration_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Common.ttypes.ProtocolConfigurationResult, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class enableProtocolDataMonitoring_args(object):
    """
    Attributes:
     - protocolHandleList
     - enable

    """


    def __init__(self, protocolHandleList=None, enable=None,):
        self.protocolHandleList = protocolHandleList
        self.enable = enable

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.protocolHandleList = []
                    (_etype166, _size163) = iprot.readListBegin()
                    for _i167 in range(_size163):
                        _elem168 = iprot.readI64()
                        self.protocolHandleList.append(_elem168)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.enable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enableProtocolDataMonitoring_args')
        if self.protocolHandleList is not None:
            oprot.writeFieldBegin('protocolHandleList', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.protocolHandleList))
            for iter169 in self.protocolHandleList:
                oprot.writeI64(iter169)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.enable is not None:
            oprot.writeFieldBegin('enable', TType.BOOL, 2)
            oprot.writeBool(self.enable)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enableProtocolDataMonitoring_args)
enableProtocolDataMonitoring_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'protocolHandleList', (TType.I64, None, False), None, ),  # 1
    (2, TType.BOOL, 'enable', None, None, ),  # 2
)


class enableProtocolDataMonitoring_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enableProtocolDataMonitoring_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enableProtocolDataMonitoring_result)
enableProtocolDataMonitoring_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class enableDeviceDataMonitoring_args(object):
    """
    Attributes:
     - deviceHandleList
     - enable

    """


    def __init__(self, deviceHandleList=None, enable=None,):
        self.deviceHandleList = deviceHandleList
        self.enable = enable

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.deviceHandleList = []
                    (_etype173, _size170) = iprot.readListBegin()
                    for _i174 in range(_size170):
                        _elem175 = iprot.readI64()
                        self.deviceHandleList.append(_elem175)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.enable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enableDeviceDataMonitoring_args')
        if self.deviceHandleList is not None:
            oprot.writeFieldBegin('deviceHandleList', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.deviceHandleList))
            for iter176 in self.deviceHandleList:
                oprot.writeI64(iter176)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.enable is not None:
            oprot.writeFieldBegin('enable', TType.BOOL, 2)
            oprot.writeBool(self.enable)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enableDeviceDataMonitoring_args)
enableDeviceDataMonitoring_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'deviceHandleList', (TType.I64, None, False), None, ),  # 1
    (2, TType.BOOL, 'enable', None, None, ),  # 2
)


class enableDeviceDataMonitoring_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enableDeviceDataMonitoring_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enableDeviceDataMonitoring_result)
enableDeviceDataMonitoring_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class enableDevicePriority_args(object):
    """
    Attributes:
     - deviceHandleList
     - enable

    """


    def __init__(self, deviceHandleList=None, enable=None,):
        self.deviceHandleList = deviceHandleList
        self.enable = enable

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.deviceHandleList = []
                    (_etype180, _size177) = iprot.readListBegin()
                    for _i181 in range(_size177):
                        _elem182 = iprot.readI64()
                        self.deviceHandleList.append(_elem182)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.enable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enableDevicePriority_args')
        if self.deviceHandleList is not None:
            oprot.writeFieldBegin('deviceHandleList', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.deviceHandleList))
            for iter183 in self.deviceHandleList:
                oprot.writeI64(iter183)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.enable is not None:
            oprot.writeFieldBegin('enable', TType.BOOL, 2)
            oprot.writeBool(self.enable)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enableDevicePriority_args)
enableDevicePriority_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'deviceHandleList', (TType.I64, None, False), None, ),  # 1
    (2, TType.BOOL, 'enable', None, None, ),  # 2
)


class enableDevicePriority_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enableDevicePriority_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enableDevicePriority_result)
enableDevicePriority_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class configParameter_args(object):
    """
    Attributes:
     - name
     - value

    """


    def __init__(self, name=None, value=None,):
        self.name = name
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.value = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('configParameter_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 2)
            oprot.writeBinary(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(configParameter_args)
configParameter_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'value', 'BINARY', None, ),  # 2
)


class configParameter_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('configParameter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(configParameter_result)
configParameter_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getRegistrationPort_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRegistrationPort_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRegistrationPort_args)
getRegistrationPort_args.thrift_spec = (
)


class getRegistrationPort_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRegistrationPort_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRegistrationPort_result)
getRegistrationPort_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class exitQutsApplication_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('exitQutsApplication_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(exitQutsApplication_args)
exitQutsApplication_args.thrift_spec = (
)


class exitQutsApplication_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('exitQutsApplication_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(exitQutsApplication_result)
exitQutsApplication_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class lockService_args(object):
    """
    Attributes:
     - lockInfo

    """


    def __init__(self, lockInfo=None,):
        self.lockInfo = lockInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.lockInfo = Common.ttypes.ServiceLockInfo()
                    self.lockInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('lockService_args')
        if self.lockInfo is not None:
            oprot.writeFieldBegin('lockInfo', TType.STRUCT, 1)
            self.lockInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(lockService_args)
lockService_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'lockInfo', [Common.ttypes.ServiceLockInfo, None], None, ),  # 1
)


class lockService_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('lockService_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(lockService_result)
lockService_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class unlockService_args(object):
    """
    Attributes:
     - lockInfo

    """


    def __init__(self, lockInfo=None,):
        self.lockInfo = lockInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.lockInfo = Common.ttypes.ServiceLockInfo()
                    self.lockInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('unlockService_args')
        if self.lockInfo is not None:
            oprot.writeFieldBegin('lockInfo', TType.STRUCT, 1)
            self.lockInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(unlockService_args)
unlockService_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'lockInfo', [Common.ttypes.ServiceLockInfo, None], None, ),  # 1
)


class unlockService_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('unlockService_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(unlockService_result)
unlockService_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getServiceLockInfo_args(object):
    """
    Attributes:
     - lockInfo

    """


    def __init__(self, lockInfo=None,):
        self.lockInfo = lockInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.lockInfo = Common.ttypes.ServiceLockInfo()
                    self.lockInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getServiceLockInfo_args')
        if self.lockInfo is not None:
            oprot.writeFieldBegin('lockInfo', TType.STRUCT, 1)
            self.lockInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getServiceLockInfo_args)
getServiceLockInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'lockInfo', [Common.ttypes.ServiceLockInfo, None], None, ),  # 1
)


class getServiceLockInfo_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype187, _size184) = iprot.readListBegin()
                    for _i188 in range(_size184):
                        _elem189 = Common.ttypes.ServiceLockInfo()
                        _elem189.read(iprot)
                        self.success.append(_elem189)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getServiceLockInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter190 in self.success:
                iter190.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getServiceLockInfo_result)
getServiceLockInfo_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Common.ttypes.ServiceLockInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class configLogOptions_args(object):
    """
    Attributes:
     - status
     - logOptions

    """


    def __init__(self, status=None, logOptions=None,):
        self.status = status
        self.logOptions = logOptions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.status = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.logOptions = Common.ttypes.LogOptions()
                    self.logOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('configLogOptions_args')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.BOOL, 1)
            oprot.writeBool(self.status)
            oprot.writeFieldEnd()
        if self.logOptions is not None:
            oprot.writeFieldBegin('logOptions', TType.STRUCT, 2)
            self.logOptions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(configLogOptions_args)
configLogOptions_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'status', None, None, ),  # 1
    (2, TType.STRUCT, 'logOptions', [Common.ttypes.LogOptions, None], None, ),  # 2
)


class configLogOptions_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('configLogOptions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(configLogOptions_result)
configLogOptions_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)


class getDeviceQdssConfiguration_args(object):
    """
    Attributes:
     - queryQdssInformation

    """


    def __init__(self, queryQdssInformation=None,):
        self.queryQdssInformation = queryQdssInformation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.queryQdssInformation = QueryQdssConfiguration()
                    self.queryQdssInformation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDeviceQdssConfiguration_args')
        if self.queryQdssInformation is not None:
            oprot.writeFieldBegin('queryQdssInformation', TType.STRUCT, 1)
            self.queryQdssInformation.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDeviceQdssConfiguration_args)
getDeviceQdssConfiguration_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'queryQdssInformation', [QueryQdssConfiguration, None], None, ),  # 1
)


class getDeviceQdssConfiguration_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = DeviceQdssConfiguration()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = Common.ttypes.AppException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDeviceQdssConfiguration_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDeviceQdssConfiguration_result)
getDeviceQdssConfiguration_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [DeviceQdssConfiguration, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [Common.ttypes.AppException, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs
